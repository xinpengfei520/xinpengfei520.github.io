<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.8.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.vance.xin","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="作为一名Android 开发者，我们都有发布 APP 内测版本的经历，有的公司是发布到自己的服务器上，生成一个连接或者二维码扫描就可以下载，有的公司使用一些内测平台如蒲公英、fir.im 等，有这么好的内测平台为什么不用呢？一方面这些平台的基本都是免费提供服务的，另外一方面也提供了许多丰富的 api，方便开发者使用，提升效率！  1.前段时间研究 Android 端的自动打包，采用的是 Jenk">
<meta name="keywords" content="pgyer,Gradle,upload">
<meta property="og:type" content="article">
<meta property="og:title" content="你不知道的 Gradle 高级技巧（一）">
<meta property="og:url" content="https://www.vance.xin/2019/01/30/你不知道的 Gradle 技巧/index.html">
<meta property="og:site_name" content="程序员飞飞">
<meta property="og:description" content="作为一名Android 开发者，我们都有发布 APP 内测版本的经历，有的公司是发布到自己的服务器上，生成一个连接或者二维码扫描就可以下载，有的公司使用一些内测平台如蒲公英、fir.im 等，有这么好的内测平台为什么不用呢？一方面这些平台的基本都是免费提供服务的，另外一方面也提供了许多丰富的 api，方便开发者使用，提升效率！  1.前段时间研究 Android 端的自动打包，采用的是 Jenk">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190130093717762.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbnBlbmdmZWk1MjE=,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190130093812715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbnBlbmdmZWk1MjE=,size_16,color_FFFFFF,t_70">
<meta property="og:updated_time" content="2019-01-30T06:52:57.695Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="你不知道的 Gradle 高级技巧（一）">
<meta name="twitter:description" content="作为一名Android 开发者，我们都有发布 APP 内测版本的经历，有的公司是发布到自己的服务器上，生成一个连接或者二维码扫描就可以下载，有的公司使用一些内测平台如蒲公英、fir.im 等，有这么好的内测平台为什么不用呢？一方面这些平台的基本都是免费提供服务的，另外一方面也提供了许多丰富的 api，方便开发者使用，提升效率！  1.前段时间研究 Android 端的自动打包，采用的是 Jenk">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20190130093717762.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbnBlbmdmZWk1MjE=,size_16,color_FFFFFF,t_70">

<link rel="canonical" href="https://www.vance.xin/2019/01/30/你不知道的 Gradle 技巧/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>你不知道的 Gradle 高级技巧（一） | 程序员飞飞</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">程序员飞飞</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">码农，产品思维实践者，终身学习者，微信公众号：「程序员飞飞」。</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://www.vance.xin/2019/01/30/你不知道的 Gradle 技巧/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="程序员飞飞">
      <meta itemprop="description" content="Android、Java Developer.">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="程序员飞飞">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          你不知道的 Gradle 高级技巧（一）
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2019-01-30 14:52:30 / 修改时间：14:52:57" itemprop="dateCreated datePublished" datetime="2019-01-30T14:52:30+08:00">2019-01-30</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <blockquote>
<p>作为一名Android 开发者，我们都有发布 APP 内测版本的经历，有的公司是发布到自己的服务器上，生成一个连接或者二维码扫描就可以下载，有的公司使用一些内测平台如蒲公英、fir.im 等，有这么好的内测平台为什么不用呢？一方面这些平台的基本都是免费提供服务的，另外一方面也提供了许多丰富的 api，方便开发者使用，提升效率！</p>
</blockquote>
<h2 id="1"><a href="#1" class="headerlink" title="1."></a><em>1.</em></h2><p>前段时间研究 Android 端的自动打包，采用的是 Jenkins + Git 的方式，这样，当你 push 完代码之后，Jenkins 会自动拉取你的代码，然后再用 Gradle 工具进行自动化打包，Jenkins 可以配置许多插件，当打包完之后可以自动上传到蒲公英和 fir.im 等平台，特别方便，基本就是这么个流程，我们之前公司是运维帮我们在服务器端搭建的自动打包程序，这样的好处是当你需要打几十个包时，特别快，因为服务器的配置一般比电脑都高，并且不用占用自己电脑的资源。我自己前段时间也在自己的电脑上装了一个 Jenkins，然后一些配置，也可以进行自动化打包，但是我觉得没必要，因为你把代码 push 上去，然后再拉下来，然后再打包，用的还是你本地电脑的资源，还不如直接用 AS 打包来的快，我看了下 Jenkins 上传到公测平台的实现，其实就是用了一个 <code>curl</code> 命令来实现的，我就想着能不能在 <strong>Gradle</strong> 中配置上传的脚本？答案当然是可以的！</p>
<h2 id="2"><a href="#2" class="headerlink" title="2."></a><em>2.</em></h2><p>首先，我们了解下什么是 curl？</p>
<p>下面的概念来自某度的解释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl 命令是一个利用 URL 规则在命令行下工作的文件传输工具。它支持文件的上传和下载，所以是综合传输工具，但按传统，习惯称 curl 为下载工具。作为一款强力工具，curl 支持包括 HTTP、HTTPS、ftp 等众多协议，还支持 POST、cookies、认证、从指定偏移处下载部分文件、用户代理字符串、限速、文件大小、进度条等特征。</span><br></pre></td></tr></table></figure>
<p>简单说他就是一个命令，Linux 和 Mac 系统自带，Windows 需要安装 curl 才能使用，在哪里下载 curl?为了方便大家我已经帮大家下载好了，复制下面的字符发送到后台即可：</p>
<center><strong>curl</strong></center>

<p>里面包含 32 位 &amp; 64 位的安装程序，还有安装教程的链接供大家参考，安装完成后需要配置环境变量，然后在 cmd 中输入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --version</span><br></pre></td></tr></table></figure>
<p>如果显示 curl 的版本号说明安装成功了~</p>
<h2 id="3"><a href="#3" class="headerlink" title="3."></a><em>3.</em></h2><p>有了 curl 命令，我们就可以执行 curl 命令来进行上传文件了，我们先看下蒲公英上传 apk 的接口文档，如下图：</p>
<p><img src="https://img-blog.csdnimg.cn/20190130093717762.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbnBlbmdmZWk1MjE=,size_16,color_FFFFFF,t_70" alt="image"></p>
<p>其中，_api_key、uKey 和 file 字段是必须的，其他参数都是可选项，_api_key 和 uKey 蒲公英都会为每个 APP 自动分配一个，在你的蒲公英账号对应的 APP 的信息中可以找到，file 参数就是要上传的文件了，为了让我们上传的 APP 有每次更新的描述，我们还需要添加一个 buildUpdateDescription 字段，这样，每次上传 APP 之后就可以显示本次更新的描述信息了。</p>
<p>文档看完之后，我们需要使用 curl 命令来发送一个上传文件的 POST 请求，url 的语法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl(选项)(参数)</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20190130093812715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbnBlbmdmZWk1MjE=,size_16,color_FFFFFF,t_70" alt="image"></p>
<p>curl 命令的选项有很多，上图只是截取了其中的一部分，根据蒲公英上传 APP 的接口文档，提交的是 multipart/form-data 类型的数据，因此我们使用 -F 选项，我们可以写出伪命令了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -F 参数1 -F 参数2 -F 参数3 接口地址</span><br></pre></td></tr></table></figure>
<p>因为我们上传 APP 需要 3 个参数，所以这里也需要三个参数，后面再加上我们请求的接口地址就可以了，这应该很好理解吧？</p>
<p>我们再把参数部分替换成真实的的参数，完整的命令如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -F &quot;file=app/build/outputs/apk/release/release-v1.0.apk&quot; -F &quot;uKey=ce0e825125bfe666762b2a93feb7de00&quot; -F &quot;_api_key=534a49154990d8e9126918fbdbee600a&quot; -F &quot;buildUpdateDescription=bugs fix!&quot; https://www.pgyer.com/apiv2/app/upload</span><br></pre></td></tr></table></figure>
<p>好了，一条完整的 curl 上传命令算是完成了，其中，-F 后面的参数是字段名和参数的值，中间用 “=” 号进行连接，然后我们打开 AS 的 Terminal，执行上面的命令即可进行上传 apk 到蒲公英，上传过程也有进度显示，如果显示 100%，说明上传成功了，注意上面的 uKey 和 _api_key 的值换成你自己的，另外也要注意你打完包的 apk 文件路径要真实存在，否则会出现异常！</p>
<h2 id="4"><a href="#4" class="headerlink" title="4."></a><em>4.</em></h2><p>上面我们已经学会了使用 curl 命令上传我们的 apk 了，但是你们有没有发现，我们每次上传 apk 需要好几步：</p>
<ul>
<li>打包 apk；</li>
<li>修改上传命令中 apk 的文件名和描述信息；</li>
<li>复制 curl 命令到 Terminal 中执行；</li>
<li>…</li>
</ul>
<p>至少需要 3 步才能完成，这也是一件非常麻烦的事情，作为程序员，都是比较懒的，与其说懒不如说是机智，避免做浪费时间的事情，我再想，能不能一条命令一步到位呢？当然是可以的。</p>
<p>我们先进行改造上传命令的第一步，先把 curl 命令中 file 的值，也就是 apk 路径动态进行获取，这样就不用每次都去修改了，我们知道 gradle 语法中的字符串有两种，一种是单引号，另一种是双引号，区别就是，双引号支持插值，这样我们就可以写一个方法，这个方法的作用就是获取打包好的 apk 的全路径，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def getApkFullPath() &#123;</span><br><span class="line">    return rootDir.getAbsolutePath() + &quot;/app/build/outputs/apk/release/&quot; + getApkName()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def getApkName() &#123;</span><br><span class="line">    return &quot;update-app-example-v$&#123;android.defaultConfig.versionName&#125;-$&#123;releaseTime()&#125;.apk&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static def releaseTime() &#123;</span><br><span class="line">    return new Date().format(&quot;yyyy-MM-dd&quot;, TimeZone.getTimeZone(&quot;UTC&quot;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面总共有 3 个方法，也比较简单，大家应该都能看得懂，就不过多解释了，其中第一个方法中的 <code>rootDir.getAbsolutePath()</code> 说一下，它可以获取你当前项目在你本地电脑的全路径。</p>
<p>方法写好了，我们还需要把打包脚本稍微修改下，具体如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">release &#123;</span><br><span class="line">            minifyEnabled false</span><br><span class="line">            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;</span><br><span class="line">            signingConfig signingConfigs.release</span><br><span class="line">            android.applicationVariants.all &#123; variant -&gt;</span><br><span class="line">                variant.outputs.all &#123;</span><br><span class="line">                    outputFileName = getApkName()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>注意看上面的 <code>outputFileName = getApkName()</code>，这样写每次生成的 apk 的名字就是我们要获取的 apk 的文件名，这样每次打包完后我们都能获取到打包完后的 apk 的文件名了！这样，我们 curl 上传命令中动态获取 apk 文件路径这个问题就算解决了，我们再看下我们的 curl 命令中还有 uKey 和 _api_key 两个参数，因为这两个值属于比较私密的东西我们一般都是配置到 <code>local.properties</code> 文件中，然后动态读取的，git 默认是忽略提交 <code>local.properties</code> 文件的，这样防止自己的私密信息被提交和泄露出去，因此，这里也写个方法动态读取一下吧：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def readProperties(key) &#123;</span><br><span class="line">    File file = rootProject.file(&apos;local.properties&apos;)</span><br><span class="line">    if (file.exists()) &#123;</span><br><span class="line">        InputStream inputStream = rootProject.file(&apos;local.properties&apos;).newDataInputStream()</span><br><span class="line">        Properties properties = new Properties()</span><br><span class="line">        properties.load(inputStream)</span><br><span class="line"></span><br><span class="line">        if (properties.containsKey(key)) &#123;</span><br><span class="line">            return properties.getProperty(key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法也比较简单，相信大家都能看的明白！</p>
<p>现在我们的上传命令中还有一个字段 <code>buildUpdateDescription</code>，更新描述信息，每次上传 apk 都需要修改一下更新的描述，直接在命令中修改，也不太好，因此我们也写个方法动态获取吧，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static def getUpdateDescription() &#123;</span><br><span class="line">    return &apos;1.修复一些bug；\n2.提升用户体验！&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码，非常简单，一目了然，只要是程序员都能看得懂，如果你看不懂，说明你是伪程序员！</p>
<p>好了，终于完成了，我们最终上传的命令被改造成了这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -F &quot;file=@$&#123;getApkFullPath()&#125;&quot; -F &quot;uKey=$&#123;readProperties(&apos;pgyer.userKey&apos;)&#125;&quot; -F &quot;_api_key=$&#123;readProperties(&apos;pgyer.apiKey&apos;)&#125;&quot; -F &quot;buildUpdateDescription=$&#123;getUpdateDescription()&#125;&quot; https://www.pgyer.com/apiv2/app/upload</span><br></pre></td></tr></table></figure>
<h2 id="5"><a href="#5" class="headerlink" title="5."></a><em>5.</em></h2><p>上面的命令算是改造完成了，不知道你们有没有发现，有个致命的问题就是，这条命令怎么执行啊？因为我么你的命令中动态调用了 Gradle 中我们写的方法，直接在 Terminal 中执行肯定是会报错的！这可就尴尬了。。我们想了想，要想让我们上传命令中的方法能够被成功调用，这个命令和被调用的方法肯定是在同一个 Gradle 文件中的，我们再想能不能写一个 Task，这这个 Task 中执行我们的上传命令，这样不就解决问题了吗？嗯，想了想是可以的，我发现在写的过程中 Task 好写，但是我们这个命令怎么才能够执行呢？肯定也需要一个东西才能执行我们的命令，搜了下，Gradle 中有个 <code>exec</code> 东西，它可以执行一条具体的 bash 命令，嗯，灰常不错，可以的，very good!真香！最终我们写的完整的 Task 如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">task(&quot;uploadApk&quot;) &#123;</span><br><span class="line">        def command = &quot;curl -F \&quot;file=@$&#123;getApkFullPath()&#125;\&quot; -F \&quot;uKey=$&#123;readProperties(&apos;pgyer.userKey&apos;)&#125;\&quot; -F \&quot;_api_key=$&#123;readProperties(&apos;pgyer.apiKey&apos;)&#125;\&quot; -F \&quot;buildUpdateDescription=$&#123;getUpdateDescription()&#125;\&quot; https://www.pgyer.com/apiv2/app/upload&quot;</span><br><span class="line">        println &quot;command:&quot; + command</span><br><span class="line">        try &#123;</span><br><span class="line">            exec &#123;</span><br><span class="line">                ExecSpec execSpec -&gt;</span><br><span class="line">                    executable &apos;bash&apos;</span><br><span class="line">                    args &apos;-c&apos;, command</span><br><span class="line">            &#125;</span><br><span class="line">            println &quot;uploadApk success~&quot;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码相对也比较简单，其中 <code>ExecSpec</code> 大家可能看着比较陌生，executable ‘bash’ 为固定写法，其中 bash 代表 shell 的类型，Linux 下有很多种 shell 的类型，流行的 shell 有 ash、bash、ksh、csh、zsh 等，一般我们常用的都是 bash，其中的 command 就是一条具体的命令了。</p>
<p>这样，我们只要执行这个 Task 就可以自动执行上传命令并动态获取我们所需要的参数了~</p>
<h2 id="6"><a href="#6" class="headerlink" title="6."></a><em>6.</em></h2><p>上面的命令执行起来是非常方便的，但是在实际使用中，我们发现，需要先打完包之后才能执行上传的 Task，我们知道 Gradle 中的 Task 是可以依赖另一个 Task 的，打包命令实质上也是一个 Task，这样我们让我们自己写的 Task 依赖于打包的 Task 不就行了吗？我觉得没毛病，这样，当执行完打包后，自动执行上传命令，这样一条命令就可以解决问题，另外，我们自己的 Task 也需要稍微修改下，将上传的实现部分放到 <code>doLast</code> 闭包中，完成代码入下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">task(&quot;uploadApk&quot;) &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        def command = &quot;curl -F \&quot;file=@$&#123;getApkFullPath()&#125;\&quot; -F \&quot;uKey=$&#123;readProperties(&apos;pgyer.userKey&apos;)&#125;\&quot; -F \&quot;_api_key=$&#123;readProperties(&apos;pgyer.apiKey&apos;)&#125;\&quot; -F \&quot;buildUpdateDescription=$&#123;getUpdateDescription()&#125;\&quot; https://www.pgyer.com/apiv2/app/upload&quot;</span><br><span class="line">        println &quot;command:&quot; + command</span><br><span class="line">        try &#123;</span><br><span class="line">            exec &#123;</span><br><span class="line">                ExecSpec execSpec -&gt;</span><br><span class="line">                    executable &apos;bash&apos;</span><br><span class="line">                    args &apos;-c&apos;, command</span><br><span class="line">            &#125;</span><br><span class="line">            println &quot;uploadApk success~&quot;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uploadApk.dependsOn(&quot;assembleRelease&quot;)</span><br></pre></td></tr></table></figure>
<p>从此，我们只要在 Terminal 中执行一条命令就可以实现打包上传了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew uploadApk</span><br></pre></td></tr></table></figure>
<p>温馨提示：Windows 用户执行命令不需要加 ./</p>
<p>怎么样？是不是很爽！这个效率上的提升不是一点半点，后续我再想能不能把这个功能封装成一个 Gradle 插件的形式，提供给大家使用，这样也许是要添加一两行代码引用一下插件的就可以使用了，这样就更加方便了，敬请期待吧~</p>
<p>如果我的文章对你有用，欢迎留言！</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/pgyer/" rel="tag"># pgyer</a>
              <a href="/tags/Gradle/" rel="tag"># Gradle</a>
              <a href="/tags/upload/" rel="tag"># upload</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/01/08/一行代码实现蒲公英市场APP检查更新/" rel="prev" title="一行代码实现蒲公英市场APP检查更新">
      <i class="fa fa-chevron-left"></i> 一行代码实现蒲公英市场APP检查更新
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/05/18/RxJava2.x创建操作符之create和just (打怪升级版)！！！/" rel="next" title="RxJava2.x创建操作符之create和just (打怪升级版)！！！">
      RxJava2.x创建操作符之create和just (打怪升级版)！！！ <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1"><span class="nav-number">1.</span> <span class="nav-text">1.</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2"><span class="nav-number">2.</span> <span class="nav-text">2.</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3"><span class="nav-number">3.</span> <span class="nav-text">3.</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4"><span class="nav-number">4.</span> <span class="nav-text">4.</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5"><span class="nav-number">5.</span> <span class="nav-text">5.</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6"><span class="nav-number">6.</span> <span class="nav-text">6.</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">程序员飞飞</p>
  <div class="site-description" itemprop="description">Android、Java Developer.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">95</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">129</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">程序员飞飞</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":110,"height":180},"mobile":{"show":false},"log":false,"tagMode":false});</script></body>
</html>
