<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F12%2F05%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[《Android源码设计模式》学习笔记之 ImageLoader]]></title>
    <url>%2F2017%2F09%2F24%2F%E3%80%8AAndroid%E6%BA%90%E7%A0%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BImageLoader%2F</url>
    <content type="text"><![CDATA[需求：设计一个图片加载工具类。要求：职责单一、可扩展性强、实现三级缓存，遵循开闭原则。 1.改造前原始代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package com.anloq.sdk.imageloader;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.util.LruCache;import android.widget.ImageView;import java.net.HttpURLConnection;import java.net.URL;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * Created by xpf on 2017/10/22 :) * Function: */public class ImageLoader &#123; // 图片缓存 LruCache&lt;String, Bitmap&gt; mImageCache; // 线程池，线程池数量为CPU的数量 ExecutorService mExecutorService = Executors.newFixedThreadPool( Runtime.getRuntime().availableProcessors()); public ImageLoader() &#123; initImageCache(); &#125; /** * 初始化图片缓存大小 */ private void initImageCache() &#123; // 计算可使用的最大内存 final int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024); // 取1/4的可用内存作为缓存 final int cacheSize = maxMemory / 4; mImageCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) &#123; @Override protected int sizeOf(String key, Bitmap value) &#123; return value.getRowBytes() * value.getHeight() / 1024; &#125; &#125;; &#125; /** * 加载显示图片 * * @param url * @param imageView */ public void displayImage(final String url, final ImageView imageView) &#123; imageView.setTag(url); mExecutorService.submit(new Runnable() &#123; @Override public void run() &#123; Bitmap bitmap = downloadImage(url); if (bitmap == null) return; if (imageView.getTag().equals(url)) &#123; imageView.setImageBitmap(bitmap); &#125; mImageCache.put(url, bitmap); &#125; &#125;); &#125; /** * 下载图片 * * @param imageUrl * @return */ private Bitmap downloadImage(String imageUrl) &#123; Bitmap bitmap = null; try &#123; URL url = new URL(imageUrl); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); bitmap = BitmapFactory.decodeStream(conn.getInputStream()); conn.disconnect(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 2.遵循单一原则将原始类分为加载和缓存两个类（功能）2.1.图片加载类为：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.anloq.sdk.imageloader;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.widget.ImageView;import java.net.HttpURLConnection;import java.net.URL;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * Created by xpf on 2017/10/22 :) * Function: */public class ImageLoader &#123; // 图片缓存 ImageCache mImageCache = new ImageCache(); // 线程池，线程池数量为CPU的数量 ExecutorService mExecutorService = Executors.newFixedThreadPool( Runtime.getRuntime().availableProcessors()); /** * 加载显示图片 * * @param url * @param imageView */ public void displayImage(final String url, final ImageView imageView) &#123; // 优先从缓存中加载 Bitmap bitmap = mImageCache.get(url); if (bitmap != null) &#123; imageView.setImageBitmap(bitmap); return; &#125; imageView.setTag(url); mExecutorService.submit(new Runnable() &#123; @Override public void run() &#123; Bitmap bitmap = downloadImage(url); if (bitmap == null) return; if (imageView.getTag().equals(url)) &#123; imageView.setImageBitmap(bitmap); &#125; mImageCache.put(url, bitmap); &#125; &#125;); &#125; /** * 下载图片 * * @param imageUrl * @return */ private Bitmap downloadImage(String imageUrl) &#123; Bitmap bitmap = null; try &#123; URL url = new URL(imageUrl); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); bitmap = BitmapFactory.decodeStream(conn.getInputStream()); conn.disconnect(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 2.2.缓存类为123456789101112131415161718192021222324252627282930313233343536373839404142package com.anloq.sdk.imageloader;import android.graphics.Bitmap;import android.util.LruCache;/** * Created by xpf on 2017/10/22 :) * Function:图片缓存类 */public class ImageCache &#123; // 图片LRU缓存 LruCache&lt;String, Bitmap&gt; mImageCache; public ImageCache() &#123; initImageCache(); &#125; /** * 初始化图片缓存大小 */ private void initImageCache() &#123; // 计算可使用的最大内存 final int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024); // 取1/4的可用内存作为缓存 final int cacheSize = maxMemory / 4; mImageCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) &#123; @Override protected int sizeOf(String key, Bitmap value) &#123; return value.getRowBytes() * value.getHeight() / 1024; &#125; &#125;; &#125; public void put(String url, Bitmap bitmap) &#123; mImageCache.put(url, bitmap); &#125; public Bitmap get(String url) &#123; return mImageCache.get(url); &#125;&#125; 3.提高扩展性，增加SD卡缓存以上将代码的功能分开了，逻辑更清晰了，职责也单一了，但是可扩展性还是比较差，接下来进行增加SD卡缓存。 3.1增加SD卡缓存类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.anloq.sdk.imageloader;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;/** * Created by xpf on 2017/10/22 :) * Function: */public class DiskCache &#123; static String cacheDir = &quot;/sdcard/cache/image/&quot;; /** * 从SD卡中读取 * * @param url * @return */ public Bitmap get(String url) &#123; return BitmapFactory.decodeFile(cacheDir + url); &#125; /** * 缓存到SD卡中 * * @param url * @param bmp */ public void put(String url, Bitmap bmp) &#123; FileOutputStream fos = null; try &#123; fos = new FileOutputStream(cacheDir + url); bmp.compress(Bitmap.CompressFormat.PNG, 100, fos); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; if (fos != null) &#123; try &#123; fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 3.2ImageLoader中增加一个boolean值来设置使用哪种缓存方式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.anloq.sdk.imageloader;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.widget.ImageView;import java.net.HttpURLConnection;import java.net.URL;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * Created by xpf on 2017/10/22 :) * Function: */public class ImageLoader &#123; // 内存缓存 ImageCache mImageCache = new ImageCache(); // SD卡缓存 DiskCache mDiskCache = new DiskCache(); // 是否使用SD卡缓存 boolean isUseDiskCache = false; // 线程池，线程池数量为CPU的数量 ExecutorService mExecutorService = Executors.newFixedThreadPool( Runtime.getRuntime().availableProcessors()); /** * 加载显示图片 * * @param url * @param imageView */ public void displayImage(final String url, final ImageView imageView) &#123; // 优先从缓存中加载 Bitmap bitmap = isUseDiskCache ? mImageCache.get(url) : mDiskCache.get(url); if (bitmap != null) &#123; imageView.setImageBitmap(bitmap); return; &#125; imageView.setTag(url); mExecutorService.submit(new Runnable() &#123; @Override public void run() &#123; Bitmap bitmap = downloadImage(url); if (bitmap == null) return; if (imageView.getTag().equals(url)) &#123; imageView.setImageBitmap(bitmap); &#125; mImageCache.put(url, bitmap); &#125; &#125;); &#125; /** * 下载图片 * * @param imageUrl * @return */ private Bitmap downloadImage(String imageUrl) &#123; Bitmap bitmap = null; try &#123; URL url = new URL(imageUrl); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); bitmap = BitmapFactory.decodeStream(conn.getInputStream()); conn.disconnect(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; /** * 设置是否使用SD卡缓存 * * @param useDiskCache */ public void setUseDiskCache(boolean useDiskCache) &#123; isUseDiskCache = useDiskCache; &#125;&#125; 4.进一步改造，使用双缓存，优先使用内存加载，如果无再使用SD卡缓存以上代码修改虽然增加了SD卡缓存，但是为了节省用户的流量及加载速度我们应该设计成优先使用内存加载，如果无再使用SD卡缓存。 4.1增加双缓存类123456789101112131415161718192021222324252627282930313233343536373839package com.anloq.sdk.imageloader;import android.graphics.Bitmap;/** * Created by xpf on 2017/10/22 :) * Function: */public class DoubleCache &#123; ImageCache mMemoryCache = new ImageCache(); DiskCache mDiskCache = new DiskCache(); /** * 优先使用内存加载，如果无再使用SD卡缓存 * * @param url * @return */ public Bitmap get(String url) &#123; Bitmap bitmap = mMemoryCache.get(url); if (bitmap == null) &#123; bitmap = mDiskCache.get(url); &#125; return bitmap; &#125; /** * 将图片缓存到内存和SD卡中 * * @param url * @param bitmap */ public void put(String url, Bitmap bitmap) &#123; mMemoryCache.put(url, bitmap); mDiskCache.put(url, bitmap); &#125;&#125; 4.2ImageLoader增加双缓存配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103package com.anloq.sdk.imageloader;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.widget.ImageView;import java.net.HttpURLConnection;import java.net.URL;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * Created by xpf on 2017/10/22 :) * Function: */public class ImageLoader &#123; // 内存缓存 ImageCache mImageCache = new ImageCache(); // SD卡缓存 DiskCache mDiskCache = new DiskCache(); // 双缓存 DoubleCache mDoubleCache = new DoubleCache(); // 是否使用SD卡缓存 boolean isUseDiskCache = false; // 是否使用双缓存 boolean isUseDoubleCache = false; // 线程池，线程池数量为CPU的数量 ExecutorService mExecutorService = Executors.newFixedThreadPool( Runtime.getRuntime().availableProcessors()); /** * 加载显示图片 * * @param url * @param imageView */ public void displayImage(final String url, final ImageView imageView) &#123; // 优先从缓存中加载 Bitmap bitmap = null; if (isUseDoubleCache) &#123; bitmap = mDoubleCache.get(url); &#125; else if (isUseDiskCache) &#123; bitmap = mDiskCache.get(url); &#125; else &#123; bitmap = mImageCache.get(url); &#125; if (bitmap != null) &#123; imageView.setImageBitmap(bitmap); return; &#125; imageView.setTag(url); mExecutorService.submit(new Runnable() &#123; @Override public void run() &#123; Bitmap bitmap = downloadImage(url); if (bitmap == null) return; if (imageView.getTag().equals(url)) &#123; imageView.setImageBitmap(bitmap); &#125; mImageCache.put(url, bitmap); &#125; &#125;); &#125; /** * 下载图片 * * @param imageUrl * @return */ private Bitmap downloadImage(String imageUrl) &#123; Bitmap bitmap = null; try &#123; URL url = new URL(imageUrl); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); bitmap = BitmapFactory.decodeStream(conn.getInputStream()); conn.disconnect(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; /** * 设置是否使用SD卡缓存 * * @param useDiskCache */ public void setUseDiskCache(boolean useDiskCache) &#123; isUseDiskCache = useDiskCache; &#125; /** * 设置是否使用双缓存 * * @param useDoubleCache */ public void setUseDoubleCache(boolean useDoubleCache) &#123; isUseDoubleCache = useDoubleCache; &#125;&#125; 以上改造总算可以了，但是这样每次增加缓存策略都要修改源代码，这样很有可能引入bug,所以我们的原则是要对修改关闭，对扩展开放，这样以后有新需求的时候我们就可以使用扩展的方法来实现。 5.抽象公共方法的接口5.1接口抽取1234567891011121314package com.anloq.sdk.imageloader;import android.graphics.Bitmap;/** * Created by xpf on 2017/10/22 :) * Function: */public interface ImageCache &#123; Bitmap get(String url); void put(String url, Bitmap bitmap);&#125; 5.2ImageLoader注入接口的实现类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package com.anloq.sdk.imageloader;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.widget.ImageView;import java.net.HttpURLConnection;import java.net.URL;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * Created by xpf on 2017/10/22 :) * Function: */public class ImageLoader &#123; ImageCache mImageCache = new MemoryCache(); // 线程池，线程池数量为CPU的数量 ExecutorService mExecutorService = Executors.newFixedThreadPool( Runtime.getRuntime().availableProcessors()); /** * 注入缓存实现 * * @param mImageCache */ public void setmImageCache(ImageCache mImageCache) &#123; this.mImageCache = mImageCache; &#125; /** * 加载显示图片 * * @param url * @param imageView */ public void displayImage(final String url, final ImageView imageView) &#123; Bitmap bitmap = mImageCache.get(url); if (bitmap != null) &#123; imageView.setImageBitmap(bitmap); return; &#125; // 图片没有缓存提交到线程池中下载 submitLoadRequest(url, imageView); &#125; private void submitLoadRequest(final String url, final ImageView imageView) &#123; imageView.setTag(url); mExecutorService.submit(new Runnable() &#123; @Override public void run() &#123; Bitmap bitmap = downloadImage(url); if (bitmap == null) return; if (imageView.getTag().equals(url)) &#123; imageView.setImageBitmap(bitmap); &#125; mImageCache.put(url, bitmap); &#125; &#125;); &#125; /** * 下载图片 * * @param imageUrl * @return */ private Bitmap downloadImage(String imageUrl) &#123; Bitmap bitmap = null; try &#123; URL url = new URL(imageUrl); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); bitmap = BitmapFactory.decodeStream(conn.getInputStream()); conn.disconnect(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return bitmap; &#125;&#125; 5.3内存缓存、SD卡缓存和双缓存分别实现接口1234567891011121314151617181920212223242526272829303132333435363738394041package com.anloq.sdk.imageloader;import android.graphics.Bitmap;/** * Created by xpf on 2017/10/22 :) * Function: */public class DoubleCache implements ImageCache &#123; ImageCache mMemoryCache = new MemoryCache(); ImageCache mDiskCache = new DiskCache(); /** * 优先使用内存加载，如果无再使用SD卡缓存 * * @param url * @return */ @Override public Bitmap get(String url) &#123; Bitmap bitmap = mMemoryCache.get(url); if (bitmap == null) &#123; bitmap = mDiskCache.get(url); &#125; return bitmap; &#125; /** * 将图片缓存到内存和SD卡中 * * @param url * @param bitmap */ @Override public void put(String url, Bitmap bitmap) &#123; mMemoryCache.put(url, bitmap); mDiskCache.put(url, bitmap); &#125;&#125; 内存缓存、SD卡缓存实现同上。 6.外部调用及设置缓存策略1234567891011121314151617181920212223private void loadImage() &#123; ImageLoader imageLoader = new ImageLoader(); // 使用内存缓存 imageLoader.setmImageCache(new MemoryCache()); // 使用SD卡缓存 imageLoader.setmImageCache(new DiskCache()); // 使用双缓存 imageLoader.setmImageCache(new DoubleCache()); // 使用自定义的图片缓存 imageLoader.setmImageCache(new ImageCache() &#123; @Override public Bitmap get(String url) &#123; return null; &#125; @Override public void put(String url, Bitmap bitmap) &#123; &#125; &#125;); String imageUrl = &quot;http://p1.meituan.net/160.0.80/xianfu/5e369ac9d6aa54125ad1b6562282b2ca36024.jpeg&quot;; imageLoader.displayImage(imageUrl, imageView); &#125; 经过上述代码的重构，我们可以通过setImageCache(ImageCache cache)方法注入不同的缓存实现，来使得ImageLoader更简单、健壮、扩展性好灵活性也更高。以上三种缓存图片的具体实现完全不一样，但是它们都有一个共同的特点是都实现了ImageCache接口。当用户需要增加一种新的缓存策略时，我们只需新建一个实现ImageCache接口等待类就可以了，这样就实现了千变万化的缓存策略，并且新扩展的策略不会影响导致ImageLoader类的修改，这正是体现了“对修改关闭，对扩展开放的”原则，所以，我们在设计写代码的时候应该认真地进行思考，希望大家一起思考，一起学习，有所成长！ 源码下载链接： https://github.com/xinpengfei520/MyImageLoader 如果本文对你有帮助，欢迎大家点赞、评论，码字不易，再小的支持也是对博主的莫大鼓励！ 今天的分享就到这里注明，谢谢！ 声明：文中部分代码摘抄自《Android源码设计模式》一书。 注：本文由博主原创，转载请注明出处，谢谢！]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>ImageLoader</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
</search>
