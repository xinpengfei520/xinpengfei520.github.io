<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>IT大飞说</title>
  
  <subtitle>魔都某非著名互联网创业公司码农，一个狂热的技术人！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.x-sir.com/"/>
  <updated>2019-09-18T05:41:09.758Z</updated>
  <id>http://www.x-sir.com/</id>
  
  <author>
    <name>x-sir</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android 自定义一个简单的刮奖 View</title>
    <link href="http://www.x-sir.com/2019/09/18/Android%20%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%88%AE%E5%A5%96%20View/"/>
    <id>http://www.x-sir.com/2019/09/18/Android 自定义一个简单的刮奖 View/</id>
    <published>2019-09-18T05:40:05.000Z</published>
    <updated>2019-09-18T05:41:09.758Z</updated>
    
    <content type="html"><![CDATA[<p>实现思路：</p><p>使用相对布局，先写一个 TextView，然后自定义一个 EraseView，写一个同样大小的 EraseView 覆盖在 TextView 上面即可。</p><p>先看下效果图:</p><p><img src="https://img-blog.csdnimg.cn/20190918133340585.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbnBlbmdmZWk1MjE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>代码也比较简单，我就直接贴上了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">public class EraseView extends View &#123;</span><br><span class="line"></span><br><span class="line">    private boolean isMove = false;</span><br><span class="line">    private Bitmap bitmap = null;</span><br><span class="line">    private Bitmap frontBitmap = null;</span><br><span class="line">    private Path path;</span><br><span class="line">    private Canvas mCanvas;</span><br><span class="line">    private Paint paint;</span><br><span class="line"></span><br><span class="line">    public EraseView(Context context) &#123;</span><br><span class="line">        this(context, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public EraseView(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        this(context, attrs, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public EraseView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">        super(context, attrs, defStyleAttr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">        super.onDraw(canvas);</span><br><span class="line">        if (mCanvas == null) &#123;</span><br><span class="line">            createEraseBitmap();</span><br><span class="line">        &#125;</span><br><span class="line">        canvas.drawBitmap(bitmap, 0, 0, null);</span><br><span class="line">        mCanvas.drawPath(path, paint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void createEraseBitmap() &#123;</span><br><span class="line">        bitmap = Bitmap.createBitmap(getWidth(), getHeight(), Config.ARGB_4444);</span><br><span class="line">        frontBitmap = createBitmap(Color.GRAY, getWidth(), getHeight());</span><br><span class="line"></span><br><span class="line">        paint = new Paint();</span><br><span class="line">        paint.setStyle(Paint.Style.STROKE);</span><br><span class="line">        paint.setXfermode(new PorterDuffXfermode(Mode.CLEAR));</span><br><span class="line">        paint.setAntiAlias(true);</span><br><span class="line">        paint.setDither(true);</span><br><span class="line">        paint.setStrokeJoin(Paint.Join.ROUND);</span><br><span class="line">        paint.setStrokeCap(Paint.Cap.ROUND);</span><br><span class="line">        paint.setStrokeWidth(60);</span><br><span class="line"></span><br><span class="line">        path = new Path();</span><br><span class="line"></span><br><span class="line">        mCanvas = new Canvas(bitmap);</span><br><span class="line">        mCanvas.drawBitmap(frontBitmap, 0, 0, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        float ax = event.getX();</span><br><span class="line">        float ay = event.getY();</span><br><span class="line"></span><br><span class="line">        if (event.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            isMove = false;</span><br><span class="line">            path.reset();</span><br><span class="line">            path.moveTo(ax, ay);</span><br><span class="line">            invalidate();</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else if (event.getAction() == MotionEvent.ACTION_MOVE) &#123;</span><br><span class="line">            isMove = true;</span><br><span class="line">            path.lineTo(ax, ay);</span><br><span class="line">            invalidate();</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return super.onTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Bitmap createBitmap(int color, int width, int height) &#123;</span><br><span class="line">        int[] rgb = new int[width * height];</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; rgb.length; i++) &#123;</span><br><span class="line">            rgb[i] = color;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return Bitmap.createBitmap(rgb, width, height, Config.ARGB_8888);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，今天的分享就到这里了。</p><p>最后，我这边有个技术交流群，平常我会分享一些学习资源到群里，还可以和大家一起交流学习，需要的朋友可以扫描下面的二维码加我微信并备注「加群」，拉你进入技术交流群！</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLngtc2lyLmNvbS9Gb2lFem5ZRjVlU1FTOFdNTjYyTnpVUTRnazQw?x-oss-process=image/format,png# =337x448" alt=""></p><p>飞哥带你去装逼，一直装逼到天黑！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;实现思路：&lt;/p&gt;
&lt;p&gt;使用相对布局，先写一个 TextView，然后自定义一个 EraseView，写一个同样大小的 EraseView 覆盖在 TextView 上面即可。&lt;/p&gt;
&lt;p&gt;先看下效果图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blo
      
    
    </summary>
    
      <category term="Android" scheme="http://www.x-sir.com/categories/Android/"/>
    
    
      <category term="自定义View" scheme="http://www.x-sir.com/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="CustomView" scheme="http://www.x-sir.com/tags/CustomView/"/>
    
      <category term="刮奖" scheme="http://www.x-sir.com/tags/%E5%88%AE%E5%A5%96/"/>
    
  </entry>
  
  <entry>
    <title>Maven 项目集成 Swagger2</title>
    <link href="http://www.x-sir.com/2019/07/13/Maven%20%E9%A1%B9%E7%9B%AE%E9%9B%86%E6%88%90%20Swagger2/"/>
    <id>http://www.x-sir.com/2019/07/13/Maven 项目集成 Swagger2/</id>
    <published>2019-07-13T08:12:00.000Z</published>
    <updated>2019-07-13T08:14:04.928Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLngtc2lyLmNvbS9GZ2Q3cXZzN3l6UjcxRTdobWdJc2xVc1lPdVQ5" alt=""><br>题图：来自飞哥的图片工厂</p><p>音乐推荐：背叛<br>文丨IT大飞说<br>预计阅读时间：3.2 分钟</p><p>哈喽，朋友们，今天我们来学习下如何使用 Swagger2。</p><h2 id="什么是-Swagger"><a href="#什么是-Swagger" class="headerlink" title="什么是 Swagger?"></a>什么是 Swagger?</h2><p>Swagger 是一款 RESTFUL 接口的、基于YAML、JSON语言的文档在线自动生成、代码自动生成的工具。</p><h2 id="如何集成？"><a href="#如何集成？" class="headerlink" title="如何集成？"></a>如何集成？</h2><p>打开 pom.xml 文件，添加如下依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>注：编写本文时使用的最新版本是 2.9.2，当你看到这篇文章的时候可能会有更新，最新的版本可到 <a href="https://mvnrepository.com" target="_blank" rel="noopener">https://mvnrepository.com</a> 查看。</p><p>新建一个 Swagger2 类，完整代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableSwagger2 // 启用 Swagger</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class Swagger2 &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Docket createRestApi() &#123;</span><br><span class="line">        return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                // 为当前包路径</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(&quot;com.xpf.imoney&quot;))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 构建 api 文档的详细信息函数，注意这里的注解引用的是哪个</span><br><span class="line">     */</span><br><span class="line">    private ApiInfo apiInfo() &#123;</span><br><span class="line">        return new ApiInfoBuilder()</span><br><span class="line">                // 页面标题</span><br><span class="line">                .title(&quot;SSM Application [iMoney] Swagger2 RESTFul API&quot;)</span><br><span class="line">                // 创建人</span><br><span class="line">                .contact(new Contact(&quot;x-sir&quot;, &quot;http://www.x-sir.com&quot;, &quot;542270559@qq.com&quot;))</span><br><span class="line">                // 版本号</span><br><span class="line">                .version(&quot;1.0&quot;)</span><br><span class="line">                // 描述</span><br><span class="line">                .description(&quot;This is [iMoney] API doc&quot;)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后编译并启动你本地的服务，打开浏览器，输入下面的访问地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/JavaWeb/swagger-ui.html</span><br></pre></td></tr></table></figure><p>注：上面链接中的 JavaWeb 为你的项目名称，替换为你自己的！</p><p>正常情况下你就会看到下面的页面了：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLngtc2lyLmNvbS9GbDQ2b2p3cHY4d1hETXV1a3gyRjdDY0xmNjAt" alt=""></p><h2 id="Swagger-的几个常用注解"><a href="#Swagger-的几个常用注解" class="headerlink" title="Swagger 的几个常用注解"></a>Swagger 的几个常用注解</h2><ul><li>@Api：表示这个类是 Swagger 的资源；</li><li>@ApiOperation：用在方法上，说明方法的作用；</li><li>@ApiParam：用来修饰参数，表示对参数添加元数据；</li><li>@ApiModel：用于类，对类进行说明；</li><li>@ApiIgnore：用于类，方法，表示这个类或方法被忽略；</li><li>@ApiImplicitParam：用于方法，表示单独的请求参数；</li></ul><p>举个例子，我们的 UserController 中的简单使用，完整代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Api(value = &quot;/user&quot;, description = &quot;关于用户的一些操做。&quot;)</span><br><span class="line">@Controller</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private UserService userService;</span><br><span class="line"></span><br><span class="line">    @ResponseBody</span><br><span class="line">    @RequestMapping(value = &quot;/index&quot;)</span><br><span class="line">    @ApiOperation(value = &quot;通过 ID 查询 USER 信息&quot;, httpMethod = &quot;GET&quot;, notes = &quot;暂无&quot;)</span><br><span class="line">    public User index(@RequestParam(&quot;id&quot;) int id) &#123;</span><br><span class="line">        return userService.getUserById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本的用法就这些，好了，今天的分享就到这里了。</p><p>最后，我这边有个技术交流群，平常我会分享一些学习资源到群里，还可以和大家一起交流学习，需要的朋友可以扫描下面的二维码加我微信并备注「加群」，拉你进入技术交流群！</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLngtc2lyLmNvbS9Gb2lFem5ZRjVlU1FTOFdNTjYyTnpVUTRnazQw# =337x448" alt=""></p><p>飞哥带你去装逼，一直装逼到天黑！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLngtc2lyLmNvbS9GZ2Q3cXZzN3l6UjcxRTdobWdJc2xVc1lPdVQ5&quot; alt=&quot;&quot;&gt;&lt;br&gt;题图：来自飞哥的图片工厂&lt;/p&gt;
      
    
    </summary>
    
      <category term="JavaEE" scheme="http://www.x-sir.com/categories/JavaEE/"/>
    
    
      <category term="Maven" scheme="http://www.x-sir.com/tags/Maven/"/>
    
      <category term="Swagger" scheme="http://www.x-sir.com/tags/Swagger/"/>
    
      <category term="Swagger2" scheme="http://www.x-sir.com/tags/Swagger2/"/>
    
      <category term="Spring" scheme="http://www.x-sir.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>RxJava2.x 操作符之 compose</title>
    <link href="http://www.x-sir.com/2019/06/20/RxJava2.x%20%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B9%8B%20compose/"/>
    <id>http://www.x-sir.com/2019/06/20/RxJava2.x 操作符之 compose/</id>
    <published>2019-06-20T12:03:01.000Z</published>
    <updated>2019-06-20T12:04:19.622Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.x-sir.com/Fgd7qvs7yzR71E7hmgIslUsYOuT9" alt=""><br>题图：来自飞哥的图片工厂</p><p>音乐推荐：后来<br>文丨IT大飞说<br>预计阅读时间：2.3 分钟</p><p>哈喽，朋友们，之前我们学习了一些 RxJava2.x 的常用操作符，今天我们来继续学习一下 RxJava 的 compose 操作符。</p><p>compose 操作符能够从数据流中得到原始的被观察者，当创建被观察者时，compose 操作符会立即执行，而不像其他的操作符需要在 onNext() 调用后才能执行。</p><h2 id="使用场景一"><a href="#使用场景一" class="headerlink" title="使用场景一"></a>使用场景一</h2><p>我们可以用 compose 操作符来进行线程的切换，一般用在网络请求的地方。</p><p>原始的写法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.subscribeOn(Schedulers.io())</span><br><span class="line">.observeOn(AndroidSchedulers.mainThread())</span><br></pre></td></tr></table></figure><p>我们可以将上面的操作封装成一个简单的工具类来使用，我这里提供了 Java 版和 Kotlin 版本：</p><p>Java 版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import io.reactivex.FlowableTransformer;</span><br><span class="line">import io.reactivex.MaybeTransformer;</span><br><span class="line">import io.reactivex.ObservableTransformer;</span><br><span class="line">import io.reactivex.android.schedulers.AndroidSchedulers;</span><br><span class="line">import io.reactivex.schedulers.Schedulers;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by x-sir on 2019/4/19 :)</span><br><span class="line"> * Function:线程调度</span><br><span class="line"> */</span><br><span class="line">public class RxThreadUtils &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Flowable 切换到主线程</span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; FlowableTransformer&lt;T, T&gt; flowableToMain() &#123;</span><br><span class="line">        return upstream -&gt; upstream.subscribeOn(Schedulers.io())</span><br><span class="line">                .observeOn(AndroidSchedulers.mainThread());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Observable 切换到主线程</span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; ObservableTransformer&lt;T, T&gt; observableToMain() &#123;</span><br><span class="line">        return upstream -&gt; upstream.subscribeOn(Schedulers.io())</span><br><span class="line">                .observeOn(AndroidSchedulers.mainThread());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Maybe 切换到主线程</span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; MaybeTransformer&lt;T, T&gt; maybeToMain() &#123;</span><br><span class="line">        return upstream -&gt; upstream.subscribeOn(Schedulers.io())</span><br><span class="line">                .observeOn(AndroidSchedulers.mainThread());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kotlin 版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import io.reactivex.FlowableTransformer</span><br><span class="line">import io.reactivex.MaybeTransformer</span><br><span class="line">import io.reactivex.ObservableTransformer</span><br><span class="line">import io.reactivex.android.schedulers.AndroidSchedulers</span><br><span class="line">import io.reactivex.schedulers.Schedulers</span><br><span class="line">import java.util.concurrent.TimeUnit</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by x-sir on 2019-06-02 :)</span><br><span class="line"> * Function:RxJava2.x 线程切换工具类</span><br><span class="line"> */</span><br><span class="line">object RxThreadUtils &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Observable 切换到主线程</span><br><span class="line">     */</span><br><span class="line">    fun &lt;T&gt; observableToMain(): ObservableTransformer&lt;T, T&gt; &#123;</span><br><span class="line">        return ObservableTransformer &#123; upstream -&gt;</span><br><span class="line">            upstream.subscribeOn(Schedulers.io())</span><br><span class="line">                    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Flowable 切换到主线程</span><br><span class="line">     */</span><br><span class="line">    fun &lt;T&gt; flowableToMain(): FlowableTransformer&lt;T, T&gt; &#123;</span><br><span class="line">        return FlowableTransformer &#123; upstream -&gt;</span><br><span class="line">            upstream.subscribeOn(Schedulers.io())</span><br><span class="line">                    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Maybe 切换到主线程</span><br><span class="line">     */</span><br><span class="line">    fun &lt;T&gt; maybeToMain(): MaybeTransformer&lt;T, T&gt; &#123;</span><br><span class="line">        return MaybeTransformer &#123; upstream -&gt;</span><br><span class="line">            upstream.subscribeOn(Schedulers.io())</span><br><span class="line">                    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用起来也比较简单，我们在网络请求的时候就可以这样调用（假设网络请求返回的是Flowable 对象）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.compose(RxThreadUtils.flowableToMain())</span><br></pre></td></tr></table></figure><h2 id="使用场景二"><a href="#使用场景二" class="headerlink" title="使用场景二"></a>使用场景二</h2><p>compose 操作符可以和 Transformer 结合使用，一方面可以让代码看起来更加简洁，另一方面能够提高代码的复用性，因为 RxJava 提倡链式调用，我们可以合理的使用 compose 操作符来防止链式调用被打破。</p><p>RxLifecycle 是 trello 开源的一个配置 RxJava 使用的开源库，我们知道 RxJava 有个缺点就是会导致内存泄露，此时，RxLifecycle 横空出世了，它可以配合 RxJava 一起使用，可以有效防止内存泄漏发生，使用起来也是非常方便，举个简单的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myObservable</span><br><span class="line">    .compose(RxLifecycle.bind(lifecycle))</span><br><span class="line">    .subscribe();</span><br></pre></td></tr></table></figure><p>RxLifecycle 不在文本的讲解范围内，更多详细使用可看 GitHub 介绍：</p><p><a href="https://github.com/trello/RxLifecycle" target="_blank" rel="noopener">https://github.com/trello/RxLifecycle</a></p><p>另外，知乎也开源了一个 RxLifecycle 库，使用起来也是比较方便的，感兴趣的可以看看：</p><p><a href="https://github.com/zhihu/RxLifecycle" target="_blank" rel="noopener">https://github.com/zhihu/RxLifecycle</a></p><p>好了，今天的分享就到这里了。</p><p>最后，我这边有个技术交流群，平常我会分享一些学习资源到群里，还可以和大家一起交流学习，需要的朋友可以扫描下面的二维码加我微信并备注「加群」，拉你进入技术交流群！</p><p><img src="http://image.x-sir.com/FoiEznYF5eSQS8WMN62NzUQ4gk40 =337x448" alt=""></p><p>飞哥带你去装逼，一直装逼到天黑！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://image.x-sir.com/Fgd7qvs7yzR71E7hmgIslUsYOuT9&quot; alt=&quot;&quot;&gt;&lt;br&gt;题图：来自飞哥的图片工厂&lt;/p&gt;
&lt;p&gt;音乐推荐：后来&lt;br&gt;文丨IT大飞说&lt;br&gt;预计阅读时间：2.3 分钟&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="Android" scheme="http://www.x-sir.com/categories/Android/"/>
    
    
      <category term="RxJava" scheme="http://www.x-sir.com/tags/RxJava/"/>
    
      <category term="RxJava2.x" scheme="http://www.x-sir.com/tags/RxJava2-x/"/>
    
      <category term="操作符" scheme="http://www.x-sir.com/tags/%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    
      <category term="compose" scheme="http://www.x-sir.com/tags/compose/"/>
    
  </entry>
  
  <entry>
    <title>RxJava2.x 常用操作符列表</title>
    <link href="http://www.x-sir.com/2019/06/10/RxJava2.x%20%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%88%97%E8%A1%A8/"/>
    <id>http://www.x-sir.com/2019/06/10/RxJava2.x 常用操作符列表/</id>
    <published>2019-06-10T13:48:00.000Z</published>
    <updated>2019-06-10T13:48:39.072Z</updated>
    
    <content type="html"><![CDATA[<ul><li>All：判断 Observable 发射的所有的数据项是否都满足某个条件；</li><li>Amb：给定多个 Observable，只让第一个发射数据的 Observable 发射全部数据；</li><li>And/Then/When：通过模式（And条件）和计划（Then次序）组合两个或多个 Observable 发射的数据集；</li><li>Average：计算 Observable发射的数据序列的平均值，然后发射这个结果；</li><li>Buffer：缓存，可以简单理解为缓存，它定期从 Observable 收集数据到一个集合，然后把这些数据集合打包发射，而不是一次发射一个；</li><li>Catch：捕获，继续序列操作，将错误替换为正常的数据，从 onError 通知中恢复；</li><li>CombineLatest：当两个 Observables 中的任何一个发射了一个数据时，通过一个指定的函数组合每个 Observable 发射的最新数据（一共两个数据），然后发射这个函数的结果；</li><li>Concat：不交错地连接多个 Observable 的数据；</li><li>Connect：指示一个可连接的 Observable 开始发射数据给订阅者；</li><li>Contains：判断 Observable 是否会发射一个指定的数据项；</li><li>Count：计算 Observable 发射的数据个数，然后发射这个结果；</li><li>Create：通过调用观察者的方法从头创建一个 Observable；</li><li>Debounce：只有在空闲了一段时间后才发射数据，简单来说，就是如果一段时间没有操作，就执行一次操作；</li><li>DefaultIfEmpty：发射来自原始 Observable 的数据，如果原始 Observable 没有发射数据，就发射一个默认数据；</li><li>Defer：在观察者订阅之前不创建这个 Observable，为每一个观察者创建一个新的 Observable；</li><li>Delay：延迟一段时间发射结果数据；</li><li>Distinct：去重，过滤掉重复数据项；</li><li>Do：注册一个动作占用一些 Observable 的生命周期事件，相当于 Mock 某个操作；</li><li>Materialize/Dematerialize：将发射的数据和通知都当作数据发射，或者反过来；</li><li>ElementAt：取值，取特定位置的数据项；</li><li>Empty/Never/Throw：创建行为受限的特殊 Observable；</li><li>Filter：过滤，过滤掉没有通过谓词测试的数据项，只发射通过测试的</li><li>First：首项，只发射满足条件的第一条数据；</li><li>flatMap：扁平映射，将 Observable 发射的数据转换为 Observables 集合，然后将这些 Observable 发射的数据平坦化地放进一个单独的 Observable，可以认为是一个将嵌套的数据结构展开的过程；</li><li>From：将其他对象或数据结构转换为 Observable；</li><li>GroupBy：分组，将原来的 Observable 拆分为 Observable 集合，将原始 Observable 发射的数据按 Key 分组，每一个 Observable 发射一组不同的数据；</li><li>IgnoreElements：忽略所有的数据，只保留终止通知(onError 或 onCompleted)；</li><li>Interval：创建一个定时发射整数序列的 Observable；</li><li>Join：无论何时，如果一个 Observable 发射了一个数据项，只要在另一个 Observable 发射的数据项定义的时间窗口内，就将两个 Observable 发射的数据合并发射；</li><li>Just：将对象或者对象集合转换为一个会发射这些对象的 Observable；</li><li>Last：末项，只发射最后一条数据；</li><li>Map：映射，对序列的每一项都应用一个函数变换 Observable 发射的数据，实质是对序列中的每一项执行一个函数，函数的参数就是这个数据项；</li><li>Max：计算并发射数据序列的最大值；</li><li>Merge：将两个 Observable 发射的数据组合并成一个；</li><li>Min：计算并发射数据序列的最小值；</li><li>ObserveOn：指定观察者观察 Observable 的调度程序（工作线程）；</li><li>Publish：将一个普通的 Observable 转换为可连接的；</li><li>Range：创建发射指定范围的整数序列的 Observable；</li><li>Reduce：按顺序对数据序列的每一项数据应用某个函数，然后返回这个值；</li><li>RefCount：使一个可连接的 Observable 表现得像一个普通的 Observable；</li><li>Repeat：创建重复发射特定的数据或数据序列的 Observable；</li><li>Replay：确保所有的观察者收到同样的数据序列，即使他们在 Observable 开始发射数据之后才订阅；</li><li>Retry：重试，如果 Observable 发射了一个错误通知，重新订阅它，期待它正常终止辅助操作；</li><li>Sample：取样，定期发射最新的数据，等同于数据抽样，有的实现中叫作 ThrottleFirst；</li><li>Scan：扫描，对 Observable 发射的每一项数据应用一个函数，然后按顺序依次发射这些值；</li><li>SequenceEqual：判断两个 Observable 是否按相同的数据序列；</li><li>Serialize：强制 Observable 按次序发射数据并且功能是有效的；</li><li>Skip：跳过前面的若干项数据；</li><li>SkipLast：跳过后面的若干项数据；</li><li>SkipUntil：丢弃原始 Observable 发射的数据，直到第二个 Observable 发射了一个数据，然后发射原始 Observable 的剩余数据；</li><li>SkipWhile：丢弃原始Observable发射的数据，直到一个特定的条件为假，然后发射原始 Observable 剩余的数据；</li><li>Start：创建发射一个函数返回值的 Observable；</li><li>StartWith：在发射原来的 Observable 的数据序列之前，先发射一个指定的数据序列或数据项；</li><li>Subscribe：收到 Observable 发射的数据和通知后执行的操作；</li><li>SubscribeOn：指定 Observable 应该在哪个调度程序上执行；</li><li>Sum：计算并发射数据序列的和；</li><li>Switch：将一个发射 Observable 序列的 Observable 转换为这样一个 Observable，即它逐个发射那些 Observable 最近发射的数据；</li><li>Take：只保留前面的若干项数据；</li><li>TakeLast：只保留后面的若干项数据；</li><li>TakeUntil：发射来自原始 Observable 的数据，直到第二个 Observable 发射了一个数据或一个通知；</li><li>TakeWhile：发射原始 Observable 的数据，直到一个特定的条件为真，然后跳过剩余的数据；</li><li>TimeInterval：将一个 Observable 转换为发射两个数据之间所耗费时间的 Observable；</li><li>Timeout：添加超时机制，如果过了指定的一段时间没有发射数据，就发射一个错误通知；</li><li>Timer：创建在一个指定的延迟之后发射单个数据的 Observable；</li><li>Timestamp：给 Observable 发射的每个数据项添加一个时间戳；</li><li>To：将 Observable 转换为其他对象或数据结构；</li><li>Using：创建一个只在 Observable 生命周期内存在的一次性资源；</li><li>Window：窗口，定期将来自 Observable 的数据拆分成一些 Observable 窗口，然后发射这些窗口，而不是每次发射一项；类似于 Buffer，但 Buffer 发射的是数据，Window 发射的是 Observable，每一个 Observable 发射原始 Observable 数据的一个子集；</li><li>Zip：打包，使用一个指定的函数将多个 Observable 发射的数据组合在一起，然后将这个函数的结果作为单项数据发射；</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;All：判断 Observable 发射的所有的数据项是否都满足某个条件；&lt;/li&gt;
&lt;li&gt;Amb：给定多个 Observable，只让第一个发射数据的 Observable 发射全部数据；&lt;/li&gt;
&lt;li&gt;And/Then/When：通过模式（And条件）
      
    
    </summary>
    
      <category term="Android" scheme="http://www.x-sir.com/categories/Android/"/>
    
    
      <category term="RxJava" scheme="http://www.x-sir.com/tags/RxJava/"/>
    
      <category term="RxJava2.x" scheme="http://www.x-sir.com/tags/RxJava2-x/"/>
    
      <category term="操作符" scheme="http://www.x-sir.com/tags/%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>RxJava2.x 并行编程</title>
    <link href="http://www.x-sir.com/2019/06/04/RxJava2.x%20%E7%9A%84%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/"/>
    <id>http://www.x-sir.com/2019/06/04/RxJava2.x 的并行编程/</id>
    <published>2019-06-04T15:33:00.000Z</published>
    <updated>2019-06-04T15:34:46.976Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.x-sir.com/FvMS1D4sOwIivgw3ayDP1bqfX4rI" alt=""><br>题图：来自飞哥的图片工厂</p><p>音乐推荐：你的姑娘<br>文丨IT大飞说<br>预计阅读时间：1.2 分钟</p><p>哈喽，朋友们，之前我们学习了一些 RxJava2.x 的常用操作符，今天我们来继续学习一下RxJava 的并行编程。</p><p>随着手机 CPU 的高速发展，性能越来越强劲，核心数越来越多，我们要充分、高效地利用这些 CPU 资源，来提高程序运行的效率，解决复杂的业务问题，这将变得越来越重要。</p><h2 id="1-什么是并行编程？"><a href="#1-什么是并行编程？" class="headerlink" title="1.什么是并行编程？"></a>1.什么是并行编程？</h2><p>对于并发我们可能比较清楚，那么并行是什么呢？它们的区别是什么？并发（concurrency）是指一个处理器同时处理多个任务，并行（parallelism）是多个处理器或者是多核处理器同时处理多个不同的任务，并行是同时发生的多个并发事件，具有并发的含义，而并发不一定是并行。</p><p>在 Java 8 中有个并行流（parallelStream），有的同学可能用过，我们想使用并行流的方式打印出 1-100 之间的整数，来看下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void parallelismWithJava8() &#123;</span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt;= 100; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        list.parallelStream()</span><br><span class="line">                .map(Object::toString)</span><br><span class="line">                .forEach(s -&gt; LogUtil.i(TAG, &quot;s=&quot; + s + &quot;,Current Thread Name=&quot; + Thread.currentThread().getName()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面的结果会交错输出 1-100 之间的整数，因为并行的缘故所以每个输出执行的时间可能不一样，所以会交错输出，其实上面的代码是 Java 8 借助了 JDK 的 fork/join 框架来实现并行编程的。</p><h2 id="2-使用-RxJava-的-flatMap-实现并行编程"><a href="#2-使用-RxJava-的-flatMap-实现并行编程" class="headerlink" title="2.使用 RxJava 的 flatMap 实现并行编程"></a>2.使用 RxJava 的 flatMap 实现并行编程</h2><p>我们前面学习过 flatMap 操作符，我们知道 flatMap 可以将一些数据转换成一些 Observables，然后我们可以指定它的调度器来实现并行编程的目的，还是打印 1-100 的数字，直接看代码吧：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void parallelismWithRxJavaFlatMap() &#123;</span><br><span class="line">    Observable.range(1, 100)</span><br><span class="line">            .flatMap((Function&lt;Integer, ObservableSource&lt;String&gt;&gt;) integer -&gt;</span><br><span class="line">                    Observable.just(integer)</span><br><span class="line">                            .subscribeOn(Schedulers.computation())</span><br><span class="line">                            .map(integer1 -&gt; integer1.toString()))</span><br><span class="line">            .subscribe(s -&gt; LogUtil.i(TAG, &quot;s===&quot; + s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式使用的是默认的调度器，当然我们也可以创建一个线程池，来自定义调度器，修改后的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private void parallelismWithRxJavaFlatMap() &#123;</span><br><span class="line">    int threadNum = Runtime.getRuntime().availableProcessors() + 1;</span><br><span class="line">    ExecutorService executorService = Executors.newFixedThreadPool(threadNum);</span><br><span class="line">    final Scheduler scheduler = Schedulers.from(executorService);</span><br><span class="line"></span><br><span class="line">    Observable.range(1, 100)</span><br><span class="line">            .flatMap((Function&lt;Integer, ObservableSource&lt;String&gt;&gt;) integer -&gt;</span><br><span class="line">                    Observable.just(integer)</span><br><span class="line">                            .subscribeOn(scheduler)</span><br><span class="line">                            .map(integer1 -&gt; integer1.toString()))</span><br><span class="line">            .doFinally(() -&gt; executorService.shutdown())</span><br><span class="line">            .subscribe(s -&gt; LogUtil.i(TAG, &quot;s===&quot; + s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这 2 种实现方式都差不多，性能方面也差别不大，根据喜好请自行选择，注意一点，如果使用自己创建的线程池，那么记得使用 doFinally 操作符将线程池关闭，或者由下游的消费者进行处理！</p><h2 id="3-使用-ParallelFlowable-实现并行编程"><a href="#3-使用-ParallelFlowable-实现并行编程" class="headerlink" title="3.使用 ParallelFlowable 实现并行编程"></a>3.使用 ParallelFlowable 实现并行编程</h2><p>Flowable 是 RxJava2.x 新增的被观察者，支持背压，因此它对应的并行被观察者为 ParallelFlowable，因为并行编程肯定涉及到异步，而异步又涉及到背压，所以是没有 ParallelObservable 的。</p><p>我们还是用 ParallelFlowable 来实现打印 1-100 这个需求吧，请看代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void parallelFlowable() &#123;</span><br><span class="line">    ParallelFlowable&lt;Integer&gt; parallelFlowable = Flowable.range(1, 100).parallel();</span><br><span class="line"></span><br><span class="line">    parallelFlowable</span><br><span class="line">            .runOn(Schedulers.io())</span><br><span class="line">            .map(integer -&gt; integer.toString())</span><br><span class="line">            .sequential()</span><br><span class="line">            .subscribe(s -&gt; LogUtil.i(TAG, &quot;s===&quot; + s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实代码是比较简单的，我们发现 runOn 和 sequential 操作符我们之前没见过，这里解释下，runOn 其实就是相当于我们上面使用 flatMap 实现中的 subscribeOn，我们可以用它来定义异步，它还有一个重载的方法，我们可以指定 prefetch 的数量。</p><p>sequential 操作符是将并行的操作结果返回到并行流中，这样，才能打印出所有的输出结果。</p><p>我们上面学会了好几种并行编程的方式，那么我们在实际的开发中应该选择哪种呢？</p><p>并非所有的顺序操作在并行中都是有意义的，目前 ParallelFlowable 只支持如下操作：<br>map、filter、flatMap、concatMap、reduce、collect、sorted、toSortedList、compose、fromArray、doOnCancel、doOnError、doOnComplete、doOnNext、doAfterNext、doOnSubscribe、doAfterTerminated、doOnRequest，优先推荐使用 ParallelFlowable 实现并行编程，对于无法使用 ParallelFlowable 的操作符，则使用 flatMap 来实现。</p><p>好了，今天的学习内容就算完成了，感觉是不是很简单？实践证明，学完后动手敲一遍的效果是最好的，赶紧去动手敲一遍吧！</p><p>最后，我这边有个技术交流群，平常我会分享一些学习资源到群里，还可以和大家一起交流学习，需要的朋友可以扫描下面的二维码加我微信并备注「加群」，拉你进入技术交流群！</p><p><img src="http://image.x-sir.com/FoiEznYF5eSQS8WMN62NzUQ4gk40 =337x448" alt=""></p><p>飞哥带你去装逼，一直装逼到天黑！</p><p>另外，我还建了一个免费的知识星球用于学习交流，感兴趣的可以使用微信扫码加入哦！</p><p><img src="https://img-blog.csdnimg.cn/2019052722451347.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbnBlbmdmZWk1MjE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://image.x-sir.com/FvMS1D4sOwIivgw3ayDP1bqfX4rI&quot; alt=&quot;&quot;&gt;&lt;br&gt;题图：来自飞哥的图片工厂&lt;/p&gt;
&lt;p&gt;音乐推荐：你的姑娘&lt;br&gt;文丨IT大飞说&lt;br&gt;预计阅读时间：1.2 分钟&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="Android" scheme="http://www.x-sir.com/categories/Android/"/>
    
    
      <category term="RxJava" scheme="http://www.x-sir.com/tags/RxJava/"/>
    
      <category term="RxJava2.x" scheme="http://www.x-sir.com/tags/RxJava2-x/"/>
    
      <category term="操作符" scheme="http://www.x-sir.com/tags/%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    
      <category term="并行编程" scheme="http://www.x-sir.com/tags/%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/"/>
    
      <category term="parallelism" scheme="http://www.x-sir.com/tags/parallelism/"/>
    
  </entry>
  
  <entry>
    <title>Android library 依赖 aar 包的两种方式</title>
    <link href="http://www.x-sir.com/2019/05/30/Android%20library%20%E4%BE%9D%E8%B5%96%20aar%20%E5%8C%85%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://www.x-sir.com/2019/05/30/Android library 依赖 aar 包的两种方式/</id>
    <published>2019-05-30T09:12:05.000Z</published>
    <updated>2019-05-30T09:13:36.454Z</updated>
    
    <content type="html"><![CDATA[<h2 id="方式1"><a href="#方式1" class="headerlink" title="方式1"></a>方式1</h2><p>将 aar 包放入 library module 的 libs 目录下，然后在工程的 build.gradle 文件中加入如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flatDir &#123; dirs &apos;libs&apos;, &apos;../moduleName/libs&apos; &#125;</span><br></pre></td></tr></table></figure><p>注：将 moduleName 替换为你自己的 library module 的 name.</p><p>然后在 module 的 build.gradle 文件中添加依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation(name: &apos;aar包名&apos;, ext: &apos;aar&apos;)</span><br></pre></td></tr></table></figure><h2 id="方式2"><a href="#方式2" class="headerlink" title="方式2"></a>方式2</h2><p>这种方式的思路是，先把 aar 包放入一个单独的文件夹中，然后我们再依赖这个文件夹就可以了，这个文件夹你也可以理解成一个特殊的 module。</p><p>先在工程目录下新建一个文件夹（和app同级），然后将你的 aar 包放入 这个文件夹，然后再新建一个 build.gradle 文件，在这个文件中添加下面两句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">configurations.maybeCreate(&quot;default&quot;)</span><br><span class="line">artifacts.add(&quot;default&quot;, file(&apos;aar包名.aar&apos;))</span><br></pre></td></tr></table></figure><p>然后在你需要依赖的 library module 的 build.gradle 文件中添加依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation project(&apos;:存放aar包的文件夹&apos;)</span><br></pre></td></tr></table></figure><p>最后，同步下工程就 OK 了~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;方式1&quot;&gt;&lt;a href=&quot;#方式1&quot; class=&quot;headerlink&quot; title=&quot;方式1&quot;&gt;&lt;/a&gt;方式1&lt;/h2&gt;&lt;p&gt;将 aar 包放入 library module 的 libs 目录下，然后在工程的 build.gradle 文件中加入如下代码：
      
    
    </summary>
    
      <category term="Android" scheme="http://www.x-sir.com/categories/Android/"/>
    
    
      <category term="aar" scheme="http://www.x-sir.com/tags/aar/"/>
    
      <category term="module" scheme="http://www.x-sir.com/tags/module/"/>
    
      <category term="依赖" scheme="http://www.x-sir.com/tags/%E4%BE%9D%E8%B5%96/"/>
    
      <category term="library" scheme="http://www.x-sir.com/tags/library/"/>
    
  </entry>
  
  <entry>
    <title>RxJava2.x 变换操作符之 flatMap 和 concatMap</title>
    <link href="http://www.x-sir.com/2019/05/27/RxJava2.x%20%E5%8F%98%E6%8D%A2%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B9%8B%20flatMap%E5%92%8CconcatMap/"/>
    <id>http://www.x-sir.com/2019/05/27/RxJava2.x 变换操作符之 flatMap和concatMap/</id>
    <published>2019-05-27T15:17:00.000Z</published>
    <updated>2019-05-27T15:17:26.506Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.x-sir.com/Fu8NaLmujOyoQjtSrpLnPsxWWp3a" alt=""><br>题图：Pixabay License</p><p>哈喽，朋友们，<a href="https://mp.weixin.qq.com/s?__biz=MzU4MTIzNjg0Ng==&amp;mid=2247484144&amp;idx=1&amp;sn=28e8940cc3a692057a7a3634f04d52f7&amp;chksm=fd4be3f1ca3c6ae765a83e4d6b7d9668f2c212ea3258e7e3cf6cb5ab22c3973720ef5cc7d0a8&amp;token=759890379&amp;lang=zh_CN#rd" target="_blank" rel="noopener">上一篇文章</a>我们学习了 filter 操作符，今天我们来学习 RxJava 中比较重要的两个操作符 flatMap 和 concatMap。</p><h2 id="1-flatMap"><a href="#1-flatMap" class="headerlink" title="1.flatMap"></a>1.flatMap</h2><p>我们知道 flat 是平的意思，这个翻译还是有点生硬和抽象，我们还是不太理解，你就可以先理解成平铺的意思吧。</p><p>flatMap 是变换操作符的一种，它将一个发射数据的 Observable 变换为多个 Observable，然后将他们发射的数据合并后放入一个单独的 Observable。</p><p>举个简单的例子吧，假设上游有个数据源，数据源是学生对象的集合，学生有姓名和课程的属性，每个学生的课程可以有多个，需求是打印出所有学生的课程名称。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Student student1 = new Student();</span><br><span class="line"></span><br><span class="line">List&lt;Student.Course&gt; list1 = new ArrayList&lt;&gt;();</span><br><span class="line">list1.add(new Student.Course(&quot;语文1&quot;));</span><br><span class="line">list1.add(new Student.Course(&quot;数学1&quot;));</span><br><span class="line">list1.add(new Student.Course(&quot;英语1&quot;));</span><br><span class="line">list1.add(new Student.Course(&quot;物理1&quot;));</span><br><span class="line">list1.add(new Student.Course(&quot;化学1&quot;));</span><br><span class="line"></span><br><span class="line">student1.setName(&quot;张三&quot;);</span><br><span class="line">student1.setCourses(list1);</span><br><span class="line"></span><br><span class="line">Student student2 = new Student();</span><br><span class="line"></span><br><span class="line">List&lt;Student.Course&gt; list2 = new ArrayList&lt;&gt;();</span><br><span class="line">list2.add(new Student.Course(&quot;语文2&quot;));</span><br><span class="line">list2.add(new Student.Course(&quot;数学2&quot;));</span><br><span class="line">list2.add(new Student.Course(&quot;英语2&quot;));</span><br><span class="line"></span><br><span class="line">student2.setName(&quot;李四&quot;);</span><br><span class="line">student2.setCourses(list2);</span><br><span class="line"></span><br><span class="line">List&lt;Student&gt; studentList = new ArrayList&lt;&gt;();</span><br><span class="line">studentList.add(student1);</span><br><span class="line">studentList.add(student2);</span><br><span class="line"></span><br><span class="line">Observable.just(studentList)</span><br><span class="line">        .flatMap((Function&lt;List&lt;Student&gt;, ObservableSource&lt;Student&gt;&gt;) students -&gt; Observable.fromIterable(students))</span><br><span class="line">        .flatMap((Function&lt;Student, ObservableSource&lt;Student.Course&gt;&gt;) student -&gt; &#123;</span><br><span class="line">            LogUtil.i(TAG, &quot;student name===&quot; + student.getName());</span><br><span class="line">            return Observable.fromIterable(student.getCourses());</span><br><span class="line">        &#125;)</span><br><span class="line">        .subscribe(course -&gt; LogUtil.i(TAG, &quot;course===&quot; + course.getCourseName()));</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">I/RxJavaOperatorActivity: student name===张三</span><br><span class="line">I/RxJavaOperatorActivity: course===语文1</span><br><span class="line">I/RxJavaOperatorActivity: course===数学1</span><br><span class="line">I/RxJavaOperatorActivity: course===英语1</span><br><span class="line">I/RxJavaOperatorActivity: course===物理1</span><br><span class="line">I/RxJavaOperatorActivity: course===化学1</span><br><span class="line">I/RxJavaOperatorActivity: student name===李四</span><br><span class="line">I/RxJavaOperatorActivity: course===语文2</span><br><span class="line">I/RxJavaOperatorActivity: course===数学2</span><br><span class="line">I/RxJavaOperatorActivity: course===英语2</span><br></pre></td></tr></table></figure><p>我们看到上面的代码没有 for 循环，却遍历打印了集合中的数据，RxJava 就是为了简化或者是取消 for 循环种方式，使用操作符来解决遍历循环的问题，从而是代码更加扁平化，使代码更加清晰和便于理解。</p><p>注意：flatMap 对这些 Observables 发射的数据做的是合并(merge)操作，因此它们可能是交错的，即不能保证数据的发射顺序。</p><h2 id="2-concatMap"><a href="#2-concatMap" class="headerlink" title="2.concatMap"></a>2.concatMap</h2><p>我们将上面的 flatMap 操作符换成 concatMap 操作符再看看打印的结果，修改代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(studentList)</span><br><span class="line">            .concatMap((Function&lt;List&lt;Student&gt;, ObservableSource&lt;Student&gt;&gt;) students -&gt; Observable.fromIterable(students))</span><br><span class="line">            .concatMap((Function&lt;Student, ObservableSource&lt;Student.Course&gt;&gt;) student -&gt; &#123;</span><br><span class="line">                LogUtil.i(TAG, &quot;student name===&quot; + student.getName());</span><br><span class="line">                return Observable.fromIterable(student.getCourses());</span><br><span class="line">            &#125;)</span><br><span class="line">            .subscribe(course -&gt; LogUtil.i(TAG, &quot;course===&quot; + course.getCourseName()));</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">I/RxJavaOperatorActivity: student name===张三</span><br><span class="line">I/RxJavaOperatorActivity: course===语文1</span><br><span class="line">I/RxJavaOperatorActivity: course===数学1</span><br><span class="line">I/RxJavaOperatorActivity: course===英语1</span><br><span class="line">I/RxJavaOperatorActivity: course===物理1</span><br><span class="line">I/RxJavaOperatorActivity: course===化学1</span><br><span class="line">I/RxJavaOperatorActivity: student name===李四</span><br><span class="line">I/RxJavaOperatorActivity: course===语文2</span><br><span class="line">I/RxJavaOperatorActivity: course===数学2</span><br><span class="line">I/RxJavaOperatorActivity: course===英语2</span><br></pre></td></tr></table></figure><p>我们看到和 flatMap 的执行结果是一样的，我们发现打印的结果也是按照添加数据的顺序打印出来了，理论上 flatMap 执行的结果可能会有交错，原因是我们添加的数据过少，因此它们执行的时间也是差不多的，所以提现不出交错的情况。</p><p>好了，今天的学习内容就算完成了，感觉是不是非常简单？其实有时候你光看，理解起来是很慢的，但是你动手敲一遍立马就明白了，所以代码这个东西还是得多敲！</p><p>最后，我这边建了一个技术交流群，需要的朋友可以扫描下面的二维码加我微信并备注「加群」，拉你进入技术交流群！</p><p><img src="http://image.x-sir.com/FoiEznYF5eSQS8WMN62NzUQ4gk40 =337x448" alt=""></p><p>飞哥带你去装逼，一直装逼到天黑！</p><p>另外，我还建了一个免费的知识星球用于学习交流，感兴趣的可以使用微信扫码加入哦！</p><p><img src="https://img-blog.csdnimg.cn/2019052722451347.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbnBlbmdmZWk1MjE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://image.x-sir.com/Fu8NaLmujOyoQjtSrpLnPsxWWp3a&quot; alt=&quot;&quot;&gt;&lt;br&gt;题图：Pixabay License&lt;/p&gt;
&lt;p&gt;哈喽，朋友们，&lt;a href=&quot;https://mp.weixin.qq.
      
    
    </summary>
    
      <category term="Android" scheme="http://www.x-sir.com/categories/Android/"/>
    
    
      <category term="RxJava" scheme="http://www.x-sir.com/tags/RxJava/"/>
    
      <category term="RxJava2.x" scheme="http://www.x-sir.com/tags/RxJava2-x/"/>
    
      <category term="操作符" scheme="http://www.x-sir.com/tags/%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>RxJava2.x 操作符之 filter</title>
    <link href="http://www.x-sir.com/2019/05/23/RxJava2.x%20%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B9%8B%20filter/"/>
    <id>http://www.x-sir.com/2019/05/23/RxJava2.x 操作符之 filter/</id>
    <published>2019-05-23T09:20:00.000Z</published>
    <updated>2019-05-23T09:19:19.353Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.x-sir.com/FgcNl-lC_eHGqFwCEaAENRaAGT5r" alt=""><br>题图：Pixabay License</p><p>哈喽，朋友们，<a href="https://mp.weixin.qq.com/s/EV4afZ27lQZ8xLxnZjLZow" target="_blank" rel="noopener">上一篇文章</a>我们学习了 repeate 操作符，今天我们继续来学习 filter 操作符。</p><p>我们都知道 filter 是过滤的意思，也就是说这个操作符就是帮助我们来过滤掉一些我们不需要的数据。</p><p>举个简单的例子吧，假设上游有个数据源，顺序向下游发送 0-9 十个数字，我们只想打印大于 5 的数字，我们就可以这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Observable.interval(1, TimeUnit.SECONDS)</span><br><span class="line">   .take(10)</span><br><span class="line">   .filter(new Func1&lt;Long, Boolean&gt;() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public Boolean call(Long aLong) &#123;</span><br><span class="line">               return aLong &gt; 5;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;)</span><br><span class="line">   .subscribe(new Action1&lt;Long&gt;() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void call(Long aLong) &#123;</span><br><span class="line">               LogUtil.i(&quot;aLong===&quot; + aLong);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I/RxJavaOperatorActivity: aLong===6</span><br><span class="line">I/RxJavaOperatorActivity: aLong===7</span><br><span class="line">I/RxJavaOperatorActivity: aLong===8</span><br><span class="line">I/RxJavaOperatorActivity: aLong===9</span><br></pre></td></tr></table></figure><p>结果打印出来的都是大于 5 的数字，当然你还可以设置其他的过滤条件，例如空值等！</p><p>好了，今天的学习内容就算完成了，感觉是不是非常简单？如果你学会了就赶紧动手去实践一下吧，说不定你会有新的发现哦！</p><p>最后，我和大家分享一下我学习的一些经验或者是见解吧。我们再学习的过程中，可能学的很多东西都是点状的，我们要把学习到的东西学会融会贯通，将他们连接成线即学会相互联系，再将线形成面，再形成体，这样我们学到的知识才能形成一个完整的知识体系，不要只见树叶，不见森林，希望大家在学习的过程中，多思考，多总结！</p><p>Ps:扫描下面的二维码，关注「IT大飞说」，回复「加群」，拉你进入兄弟战斗群，最后告诉你们一个小秘密，公号对话框回复「装备01」 送你一件珍藏版的打怪装备，战斗力瞬间可增加 80！！！我使用过，效果杠杠滴！从此，我们就可以一起愉快的装逼了！</p><p>飞哥带你去装逼，一直装逼到天黑！</p><p>更多干货文章请关注我的微信公众号：<br><img src="https://img-blog.csdn.net/20180626144909992?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbnBlbmdmZWk1MjE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="扫一扫关注"></p><p>另外，我还建了一个免费的知识星球，感兴趣的微信扫码即可加入！</p><p><img src="http://image.x-sir.com/zsxq_qrcodezsxq_qrcode.jpg" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://image.x-sir.com/FgcNl-lC_eHGqFwCEaAENRaAGT5r&quot; alt=&quot;&quot;&gt;&lt;br&gt;题图：Pixabay License&lt;/p&gt;
&lt;p&gt;哈喽，朋友们，&lt;a href=&quot;https://mp.weixin.qq.
      
    
    </summary>
    
      <category term="Android" scheme="http://www.x-sir.com/categories/Android/"/>
    
    
      <category term="RxJava" scheme="http://www.x-sir.com/tags/RxJava/"/>
    
      <category term="RxJava2.x" scheme="http://www.x-sir.com/tags/RxJava2-x/"/>
    
      <category term="操作符" scheme="http://www.x-sir.com/tags/%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>RxJava2.x 操作符之 repeat</title>
    <link href="http://www.x-sir.com/2019/05/21/RxJava2.x%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B9%8Brepeat/"/>
    <id>http://www.x-sir.com/2019/05/21/RxJava2.x操作符之repeat/</id>
    <published>2019-05-21T15:51:56.000Z</published>
    <updated>2019-05-21T16:10:15.758Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.x-sir.com/FqDMiECeHHogPYMQOD61PzhARXlC" alt=""><br>题图：Pixabay License</p><p>哈喽，朋友们，<a href="https://mp.weixin.qq.com/s?__biz=MzU4MTIzNjg0Ng==&amp;mid=2247484126&amp;idx=1&amp;sn=e94a44088c9697aa36ff1ddf91e35ced&amp;chksm=fd4be3dfca3c6ac969c0ccfb39d364bbca18b651f8cd36ed1e07af174775acebcd0426a6745a&amp;token=887755948&amp;lang=zh_CN#rd" target="_blank" rel="noopener">上一篇文章</a>我们学习了 from 操作符，今天我们继续来学习 repeat 操作符。</p><p>我们都知道 repeat 是重复的意思，也就是说这个操作符就是帮助我们来操作处理一些重复的数据或者操作，repeat 有三个相关的操作符：repeat、repeatWhen、repeatUntil，从字面也很好理解，repeat 就是简单的重复操作，repeatWhen 当达到什么条件的时候重复，repeatUntil 是直到某个条件不在重复。</p><h2 id="1-repeat"><a href="#1-repeat" class="headerlink" title="1.repeat"></a>1.repeat</h2><p>举个简单的例子吧，例如我们想重复打印一下 “Hello World!”，我们就可以这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private void repeat() &#123;</span><br><span class="line">    Observable.just(&quot;Hello World!&quot;)</span><br><span class="line">            .repeat(3)</span><br><span class="line">            .subscribe(s -&gt; LogUtil.i(TAG, s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单吧，这个就不用我多说了吧。需要注意的是，如果不指定重复的次数，则会无限地重复下去！</p><h2 id="2-repeatWhen"><a href="#2-repeatWhen" class="headerlink" title="2.repeatWhen"></a>2.repeatWhen</h2><p>例如，我们想按顺序打印 0-3 的数字，当 2 秒后我们再重复打印一次，我们就可以这么写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.range(0, 4)</span><br><span class="line">            .repeatWhen(objectObservable -&gt; Observable.timer(2, TimeUnit.SECONDS))</span><br><span class="line">            .subscribe(integer -&gt; LogUtil.i(TAG, &quot;integer===&quot; + integer));</span><br></pre></td></tr></table></figure><p>上面的代码也比较简单，首先我们使用了一个新的操作符 range，也就是范围的意思，我们可以用它来指定一个数字的范围，并按顺序发射出去，repeatWhen 中使用了一个新的操作符 timer，我们用他创建了一个定时器的被观察者对象，并指定了两秒的时长，当到达 2 秒时就会重复原始的 Observable 并重新订阅和发射。</p><h2 id="3-repeatUntil"><a href="#3-repeatUntil" class="headerlink" title="3.repeatUntil"></a>3.repeatUntil</h2><p>例如，我想间隔 1 秒顺序打印数字 0-2，当从开始打印到第 5 秒的时候就停止打印，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Observable.interval(1000, TimeUnit.MILLISECONDS)</span><br><span class="line">            .take(3)</span><br><span class="line">            .repeatUntil(() -&gt; System.currentTimeMillis() - currentTimeMillis &gt; 5000)</span><br><span class="line">            .subscribe(aLong -&gt; LogUtil.i(TAG, &quot;aLong===&quot; + aLong));</span><br></pre></td></tr></table></figure><p>这里我们使用了一个新的操作符 interval，它可以指定时间单位的时长发送数字序列，还有一个操作符是 take，它表示只取前 3 个，注意：从 0 开始，不包含它自己，接下来我们在 repeatUntil 里加了个判断，当大于 5 秒就停止重复打印。</p><p>执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">I/RxJavaOperatorActivity: aLong===0</span><br><span class="line">I/RxJavaOperatorActivity: aLong===1</span><br><span class="line">I/RxJavaOperatorActivity: aLong===2</span><br><span class="line">I/RxJavaOperatorActivity: aLong===0</span><br><span class="line">I/RxJavaOperatorActivity: aLong===1</span><br><span class="line">I/RxJavaOperatorActivity: aLong===2</span><br></pre></td></tr></table></figure><p>怎么样？是不是立马就明白了。</p><p>好了，今天的学习内容就算完成了，感觉是不是非常简单？如果你学会了就赶紧动手去实践一下吧，说不定你会有新的发现哦！</p><p>最后，我和大家分享一下我学习的一些经验或者是见解吧。我们再学习的过程中，可能学的很多东西都是点状的，我们要把学习到的东西学会融会贯通，将他们连接成线即学会相互联系，再将线形成面，再形成体，这样我们学到的知识才能形成一个完整的知识体系，不要只见树叶，不见森林，希望大家在学习的过程中，多思考，多总结！</p><p>Ps:扫描下面的二维码，关注「IT大飞说」，回复「加群」，拉你进入兄弟战斗群，最后告诉你们一个小秘密，公号对话框回复「装备01」 送你一件珍藏版的打怪装备，战斗力瞬间可增加 80！！！我使用过，效果杠杠滴！从此，我们就可以一起愉快的装逼了！</p><p>飞哥带你去装逼，一直装逼到天黑！</p><p>更多干货文章请关注我的微信公众号：<br><img src="https://img-blog.csdn.net/20180626144909992?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbnBlbmdmZWk1MjE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="扫一扫关注"></p><p>另外，我还建了一个免费的知识星球，感兴趣的微信扫码即可加入！</p><p><img src="http://image.x-sir.com/zsxq_qrcodezsxq_qrcode.jpg" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://image.x-sir.com/FqDMiECeHHogPYMQOD61PzhARXlC&quot; alt=&quot;&quot;&gt;&lt;br&gt;题图：Pixabay License&lt;/p&gt;
&lt;p&gt;哈喽，朋友们，&lt;a href=&quot;https://mp.weixin.qq.
      
    
    </summary>
    
      <category term="Android" scheme="http://www.x-sir.com/categories/Android/"/>
    
    
      <category term="RxJava" scheme="http://www.x-sir.com/tags/RxJava/"/>
    
      <category term="RxJava2.x" scheme="http://www.x-sir.com/tags/RxJava2-x/"/>
    
      <category term="操作符" scheme="http://www.x-sir.com/tags/%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>RxJava2.x 创建操作符之 from</title>
    <link href="http://www.x-sir.com/2019/05/19/RxJava2.x%E5%88%9B%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B9%8Bfrom/"/>
    <id>http://www.x-sir.com/2019/05/19/RxJava2.x创建操作符之from/</id>
    <published>2019-05-19T10:34:56.000Z</published>
    <updated>2019-05-19T10:35:06.681Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.x-sir.com/FstPHz-8U7d4k5MmkgEMSV2u4jZI" alt=""><br>题图：Pixabay License</p><p>哈喽，朋友们，<a href="https://mp.weixin.qq.com/s?__biz=MzU4MTIzNjg0Ng==&amp;mid=2247484120&amp;idx=1&amp;sn=92c23454794cd38b6b10f3584446a4ef&amp;chksm=fd4be3d9ca3c6acfd6154829fc2c4a0dd8ce778301d861a834e906d37500a8e9c69e78c0671f&amp;token=109718556&amp;lang=zh_CN#rd" target="_blank" rel="noopener">上一篇文章</a>我们学习了 create &amp; just 操作符，今天我们继续来学习 from 操作符。</p><p>from 操作符和 just 操作符一样，也属于创建操作符的一种，from 可将其他种类的对象和数据类型转换为 Observable。</p><p>从概念看，just 和 from 是比较相似的，那么，他们两者有什么区别呢？</p><p>just 只是简单的原样发射，它会将数组或 Iterable 当做单个数据发射出去，而 from 会将数组或 Iterable 的数据按顺序取出来，然后逐个发射出去，举个例子你就明白了。</p><p>举例，我们初始化了一个 list，分别用 just 和 fromIterable 操作符进行处理，并打印了数据的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">for (int i = 0; i &lt; 6; i++) &#123;</span><br><span class="line">    list.add(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Observable.just(list).subscribe((Consumer&lt;List&gt;) list1 -&gt; LogUtil.i(TAG, &quot;just():&quot; + Arrays.toString(list1.toArray())));</span><br><span class="line"></span><br><span class="line">Observable.fromIterable(list).subscribe(integer -&gt; LogUtil.i(TAG, &quot;fromIterable():&quot; + integer));</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">I/RxJavaOperatorActivity: just():[0, 1, 2, 3, 4, 5]</span><br><span class="line">I/RxJavaOperatorActivity: fromIterable():0</span><br><span class="line">I/RxJavaOperatorActivity: fromIterable():1</span><br><span class="line">I/RxJavaOperatorActivity: fromIterable():2</span><br><span class="line">I/RxJavaOperatorActivity: fromIterable():3</span><br><span class="line">I/RxJavaOperatorActivity: fromIterable():4</span><br><span class="line">I/RxJavaOperatorActivity: fromIterable():5</span><br></pre></td></tr></table></figure><p>从上面打印的日志我们可以看到，just 是将整个 list 数据传递下来了，而 fromIterable 是将 list 中的数据遍历并一个一个发射出去，数组也是一样的道理，数组使用 fromArray 操作符。</p><p>这里需要注意一个点，just 是可以接收 1-10 参数的，如果传入 1-5 的数字作为参数，那么它也会按顺序去打印的，而不是作为一个数组发射出去。</p><p>举个例子你就明白了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(1, 2, 3, 4, 5).subscribe(integer -&gt; LogUtil.i(TAG, &quot;just():&quot; + integer));</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">I/RxJavaOperatorActivity: just():1</span><br><span class="line">I/RxJavaOperatorActivity: just():2</span><br><span class="line">I/RxJavaOperatorActivity: just():3</span><br><span class="line">I/RxJavaOperatorActivity: just():4</span><br><span class="line">I/RxJavaOperatorActivity: just():5</span><br></pre></td></tr></table></figure><p>怎么样？是不是瞬间就懂了。</p><p>另外，from 还有一个 fromFuture 操作符，Future 是什么东西？fromFuture 又是如何使用的呢？这个问题问的好，大飞这就给你细细道来。</p><p>Future 是 java.util.concurrent 包下的一个接口，我们都知道，创建线程的 2 种方式，一种是直接继承 Thread，另外一种就是实现 Runnable接口，但是这 2 种方式都有一个缺点就是在执行完任务之后无法获取执行的结果。</p><p>如果需要获取执行结果，就必须通过共享变量或者使用线程通信的方式来达到效果，这样使用起来就比较麻烦。而自从 JDK 1.5 开始，给我们提供了 Callable 和 Future 接口，通过这两个接口我们可以在任务执行完毕之后得到线程执行的结果。</p><p>一般来说，Callable 需要和 ExecutorService 配合来使用的，举个非常简单的例子吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">static class MyCallable implements Callable&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Integer call() throws Exception &#123;</span><br><span class="line">        LogUtil.i(TAG, &quot;call():在这里模拟一些耗时操作...&quot;);</span><br><span class="line">        Thread.sleep(3000);</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int i = 0; i &lt;= 100; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void calculate() &#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    Future&lt;Integer&gt; future = executorService.submit(new MyCallable());</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        LogUtil.i(TAG, &quot;任务运行的结果：&quot; + future.get());</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; catch (ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码也比较简单，我相信大家都能看得懂，我们的 MyCallable 类实现了 Callable 接口，在 call 方法中进行了一些耗时的操作，然后将结果返回出去，紧接着我们创建了一个线程池，创建了一个 MyCallable 的对象并将其提交到线程池中，最后将执行的结果打印出来。</p><p>执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2019-05-19 16:22:36.932 I/RxJavaOperatorActivity: call():在这里模拟一些耗时操作...</span><br><span class="line">2019-05-19 16:22:40.933 I/RxJavaOperatorActivity: 任务运行的结果：5050</span><br></pre></td></tr></table></figure><p>我们再来看看如何配合 RxJava 来使用，这里使用到了 fromFuture 操作符，其实使用起来非常简单，简单修改一下上面的代码，相信你立刻就秒懂了！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Observable.fromFuture(future).subscribe(s -&gt; LogUtil.i(TAG, &quot;任务运行的结果：&quot; + s));</span><br></pre></td></tr></table></figure><p>这里我们就不调用 future 的 get 方法来获取执行的结果了，而是将 future 对象使用 fromFuture 操作符将其作为参数传递进去，当任务执行完成后，我们的观察者就会收到执行完后的结果，说白了就是 RxJava 内部帮你执行了 get 的方法并把结果回调给你了。</p><p>总结一下，对于 Future，它会发射 Future.get() 方法返回的单个数据。</p><p>细心的你可能已经发现了，fromFuture 还有一个重载方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fromFuture(Future&lt;? extends T&gt; future, long timeout, TimeUnit unit)；</span><br></pre></td></tr></table></figure><p>那第二个参数和第三个参数是什么意思呢？先别急，我们先看下 Future 接口的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface Future&lt;V&gt; &#123;</span><br><span class="line">    boolean cancel(boolean mayInterruptIfRunning);</span><br><span class="line">    boolean isCancelled();</span><br><span class="line">    boolean isDone();</span><br><span class="line">    V get() throws InterruptedException, ExecutionException;</span><br><span class="line">    V get(long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到没有，我们发现原来 get 方法也有一个重载方法，也就是说 fromFuture 3 个参数的方法中后两个参数对应的就是 get 重载方法中的这两个参数。</p><p>那么问题来了，这两个参数有什么作用呢？这两参数的意思是，我们可以指定执行任务的时长和时间单位，如果过了指定的时长，Future 还没有返回一个结果，那么这个 Observable 就会发射异常通知并终止。</p><p>我们可以测试一下是不是这样的。我们现在指定一个执行任务的时长，我在执行任务的方法中睡了 3 秒，那么这里我就给它设置成 2 秒，这样设置，任务肯定是没有执行完成的，我们看看这个时候会不会和我们猜测的一样会抛异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.fromFuture(future, 2, TimeUnit.SECONDS).subscribe(s -&gt; Observable.fromFuture(future, 2, TimeUnit.SECONDS)</span><br><span class="line">                .subscribe(s -&gt; LogUtil.i(TAG, &quot;任务运行的结果：&quot; + s)</span><br><span class="line">                        , throwable -&gt; LogUtil.e(TAG, &quot;onError:&quot; + throwable.getMessage()));</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I/RxJavaOperatorActivity: call():在这里模拟一些耗时操作...</span><br><span class="line">E/RxJavaOperatorActivity: onError:null</span><br></pre></td></tr></table></figure><p>看到没有，果不其然报错了，这样我们就可以在超时的时候做一些处理了。</p><p>好了，我们今天的学习目标就算达成了，感觉是不是很简单，很轻松？我们来回顾下今天所学的东西，首先我们学习了 fromIterable 操作符，它与 just 操作符有相似之处，因此我将其与 just 操作符举例说明了他们的区别。</p><p>紧接着我们回顾了 Java 中创建线程的相关知识，并学会了将其配合 fromFuture 操作符一起使用，真的是非常方便的。</p><p>如果你学会了就赶紧动手去实践一下吧，有数据表明，学习后实践的吸收效果比不实践的效果高几十倍！</p><p>今天的内容确实比较轻松和简单，后面我将继续带领大家一起学习新的内容，大家敬请期待吧！</p><p>最后，我和大家分享一下我学习的一些经验或者是见解吧。我们再学习的过程中，可能学的很多东西都是点状的，我们要把学习到的东西学会融会贯通，将他们连接成线即学会相互联系，再将线形成面，再形成体，这样我们学到的知识才能形成一个完整的知识体系，不要只见树叶，不见森林，希望大家在学习的过程中，多思考，多总结！</p><p>Ps:扫描下面的二维码，关注「IT大飞说」，回复「加群」，拉你进入兄弟战斗群，最后告诉你们一个小秘密，公号对话框回复「装备01」 送你一件珍藏版的打怪装备，战斗力瞬间可增加 80！！！我使用过，效果杠杠滴！从此，我们就可以一起愉快的装逼了！</p><p>飞哥带你去装逼，一直装逼到天黑！</p><p>更多干货文章请关注我的微信公众号：<br><img src="https://img-blog.csdn.net/20180626144909992?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbnBlbmdmZWk1MjE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="扫一扫关注"></p><p>另外，我还建了一个免费的知识星球，感兴趣的微信扫码即可加入！</p><p><img src="http://image.x-sir.com/zsxq_qrcodezsxq_qrcode.jpg" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://image.x-sir.com/FstPHz-8U7d4k5MmkgEMSV2u4jZI&quot; alt=&quot;&quot;&gt;&lt;br&gt;题图：Pixabay License&lt;/p&gt;
&lt;p&gt;哈喽，朋友们，&lt;a href=&quot;https://mp.weixin.qq.
      
    
    </summary>
    
      <category term="Android" scheme="http://www.x-sir.com/categories/Android/"/>
    
    
      <category term="RxJava" scheme="http://www.x-sir.com/tags/RxJava/"/>
    
      <category term="RxJava2.x" scheme="http://www.x-sir.com/tags/RxJava2-x/"/>
    
      <category term="操作符" scheme="http://www.x-sir.com/tags/%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>RxJava2.x创建操作符之create和just (打怪升级版)！！！</title>
    <link href="http://www.x-sir.com/2019/05/18/RxJava2.x%E5%88%9B%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B9%8Bcreate%E5%92%8Cjust%20(%E6%89%93%E6%80%AA%E5%8D%87%E7%BA%A7%E7%89%88)%EF%BC%81%EF%BC%81%EF%BC%81/"/>
    <id>http://www.x-sir.com/2019/05/18/RxJava2.x创建操作符之create和just (打怪升级版)！！！/</id>
    <published>2019-05-18T06:52:56.000Z</published>
    <updated>2019-05-22T12:43:51.202Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.x-sir.com/FktTLU6ea8mEdcLduIBEfTh8ZYdV" alt=""></p><p>题图：来自网络</p><p>哈喽，朋友们，好久不见了，有段时间没推文了。从今天开始，我将计划更新 RxJava2.x 系列的文章，RxJava 是什么东西，我想也不用给大家介绍了吧。</p><p>其实，网上关于 RxJava 的相关文章一大堆，我之前也看过不少，对于新手来说，那些文章，要么就是比较长，不容易看下去，要么就是讲的全是理论，晦涩难懂，缺少实践性。</p><p>因此，我打算从今天开始，更新一系列的 RxJava2.x 教程，主要从常用的操作符讲起，目的很简单，带大家每天学会一个操作符的使用。</p><p>操作符是 RxJava 的重要组成部分，因此学习操作符也是非常重要的，RxJava 的操作符虽然说比较多，但是我们可以将其进行分类，然后逐一进行理解学习，其实也是比较容易和轻松的，RxJava 的操作符大致可以分为以下几类：</p><p><img src="http://image.x-sir.com/FofYPEnQJ_1W2CKeqjO8XHWgakyX" alt=""></p><p>今天，我们先来学习两个简单的创建操作符 create &amp; just。</p><p>在学习之前，我们先来回顾下观察者模式，大多数同学应该都不陌生吧，例如 Android 的EventBus 等框架都使用了观察者模式，简单说这就是一种发布、订阅的模式，你可以简单理解为订阅报纸。</p><p>这与 RxJava 又有什么关系呢？我们先来看下 Rx 的概念：Rx 是一个使用可观察数据流进行异步编程的编程接口，也就是说 RxJava 中使用了观察者模式的这种编程思想，另外还结合了迭代器模式和函数式编程，并把它运用发挥到了极致。</p><p>我们都知道观察者模式中，有 3 个重要的概念，被观察者，观察者和订阅，类比到现实中订阅报纸的场景中就是，报纸是被观察者，阅读报纸的人是观察者，人订阅了报纸也就是说使用订阅将他们两者关联起来，这样就形成了一种发布、订阅的关系。</p><p>举个例子吧，我们来看看 Android 中点击事件的处理，注意：观察者模式与点击回调模式有很多的相似处，简单对比就是：回调是一对一的关系，只监听一个事件；观察者模式则是一个主题，可以有多个监听者，当主题变化时，向部分或所有监听者发出变化的通知，观察者模式是一对多的关系。</p><p><img src="http://image.x-sir.com/FqENsbJlDpDhhbFg7_fllxjBkAsu" alt=""></p><p>上面的代码很简单吧，我相信大家都能看得懂，一般我们习惯上将监听器写成匿名的，这里我是为了给大家做类比，所以分开写了，然后我们再结合观察者模式看看上面的代码，第一步实例化一个 Button 就相当于是创建了一个被观察者，第二步初始化一个监听器就相当于是创建了一个观察者，第三步将监听器和 Button 绑定就相当于是把被观察者和观察者通过订阅将他们两者关联起来，是不是理解起来非常简单。</p><p>我们再来看看 RxJava 如何来实现，我们就先从最简单的 Hello World 学习起来吧，同样的还是三步走！</p><p>第一步，创建被观察者（Observable）<br>第二步，创建观察者（Observer）<br>第三步，将被观察者和观察者绑定（subscribe）</p><p><img src="http://image.x-sir.com/FnIeZphHHxbniPktU0LPojPy-uLe" alt=""></p><p>和上面的点击事件对比一下，是不是感觉有异曲同工之妙？但是我们习惯上一般不分开写，而是将方法的调用写成链式调用，将对对象写成匿名的对象，我们将上面的代码变换下，如下所示：</p><p><img src="http://image.x-sir.com/FhRcbDj6_Pav2DBwUQRLpbMBRJJw" alt=""></p><p>我们看到，在上面的创建被观察者的 subscribe 方法中，调用了 onNext 方法，将 “Hello World” 字符串传递下去，而在下面调用 subscribe 的时候，传递了一个 Consumer 对象（观察者），而这个 Consumer 的回调方法就会收到 onNext 的传递过来的值，接着，我们在下面打印了一下 onNext 传递过来的字符串。</p><p>实际上，subscribe（订阅）是一个重载方法，它可以接收 0-4 个参数，当传递一个参数时，就代表接收处理成功时的回调（onNext），如传递多个参数则代表接收处理错误、完成、当订阅完成时的事件处理，我们这里为了演示，就只处理成功事件就行了。</p><p>上面的代码看着还是不太完美，我们这里使用 just 操作符将它改造一下，just 是什么鬼？看着怎么一脸懵逼，好吧，那就让大飞哥来给你讲解下 just 操作符。</p><p>just 操作符和 create 操作符一样，也是创建操作符的一种，just 操作符是将一个或多个对象转换成发射这个或这些对象的一个 Observable，看完概念还是一脸懵逼怎么办？确实，这些概念是比较抽象的，其实，用起来特别简单，当你会用了之后，你再回过头去理解起来会容易很多。</p><p>来继续将我们的 Hello World 用 just 操作符改造一下：</p><p><img src="http://image.x-sir.com/FqctUFNUoi_pT5I0QQX4Q1R99LdF" alt=""></p><p>怎么样，是不是更简单了，我们点开 just 方法，我们看到它接收的是一个 T，也就是说它可以接收任意类型的参数，我们以后就可以使用 just 操作符来很方便的创建各种被观察者对象了，非常棒！我们又学会了一个操作符，欧耶！</p><p>上面的代码看着还是有点长，我们可以用 Lambda 表达式改造一下看看：</p><p><img src="http://image.x-sir.com/FlGPbco53npYjS-AkQ4jxKwoQfJx" alt=""></p><p>哇哦！It’s beautiful! 一行代码就搞定了，有木有？</p><p>至此，我们今天的学习目标就算达成了，感觉是不是很简单，很轻松？</p><p>如果你学会了就赶紧动手去实践一下吧，实践是检验真理的唯一标准，眼过千遍不如手过一遍，代码是用来敲的不是用来看的，希望我们程序员都是实干家！</p><p>今天的内容确实比较轻松和简单，后面还有更大的挑战呢，从今天开始，大飞哥将带你一起打怪升级练本领，一起去闯关，去战斗！大家敬请期待吧！</p><p>最后，引用大飞哥的一句名言作为结尾吧：“是兄弟，就一起去战斗吧！”</p><p>Ps:扫描下面的二维码，关注「IT大飞说」，回复「加群」，拉你进入兄弟战斗群，最后告诉你们一个小秘密，公号对话框回复「装备01」 送你一件珍藏版的打怪装备，战斗力瞬间可增加 80！！！我使用过，效果杠杠滴！从此，我们就可以一起愉快的装逼了！</p><p>飞哥带你去装逼，一直装逼到天黑！</p><p>更多干货文章请关注我的微信公众号：<br><img src="https://img-blog.csdn.net/20180626144909992?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbnBlbmdmZWk1MjE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="扫一扫关注"></p><p>另外，我还建了一个免费的知识星球，感兴趣的微信扫码即可加入！</p><p><img src="http://image.x-sir.com/zsxq_qrcodezsxq_qrcode.jpg" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://image.x-sir.com/FktTLU6ea8mEdcLduIBEfTh8ZYdV&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;题图：来自网络&lt;/p&gt;
&lt;p&gt;哈喽，朋友们，好久不见了，有段时间没推文了。从今天开始，我将计划更新 RxJava2.x
      
    
    </summary>
    
      <category term="Android" scheme="http://www.x-sir.com/categories/Android/"/>
    
    
      <category term="RxJava" scheme="http://www.x-sir.com/tags/RxJava/"/>
    
      <category term="RxJava2.x" scheme="http://www.x-sir.com/tags/RxJava2-x/"/>
    
      <category term="操作符" scheme="http://www.x-sir.com/tags/%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>你不知道的 Gradle 高级技巧（一）</title>
    <link href="http://www.x-sir.com/2019/01/30/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%20Gradle%20%E6%8A%80%E5%B7%A7/"/>
    <id>http://www.x-sir.com/2019/01/30/你不知道的 Gradle 技巧/</id>
    <published>2019-01-30T06:52:30.000Z</published>
    <updated>2019-01-30T06:52:57.695Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作为一名Android 开发者，我们都有发布 APP 内测版本的经历，有的公司是发布到自己的服务器上，生成一个连接或者二维码扫描就可以下载，有的公司使用一些内测平台如蒲公英、fir.im 等，有这么好的内测平台为什么不用呢？一方面这些平台的基本都是免费提供服务的，另外一方面也提供了许多丰富的 api，方便开发者使用，提升效率！</p></blockquote><h2 id="1"><a href="#1" class="headerlink" title="1."></a><em>1.</em></h2><p>前段时间研究 Android 端的自动打包，采用的是 Jenkins + Git 的方式，这样，当你 push 完代码之后，Jenkins 会自动拉取你的代码，然后再用 Gradle 工具进行自动化打包，Jenkins 可以配置许多插件，当打包完之后可以自动上传到蒲公英和 fir.im 等平台，特别方便，基本就是这么个流程，我们之前公司是运维帮我们在服务器端搭建的自动打包程序，这样的好处是当你需要打几十个包时，特别快，因为服务器的配置一般比电脑都高，并且不用占用自己电脑的资源。我自己前段时间也在自己的电脑上装了一个 Jenkins，然后一些配置，也可以进行自动化打包，但是我觉得没必要，因为你把代码 push 上去，然后再拉下来，然后再打包，用的还是你本地电脑的资源，还不如直接用 AS 打包来的快，我看了下 Jenkins 上传到公测平台的实现，其实就是用了一个 <code>curl</code> 命令来实现的，我就想着能不能在 <strong>Gradle</strong> 中配置上传的脚本？答案当然是可以的！</p><h2 id="2"><a href="#2" class="headerlink" title="2."></a><em>2.</em></h2><p>首先，我们了解下什么是 curl？</p><p>下面的概念来自某度的解释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl 命令是一个利用 URL 规则在命令行下工作的文件传输工具。它支持文件的上传和下载，所以是综合传输工具，但按传统，习惯称 curl 为下载工具。作为一款强力工具，curl 支持包括 HTTP、HTTPS、ftp 等众多协议，还支持 POST、cookies、认证、从指定偏移处下载部分文件、用户代理字符串、限速、文件大小、进度条等特征。</span><br></pre></td></tr></table></figure><p>简单说他就是一个命令，Linux 和 Mac 系统自带，Windows 需要安装 curl 才能使用，在哪里下载 curl?为了方便大家我已经帮大家下载好了，复制下面的字符发送到后台即可：</p><center><strong>curl</strong></center><p>里面包含 32 位 &amp; 64 位的安装程序，还有安装教程的链接供大家参考，安装完成后需要配置环境变量，然后在 cmd 中输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --version</span><br></pre></td></tr></table></figure><p>如果显示 curl 的版本号说明安装成功了~</p><h2 id="3"><a href="#3" class="headerlink" title="3."></a><em>3.</em></h2><p>有了 curl 命令，我们就可以执行 curl 命令来进行上传文件了，我们先看下蒲公英上传 apk 的接口文档，如下图：</p><p><img src="https://img-blog.csdnimg.cn/20190130093717762.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbnBlbmdmZWk1MjE=,size_16,color_FFFFFF,t_70" alt="image"></p><p>其中，_api_key、uKey 和 file 字段是必须的，其他参数都是可选项，_api_key 和 uKey 蒲公英都会为每个 APP 自动分配一个，在你的蒲公英账号对应的 APP 的信息中可以找到，file 参数就是要上传的文件了，为了让我们上传的 APP 有每次更新的描述，我们还需要添加一个 buildUpdateDescription 字段，这样，每次上传 APP 之后就可以显示本次更新的描述信息了。</p><p>文档看完之后，我们需要使用 curl 命令来发送一个上传文件的 POST 请求，url 的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl(选项)(参数)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190130093812715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbnBlbmdmZWk1MjE=,size_16,color_FFFFFF,t_70" alt="image"></p><p>curl 命令的选项有很多，上图只是截取了其中的一部分，根据蒲公英上传 APP 的接口文档，提交的是 multipart/form-data 类型的数据，因此我们使用 -F 选项，我们可以写出伪命令了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -F 参数1 -F 参数2 -F 参数3 接口地址</span><br></pre></td></tr></table></figure><p>因为我们上传 APP 需要 3 个参数，所以这里也需要三个参数，后面再加上我们请求的接口地址就可以了，这应该很好理解吧？</p><p>我们再把参数部分替换成真实的的参数，完整的命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -F &quot;file=app/build/outputs/apk/release/release-v1.0.apk&quot; -F &quot;uKey=ce0e825125bfe666762b2a93feb7de00&quot; -F &quot;_api_key=534a49154990d8e9126918fbdbee600a&quot; -F &quot;buildUpdateDescription=bugs fix!&quot; https://www.pgyer.com/apiv2/app/upload</span><br></pre></td></tr></table></figure><p>好了，一条完整的 curl 上传命令算是完成了，其中，-F 后面的参数是字段名和参数的值，中间用 “=” 号进行连接，然后我们打开 AS 的 Terminal，执行上面的命令即可进行上传 apk 到蒲公英，上传过程也有进度显示，如果显示 100%，说明上传成功了，注意上面的 uKey 和 _api_key 的值换成你自己的，另外也要注意你打完包的 apk 文件路径要真实存在，否则会出现异常！</p><h2 id="4"><a href="#4" class="headerlink" title="4."></a><em>4.</em></h2><p>上面我们已经学会了使用 curl 命令上传我们的 apk 了，但是你们有没有发现，我们每次上传 apk 需要好几步：</p><ul><li>打包 apk；</li><li>修改上传命令中 apk 的文件名和描述信息；</li><li>复制 curl 命令到 Terminal 中执行；</li><li>…</li></ul><p>至少需要 3 步才能完成，这也是一件非常麻烦的事情，作为程序员，都是比较懒的，与其说懒不如说是机智，避免做浪费时间的事情，我再想，能不能一条命令一步到位呢？当然是可以的。</p><p>我们先进行改造上传命令的第一步，先把 curl 命令中 file 的值，也就是 apk 路径动态进行获取，这样就不用每次都去修改了，我们知道 gradle 语法中的字符串有两种，一种是单引号，另一种是双引号，区别就是，双引号支持插值，这样我们就可以写一个方法，这个方法的作用就是获取打包好的 apk 的全路径，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def getApkFullPath() &#123;</span><br><span class="line">    return rootDir.getAbsolutePath() + &quot;/app/build/outputs/apk/release/&quot; + getApkName()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def getApkName() &#123;</span><br><span class="line">    return &quot;update-app-example-v$&#123;android.defaultConfig.versionName&#125;-$&#123;releaseTime()&#125;.apk&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static def releaseTime() &#123;</span><br><span class="line">    return new Date().format(&quot;yyyy-MM-dd&quot;, TimeZone.getTimeZone(&quot;UTC&quot;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面总共有 3 个方法，也比较简单，大家应该都能看得懂，就不过多解释了，其中第一个方法中的 <code>rootDir.getAbsolutePath()</code> 说一下，它可以获取你当前项目在你本地电脑的全路径。</p><p>方法写好了，我们还需要把打包脚本稍微修改下，具体如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">release &#123;</span><br><span class="line">            minifyEnabled false</span><br><span class="line">            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;</span><br><span class="line">            signingConfig signingConfigs.release</span><br><span class="line">            android.applicationVariants.all &#123; variant -&gt;</span><br><span class="line">                variant.outputs.all &#123;</span><br><span class="line">                    outputFileName = getApkName()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>注意看上面的 <code>outputFileName = getApkName()</code>，这样写每次生成的 apk 的名字就是我们要获取的 apk 的文件名，这样每次打包完后我们都能获取到打包完后的 apk 的文件名了！这样，我们 curl 上传命令中动态获取 apk 文件路径这个问题就算解决了，我们再看下我们的 curl 命令中还有 uKey 和 _api_key 两个参数，因为这两个值属于比较私密的东西我们一般都是配置到 <code>local.properties</code> 文件中，然后动态读取的，git 默认是忽略提交 <code>local.properties</code> 文件的，这样防止自己的私密信息被提交和泄露出去，因此，这里也写个方法动态读取一下吧：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def readProperties(key) &#123;</span><br><span class="line">    File file = rootProject.file(&apos;local.properties&apos;)</span><br><span class="line">    if (file.exists()) &#123;</span><br><span class="line">        InputStream inputStream = rootProject.file(&apos;local.properties&apos;).newDataInputStream()</span><br><span class="line">        Properties properties = new Properties()</span><br><span class="line">        properties.load(inputStream)</span><br><span class="line"></span><br><span class="line">        if (properties.containsKey(key)) &#123;</span><br><span class="line">            return properties.getProperty(key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法也比较简单，相信大家都能看的明白！</p><p>现在我们的上传命令中还有一个字段 <code>buildUpdateDescription</code>，更新描述信息，每次上传 apk 都需要修改一下更新的描述，直接在命令中修改，也不太好，因此我们也写个方法动态获取吧，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static def getUpdateDescription() &#123;</span><br><span class="line">    return &apos;1.修复一些bug；\n2.提升用户体验！&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，非常简单，一目了然，只要是程序员都能看得懂，如果你看不懂，说明你是伪程序员！</p><p>好了，终于完成了，我们最终上传的命令被改造成了这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -F &quot;file=@$&#123;getApkFullPath()&#125;&quot; -F &quot;uKey=$&#123;readProperties(&apos;pgyer.userKey&apos;)&#125;&quot; -F &quot;_api_key=$&#123;readProperties(&apos;pgyer.apiKey&apos;)&#125;&quot; -F &quot;buildUpdateDescription=$&#123;getUpdateDescription()&#125;&quot; https://www.pgyer.com/apiv2/app/upload</span><br></pre></td></tr></table></figure><h2 id="5"><a href="#5" class="headerlink" title="5."></a><em>5.</em></h2><p>上面的命令算是改造完成了，不知道你们有没有发现，有个致命的问题就是，这条命令怎么执行啊？因为我么你的命令中动态调用了 Gradle 中我们写的方法，直接在 Terminal 中执行肯定是会报错的！这可就尴尬了。。我们想了想，要想让我们上传命令中的方法能够被成功调用，这个命令和被调用的方法肯定是在同一个 Gradle 文件中的，我们再想能不能写一个 Task，这这个 Task 中执行我们的上传命令，这样不就解决问题了吗？嗯，想了想是可以的，我发现在写的过程中 Task 好写，但是我们这个命令怎么才能够执行呢？肯定也需要一个东西才能执行我们的命令，搜了下，Gradle 中有个 <code>exec</code> 东西，它可以执行一条具体的 bash 命令，嗯，灰常不错，可以的，very good!真香！最终我们写的完整的 Task 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">task(&quot;uploadApk&quot;) &#123;</span><br><span class="line">        def command = &quot;curl -F \&quot;file=@$&#123;getApkFullPath()&#125;\&quot; -F \&quot;uKey=$&#123;readProperties(&apos;pgyer.userKey&apos;)&#125;\&quot; -F \&quot;_api_key=$&#123;readProperties(&apos;pgyer.apiKey&apos;)&#125;\&quot; -F \&quot;buildUpdateDescription=$&#123;getUpdateDescription()&#125;\&quot; https://www.pgyer.com/apiv2/app/upload&quot;</span><br><span class="line">        println &quot;command:&quot; + command</span><br><span class="line">        try &#123;</span><br><span class="line">            exec &#123;</span><br><span class="line">                ExecSpec execSpec -&gt;</span><br><span class="line">                    executable &apos;bash&apos;</span><br><span class="line">                    args &apos;-c&apos;, command</span><br><span class="line">            &#125;</span><br><span class="line">            println &quot;uploadApk success~&quot;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码相对也比较简单，其中 <code>ExecSpec</code> 大家可能看着比较陌生，executable ‘bash’ 为固定写法，其中 bash 代表 shell 的类型，Linux 下有很多种 shell 的类型，流行的 shell 有 ash、bash、ksh、csh、zsh 等，一般我们常用的都是 bash，其中的 command 就是一条具体的命令了。</p><p>这样，我们只要执行这个 Task 就可以自动执行上传命令并动态获取我们所需要的参数了~</p><h2 id="6"><a href="#6" class="headerlink" title="6."></a><em>6.</em></h2><p>上面的命令执行起来是非常方便的，但是在实际使用中，我们发现，需要先打完包之后才能执行上传的 Task，我们知道 Gradle 中的 Task 是可以依赖另一个 Task 的，打包命令实质上也是一个 Task，这样我们让我们自己写的 Task 依赖于打包的 Task 不就行了吗？我觉得没毛病，这样，当执行完打包后，自动执行上传命令，这样一条命令就可以解决问题，另外，我们自己的 Task 也需要稍微修改下，将上传的实现部分放到 <code>doLast</code> 闭包中，完成代码入下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">task(&quot;uploadApk&quot;) &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        def command = &quot;curl -F \&quot;file=@$&#123;getApkFullPath()&#125;\&quot; -F \&quot;uKey=$&#123;readProperties(&apos;pgyer.userKey&apos;)&#125;\&quot; -F \&quot;_api_key=$&#123;readProperties(&apos;pgyer.apiKey&apos;)&#125;\&quot; -F \&quot;buildUpdateDescription=$&#123;getUpdateDescription()&#125;\&quot; https://www.pgyer.com/apiv2/app/upload&quot;</span><br><span class="line">        println &quot;command:&quot; + command</span><br><span class="line">        try &#123;</span><br><span class="line">            exec &#123;</span><br><span class="line">                ExecSpec execSpec -&gt;</span><br><span class="line">                    executable &apos;bash&apos;</span><br><span class="line">                    args &apos;-c&apos;, command</span><br><span class="line">            &#125;</span><br><span class="line">            println &quot;uploadApk success~&quot;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uploadApk.dependsOn(&quot;assembleRelease&quot;)</span><br></pre></td></tr></table></figure><p>从此，我们只要在 Terminal 中执行一条命令就可以实现打包上传了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew uploadApk</span><br></pre></td></tr></table></figure><p>温馨提示：Windows 用户执行命令不需要加 ./</p><p>怎么样？是不是很爽！这个效率上的提升不是一点半点，后续我再想能不能把这个功能封装成一个 Gradle 插件的形式，提供给大家使用，这样也许是要添加一两行代码引用一下插件的就可以使用了，这样就更加方便了，敬请期待吧~</p><p>如果我的文章对你有用，欢迎留言！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;作为一名Android 开发者，我们都有发布 APP 内测版本的经历，有的公司是发布到自己的服务器上，生成一个连接或者二维码扫描就可以下载，有的公司使用一些内测平台如蒲公英、fir.im 等，有这么好的内测平台为什么不用呢？一方面这些平台的基本都是
      
    
    </summary>
    
      <category term="Android" scheme="http://www.x-sir.com/categories/Android/"/>
    
    
      <category term="pgyer" scheme="http://www.x-sir.com/tags/pgyer/"/>
    
      <category term="Gradle" scheme="http://www.x-sir.com/tags/Gradle/"/>
    
      <category term="upload" scheme="http://www.x-sir.com/tags/upload/"/>
    
  </entry>
  
  <entry>
    <title>一行代码实现蒲公英市场APP检查更新</title>
    <link href="http://www.x-sir.com/2019/01/08/%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E8%92%B2%E5%85%AC%E8%8B%B1%E5%B8%82%E5%9C%BAAPP%E6%A3%80%E6%9F%A5%E6%9B%B4%E6%96%B0/"/>
    <id>http://www.x-sir.com/2019/01/08/一行代码实现蒲公英市场APP检查更新/</id>
    <published>2019-01-08T14:40:00.000Z</published>
    <updated>2019-01-09T14:41:06.007Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我们知道，只要是个 APP 就都有更新的功能，可以说这个功能是比较重要的功能，我们在上架之前都会发布测试的版本，测试一般都是发布到蒲公英、Fir.im 等平台，可以说这个需求也算是比较普遍的一个功能了，之前我们的 APP 用的是蒲公英公测，然后现在又有一个新的 APP 需要，这就需要把之前的更新功能重写一遍，其实这是比较麻烦的，也没有必要，我想着能不能把这个功能抽取出来，于是就有了今天这个库。</p></blockquote><h2 id="1-实现思路"><a href="#1-实现思路" class="headerlink" title="1.实现思路"></a>1.实现思路</h2><p>其实，要实现这个功能也比较简单，第一步，我先是判断是否有读写外部存储的权限，因为下载 apk 一般来说是要下载到手机的 SD 卡上；如果有权限，那就调用蒲公英的更新检测接口，这个接口至少需要两个参数，apiKey 和 appKey，这两个值我们在蒲公英的 APP 信息中可以查到，我的想法是在清单文件中，让用户去设置这两个值，然后我动态取出来，这样就解决了这两个参数值传递的问题；接口请求成功后，会返回 buildVersionNo这个字段，然后通过这个返回字段与本地的 versionCode 去比对，如果比本地的大，说明就有新版本，然后弹出对话框，提示用户更新，当用户点击“更新”时，就去下载对应的版本即可，下载完成后调用安装程序，这样基本的更新思路就出来了。</p><h2 id="2-使用方式"><a href="#2-使用方式" class="headerlink" title="2.使用方式"></a>2.使用方式</h2><p>使用方式也比较简单，我已经将库发布到 jCenter 上了，大家查看项目的主页即可：</p><p><a href="https://github.com/xinpengfei520/pgyer-android-app-update" target="_blank" rel="noopener">https://github.com/xinpengfei520/pgyer-android-app-update</a></p><p>如果你觉得有帮助的话，请帮我点个 star，谢谢！另外，欢迎大家 fork 和 PR。</p><p>温馨提示：<br>点击查看原文可以看到项目的主页。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;我们知道，只要是个 APP 就都有更新的功能，可以说这个功能是比较重要的功能，我们在上架之前都会发布测试的版本，测试一般都是发布到蒲公英、Fir.im 等平台，可以说这个需求也算是比较普遍的一个功能了，之前我们的 APP 用的是蒲公英公测，然后现在
      
    
    </summary>
    
      <category term="Android" scheme="http://www.x-sir.com/categories/Android/"/>
    
    
      <category term="update-app" scheme="http://www.x-sir.com/tags/update-app/"/>
    
      <category term="pgyer" scheme="http://www.x-sir.com/tags/pgyer/"/>
    
  </entry>
  
  <entry>
    <title>BaseRecyclerViewAdapterHelper 让 RecyclerView 用起来更爽</title>
    <link href="http://www.x-sir.com/2018/12/27/BaseRecyclerViewAdapterHelper/"/>
    <id>http://www.x-sir.com/2018/12/27/BaseRecyclerViewAdapterHelper/</id>
    <published>2018-12-27T09:10:57.000Z</published>
    <updated>2018-12-27T09:13:01.859Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>BaseRecyclerViewAdapterHelper 是 GitHub 上的一个开源库，它可以让 RecyclerView 的使用更简单，方便和清晰，和原始的 adapter 相比，减少 70% 的代码量。确实，我最近的项目中也集成了这个库，并把之前的所有的 Adapter 都替换了为了库中的实现方式，代码量减少了，逻辑也更加清晰了，减少了一些无用功，提高了开发效率！强烈推荐大家使用。</p></blockquote><p>这个库也算封装的很好了，正常情况下，可以满足大部分的开发需求，其主要有一下几大优点：</p><ol><li>支持设置各种加载动画；</li><li>支持添加多个头和多个尾布局；</li><li>支持自动加载和预加载；</li><li>支持分组布局；</li><li>支持树形结构，也就是我们常说的折叠分组效果；</li><li>支持多种数据类型及多种布局的实现效果；</li><li>支持设置数据为空时的布局；</li><li>支持侧滑刷新和拖拽动作；</li><li>支持下拉刷新和加载更多；</li><li>支持自定义 ViewHolder；</li><li>更多请自行去发现…</li></ol><p>开源库地址：<a href="https://github.com/CymChad/BaseRecyclerViewAdapterHelper" target="_blank" rel="noopener">https://github.com/CymChad/BaseRecyclerViewAdapterHelper</a></p><p>开源库中文文档：<a href="https://www.jianshu.com/p/b343fcff51b0" target="_blank" rel="noopener">https://www.jianshu.com/p/b343fcff51b0</a></p><p>官方网站：<a href="http://www.recyclerview.org/" target="_blank" rel="noopener">http://www.recyclerview.org/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;BaseRecyclerViewAdapterHelper 是 GitHub 上的一个开源库，它可以让 RecyclerView 的使用更简单，方便和清晰，和原始的 adapter 相比，减少 70% 的代码量。确实，我最近的项目中也集成了这个库，
      
    
    </summary>
    
      <category term="Android" scheme="http://www.x-sir.com/categories/Android/"/>
    
    
      <category term="RecyclerView" scheme="http://www.x-sir.com/tags/RecyclerView/"/>
    
      <category term="Adapter" scheme="http://www.x-sir.com/tags/Adapter/"/>
    
  </entry>
  
  <entry>
    <title>绘制一个漂亮的弧形 View</title>
    <link href="http://www.x-sir.com/2018/11/06/%E7%BB%98%E5%88%B6%E4%B8%80%E4%B8%AA%E6%BC%82%E4%BA%AE%E7%9A%84%E5%BC%A7%E5%BD%A2%20View/"/>
    <id>http://www.x-sir.com/2018/11/06/绘制一个漂亮的弧形 View/</id>
    <published>2018-11-06T03:28:01.000Z</published>
    <updated>2018-12-08T15:02:48.596Z</updated>
    
    <content type="html"><![CDATA[<p>来，先看下效果图：</p><p><img src="http://pcobk8jbf.bkt.clouddn.com/FjVEV1HKnkl637u0Qs7im1YRfBjo" alt=""></p><p>怎么样？漂亮吧，上面是一个标题栏，下面是一个弧形的 View，标题栏和弧形 View 从左到右都有一个线性的渐变色，类似于手机 QQ 顶部的渐变效果，关于弧形的这种效果，使用的场景还是比较普遍的，小面我们就一起来看看如何绘制吧。</p><h2 id="1-先自定义一个-ArcView"><a href="#1-先自定义一个-ArcView" class="headerlink" title="1.先自定义一个 ArcView"></a>1.先自定义一个 ArcView</h2><p>创建一个类 ArcView 继承于 View，然后我们重写其三个构造方法，还有 onMeasure() 和 onDraw() 方法，这都是自定义 View 最基本的写法，比较简单这里就不详细说了， onMeasure() 用于测量 View 的宽高尺寸，onDraw() 就是具体的绘制过程了，具体的绘制思路是：我们在 onMeasure（）方法中拿到测量出来的宽和高，然后再 onDraw() 中初始化一个画笔，我们可以创建一个 LinearGradient 对象，然后调用设置画笔的 setShader() 方法就可以达到画笔渐变色的效果，然后再创建一个 Rect 对象，这里只是创建了一个矩形对象，要想绘制弧形，我们还需要设置绘制的路径，创建一个 Path 对象，分别调用 moveTo() 方法，和 quadTo() 方法，moveTo （）不会进行绘制，只用于移动移动画笔，一般和其他方法配合使用，这里和 quadTo() 方法配合使用，而 quadTo() 用于绘制圆滑的曲线，即贝塞尔曲线。mPath.quadTo(x1, y1, x2, y2) 其中x1、y1 为控制点，x2、y2 为结束点。有了路径之后我们就可以轻而易举地绘制出一个弧形了，完整的代码请看下面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by x-sir on 2018/8/10 :)</span><br><span class="line"> * Function:自定义弧形 View</span><br><span class="line"> */</span><br><span class="line">public class ArcView extends View &#123;</span><br><span class="line"></span><br><span class="line">    private int mWidth;</span><br><span class="line">    private int mHeight;</span><br><span class="line">    private int mArcHeight; // 弧形高度</span><br><span class="line">    private int mBgColor; // 背景颜色</span><br><span class="line">    private Paint mPaint;</span><br><span class="line"></span><br><span class="line">    public ArcView(Context context) &#123;</span><br><span class="line">        this(context, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ArcView(Context context, @Nullable AttributeSet attrs) &#123;</span><br><span class="line">        this(context, attrs, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ArcView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">        super(context, attrs, defStyleAttr);</span><br><span class="line">        TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.ArcView);</span><br><span class="line">        mArcHeight = typedArray.getDimensionPixelSize(R.styleable.ArcView_arcHeight, 0);</span><br><span class="line">        mBgColor = typedArray.getColor(R.styleable.ArcView_bgColor, Color.parseColor(&quot;#1E90FF&quot;));</span><br><span class="line">        typedArray.recycle();</span><br><span class="line">        mPaint = new Paint();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressLint(&quot;DrawAllocation&quot;)</span><br><span class="line">    @Override</span><br><span class="line">    protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">        super.onDraw(canvas);</span><br><span class="line">        // 参数一为渐变起初点坐标 x 位置，参数二为 y 轴位置，参数三和四分辨对应渐变终点，最后参数为平铺方式，这里设置为镜像</span><br><span class="line">        LinearGradient lg = new LinearGradient(0, 0, mWidth, 0,</span><br><span class="line">                Color.parseColor(&quot;#4796FB&quot;), Color.parseColor(&quot;#5AB4F9&quot;),</span><br><span class="line">                Shader.TileMode.CLAMP);</span><br><span class="line">        // 刚才已经讲到 Gradient 是基于 Shader 类，所以我们通过 Paint 的 setShader 方法来设置这个渐变</span><br><span class="line">        mPaint.setShader(lg);</span><br><span class="line">        mPaint.setStyle(Paint.Style.FILL);</span><br><span class="line">        //mPaint.setColor(mBgColor);</span><br><span class="line">        mPaint.setAntiAlias(true);</span><br><span class="line">        Rect rect = new Rect(0, 0, mWidth, mHeight - mArcHeight);</span><br><span class="line">        canvas.drawRect(rect, mPaint);</span><br><span class="line">        Path path = new Path();</span><br><span class="line">        path.moveTo(0, mHeight - mArcHeight);</span><br><span class="line">        path.quadTo(mWidth / 2, mHeight, mWidth, mHeight - mArcHeight);</span><br><span class="line">        canvas.drawPath(path, mPaint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">        super.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        int widthSize = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">        int widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">        int heightSize = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">        int heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">        if (widthMode == MeasureSpec.EXACTLY) &#123;</span><br><span class="line">            mWidth = widthSize;</span><br><span class="line">        &#125;</span><br><span class="line">        if (heightMode == MeasureSpec.EXACTLY) &#123;</span><br><span class="line">            mHeight = heightSize;</span><br><span class="line">        &#125;</span><br><span class="line">        setMeasuredDimension(mWidth, mHeight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我这里只定义了弧形的高度和背景颜色这两个自定义属性，其中还有渐变颜色的开始色值和结束色值，还有是否需要渐变等属性，都可以定义为自定义的属性，方便直接在布局文件中灵活进行配置，以适应不同的需求，也比较简单，我这里为了就不实现了。</p><h2 id="2-自定义一个通用的-titlebar"><a href="#2-自定义一个通用的-titlebar" class="headerlink" title="2.自定义一个通用的 titlebar"></a>2.自定义一个通用的 titlebar</h2><p>这样做我们可以提高代码的复用性，可以将一些功能封装进去，也更好地体现了封装的思想，实现也比较简单，使用 LayoutInflater 加载了一个布局文件，然后将 文字，字体大小，字体颜色和 title 背景色等定义成了自定义的属性，方便在布局文件中进行设置，另外我们内部默认处理了点击返回按钮的事件，对于需要其他特殊情况下返回按钮的处理，我们也定义了一个接口，方便外部使用接口来自行进行处理，代码也非常简单，看下面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by x-sir on 2018/9/2 :)</span><br><span class="line"> * Function:自定义通用 TitleBar</span><br><span class="line"> */</span><br><span class="line">public class TitleBarLayout extends LinearLayout &#123;</span><br><span class="line"></span><br><span class="line">    private ImageView ivBack;</span><br><span class="line">    private ImageView ivMenu;</span><br><span class="line">    private TextView tvTitleName;</span><br><span class="line">    private LinearLayout llTitleBg;</span><br><span class="line">    private CharSequence mText;</span><br><span class="line">    private int mTitleBgColor;</span><br><span class="line">    private boolean mMenuVisible;</span><br><span class="line">    private int mTextSize;</span><br><span class="line">    private int mTextColor;</span><br><span class="line">    private OnMenuClickListener mListener;</span><br><span class="line">    private OnBackClickListener mOnBackListener;</span><br><span class="line">    private static final String DEFAULT_TEXT = &quot;Title&quot;; // default text.</span><br><span class="line">    private static final int DEFAULT_TEXT_SIZE = 16; // default text size.</span><br><span class="line">    private static final String TAG = &quot;TitleBarLayout&quot;;</span><br><span class="line"></span><br><span class="line">    public TitleBarLayout(Context context) &#123;</span><br><span class="line">        this(context, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public TitleBarLayout(Context context, @Nullable AttributeSet attrs) &#123;</span><br><span class="line">        this(context, attrs, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public TitleBarLayout(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">        super(context, attrs, defStyleAttr);</span><br><span class="line"></span><br><span class="line">        TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.TitleBarLayout);</span><br><span class="line">        mText = typedArray.getText(R.styleable.TitleBarLayout_text);</span><br><span class="line">        mTextSize = typedArray.getDimensionPixelSize(R.styleable.TitleBarLayout_textSize, DEFAULT_TEXT_SIZE);</span><br><span class="line">        mTextColor = typedArray.getColor(R.styleable.TitleBarLayout_textColor, Color.parseColor(&quot;#FFFFFF&quot;));</span><br><span class="line">        mTitleBgColor = typedArray.getColor(R.styleable.TitleBarLayout_titleBgColor, Color.parseColor(&quot;#1E90FF&quot;));</span><br><span class="line">        mMenuVisible = typedArray.getBoolean(R.styleable.TitleBarLayout_menuVisible, false);</span><br><span class="line">        typedArray.recycle();</span><br><span class="line"></span><br><span class="line">        initView(context);</span><br><span class="line">        initData();</span><br><span class="line">        initListener();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void initView(Context context) &#123;</span><br><span class="line">        LayoutInflater.from(context).inflate(R.layout.common_titlebar, this);</span><br><span class="line">        ivBack = findViewById(R.id.ivBack);</span><br><span class="line">        ivMenu = findViewById(R.id.ivMenu);</span><br><span class="line">        tvTitleName = findViewById(R.id.tvTitleName);</span><br><span class="line">        llTitleBg = findViewById(R.id.llTitleBg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void initData() &#123;</span><br><span class="line">        String text = (mText != null) ? mText.toString() : DEFAULT_TEXT;</span><br><span class="line">        tvTitleName.setText(text);</span><br><span class="line">        tvTitleName.setTextSize(TypedValue.COMPLEX_UNIT_PX, mTextSize);</span><br><span class="line">        tvTitleName.setTextColor(mTextColor);</span><br><span class="line">        //llTitleBg.setBackgroundColor(mTitleBgColor);</span><br><span class="line">        ivMenu.setVisibility(mMenuVisible ? VISIBLE : INVISIBLE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void initListener() &#123;</span><br><span class="line">        ivBack.setOnClickListener(v -&gt; &#123;</span><br><span class="line">            // 如果监听器不为空就让其自己处理，为空就默认处理（销毁页面）</span><br><span class="line">            if (mOnBackListener != null) &#123;</span><br><span class="line">                mOnBackListener.onClick();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ((Activity) getContext()).finish();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        ivMenu.setOnClickListener(v -&gt; &#123;</span><br><span class="line">            if (mListener != null) &#123;</span><br><span class="line">                mListener.onClick();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTitleName(String title) &#123;</span><br><span class="line">        if (!TextUtils.isEmpty(title)) &#123;</span><br><span class="line">            tvTitleName.setText(title);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Log.e(TAG, &quot;set title name failed, because title is null!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setOnMenuListener(OnMenuClickListener mListener) &#123;</span><br><span class="line">        this.mListener = mListener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setOnBackListener(OnBackClickListener mOnBackListener) &#123;</span><br><span class="line">        this.mOnBackListener = mOnBackListener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public interface OnMenuClickListener &#123;</span><br><span class="line">        void onClick();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public interface OnBackClickListener &#123;</span><br><span class="line">        void onClick();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为这里为了和绘制的弧形协调，我将 title 布局的背景设置了一个渐变的 shape 。</p><h2 id="3-将布局延伸到系统状态栏"><a href="#3-将布局延伸到系统状态栏" class="headerlink" title="3.将布局延伸到系统状态栏"></a>3.将布局延伸到系统状态栏</h2><p>Android 5.0 之后我们可以设置 Activity 的布局延伸到系统状态栏中，这样我们页面看起来更美观和协调，设置也比较简单，直接贴代码了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span><br><span class="line">        getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>另外在布局文件中也可以设置，只需在你 App 引用的主题中添加一行代码即可：</p><p><img src="http://pcobk8jbf.bkt.clouddn.com/FtLpSwRRbekR_PbI6n24DXvRqM8m" alt=""></p><p>注意：因为这个属性是 5.0 之后才有的，在实际开发中需要做兼容处理，代码中设置时需要判断一下版本，布局文件中可以新建一个 values-v21 文件夹做兼容处理。</p><p>如果你的 title 的文字跑到状态栏里了，那样会很丑，在 title 布局的根标签中添加下面一行代码就可以了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:fitsSystemWindows=&quot;true&quot;</span><br></pre></td></tr></table></figure><p>这行代码的意思就是不占用系统状态栏的空间。</p><p>好了，所有绘制工作都已经完成了，是不是非常简单呢？如果觉得不错的话，欢迎点赞、评论和转发，你们的支持是我坚持不懈的动力！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;来，先看下效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pcobk8jbf.bkt.clouddn.com/FjVEV1HKnkl637u0Qs7im1YRfBjo&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;怎么样？漂亮吧，上面是一个标题栏，下面是一个弧形的 View，标
      
    
    </summary>
    
      <category term="Android" scheme="http://www.x-sir.com/categories/Android/"/>
    
    
      <category term="View" scheme="http://www.x-sir.com/tags/View/"/>
    
      <category term="技术提升" scheme="http://www.x-sir.com/tags/%E6%8A%80%E6%9C%AF%E6%8F%90%E5%8D%87/"/>
    
      <category term="ArcView" scheme="http://www.x-sir.com/tags/ArcView/"/>
    
  </entry>
  
  <entry>
    <title>你租的房子遇 “坑” 了么？</title>
    <link href="http://www.x-sir.com/2018/10/26/%E4%BD%A0%E7%A7%9F%E7%9A%84%E6%88%BF%E5%AD%90%E9%81%87%20%E2%80%9C%E5%9D%91%E2%80%9D%20%E4%BA%86%E4%B9%88%EF%BC%9F/"/>
    <id>http://www.x-sir.com/2018/10/26/你租的房子遇 “坑” 了么？/</id>
    <published>2018-10-26T14:59:57.000Z</published>
    <updated>2018-12-08T15:04:57.044Z</updated>
    
    <content type="html"><![CDATA[<h1 id="你租的房子遇-“坑”-了么？"><a href="#你租的房子遇-“坑”-了么？" class="headerlink" title="你租的房子遇 “坑” 了么？"></a>你租的房子遇 “坑” 了么？</h1><blockquote><p>前段时间真的是太忙了，出差了一周，另外还有自己的一堆事儿，忙成狗，几乎每天也就睡 5、6 个小时，现在终于不忙了，然后就可以安安静静地写文章了，好久没更了，让大家久等了。最近这段时间我身边发生了好多事情，有欠钱不还的，有租房被中介坑的，有公司裁员的… 真的是发生在谁身上谁倒霉，有些事情我们也无法避免，我们要做的就是不断吸取教训，长点心眼，提高自己判断力，来保护自己的利益不受侵害。</p></blockquote><p>自从前一段时间爆出来自如甲醛房子的问题，后来又有自媒体爆料，一阿里 P7 员工在租住了杭州自如房 6 个月后，被查出患白血病，不久之后病情恶化，去世，一度引发舆论的关注！最近，又有媒体陆续曝出租客在自如出租房内的插座里发现针孔摄像头，租住数月后才发现。最近我身边几个认识的同学、同事租房也被中介坑，好像最近一段时间骗子又猖狂起来了？</p><h2 id="1-“寓见”你真是倒了八辈子的霉了"><a href="#1-“寓见”你真是倒了八辈子的霉了" class="headerlink" title="1.“寓见”你真是倒了八辈子的霉了"></a>1.“寓见”你真是倒了八辈子的霉了</h2><p>【上海寓见公寓“爆仓”“租金贷”风险恐密集爆发】曾被雷军看好的长租公寓“爆仓”了。如今寓见公寓资金链断裂，一些房东在未收到租金的情况下，要求房客搬出。部分租客已聚集在寓见公寓总部所在地的上海市徐汇经侦支队报案，并试图“围堵”寓见公寓CEO 兼创始人林小森。在寓见公寓此次“爆仓”前，已经有多家长租公寓品牌出现问题。</p><p>这件事情真真切切的就发生在我同学的身上，他们从“寓见公寓”那里租的房子，“寓见公寓”从房东那里租的房子，她们每个月按时把租金交给“寓见公寓”，而“寓见公寓”没有把钱给房东，现在房东没有收到钱，房东现在找租客的事，另外，“寓见公寓”给租客们签的合同都是通过贷款平台贷的款，相当于是每个月的房租是分期付款，假设你签了 1 年的合同，那也就是说，“寓见公寓” 一次性就拿到了 1 年的租金（有钱了就可以去用钱去赚更多的钱了），然后，租客就每个月向贷款机构去还钱，这里说明一下，租客其实是不知道他们向贷款机构借钱了，签合同的时候，寓见的人只是说，这这个平台只是交租金，并没有向租客明确说明贷款这件事，我认为“寓见”隐瞒了事实，侵犯了租客的知情权，存在欺诈行为，当出现了事情之后，租客们才知道是“被”贷款了，如果没出现这事，租客可能一直都不知道“被”贷款了，现在的各种贷款都和你的征信挂钩，如果你没有按时交的话，有可能已经影响到你的征信了，可能影响到你买房买车等，但是你却全然不知，真的是太坑了，稍微一不注意就掉坑里了。现在“寓见”跑路，房东不让租客住房子，为了不影响征信，租客还要还贷款，你说这不是两头受气吃亏么？都是打工的，辛辛苦苦工作一个月，把工资的一大部分都交房租了，还遇到这样的事情，你说糟心不糟心？这种事情报案的话，处理起来也比较麻烦，能起到的作用也比较有限，所以，我们要擦亮自己的眼睛才是最主要的！</p><p>在这里提醒大家一下：如果租房的时候让你绑定个人银行卡并且还要让你通过某个你没听过的平台交房租时，你可得警惕注意了，稍不注意你就“被”贷款了！</p><h2 id="2-黑中介“昊园恒业”是真的黑"><a href="#2-黑中介“昊园恒业”是真的黑" class="headerlink" title="2.黑中介“昊园恒业”是真的黑"></a>2.黑中介“昊园恒业”是真的黑</h2><p><img src="http://pcobk8jbf.bkt.clouddn.com/15405599314402.jpg" alt=""></p><p>这件事也是发生在我之前同事的身上，她之前是通过“昊园恒业”租的房子，然后在不知情的情况下，也被贷款了，是通过一个叫“元宝e家”的分期付款平台，元宝一次性把钱转给中介，现在中介违约了，中途让租客搬家，现在中介需要把钱返给元宝或者是将剩余的部分返给租客，但是中介一直拖着迟迟不给，现在租客和元宝之间的贷款还是有效的，也就说租客还要给元宝还贷款（影响征信），为什么中介迟迟拿不出钱？想都不用想，中介肯定把钱挪作他用了，一次性收一年的房租，中介才不会傻傻把钱拿手里或者存银行，他肯定是用这笔收过来的租金再搞其他投资，然后赚更多的钱，说白了就是以租房为幌子，玩的是资金流的把戏，美其名曰：“帮租客们减轻租房的压力，分期付款，享受高品质的生活”，嗯，没毛病，这样租户付款压力减轻了，还不用支付额外的利息，于是很多租户就接受了这种付款方式，这样租客们就轻轻松松的掉坑里了！</p><p>下图是我前同事给大家的一些建议，都是血淋淋的教训，希望大家引以为鉴！</p><p><img src="http://pcobk8jbf.bkt.clouddn.com/IMG_1692.jpg" alt=""></p><p>最后，建议大家在租房的时候，首先找个人的房源或者是比较靠谱的中介，可以先搜一下中介的网上的评价或者有没有负面信息，然后再考虑要不要租，再签合同的时候也需要仔细看看有没有坑，另外对于押金条及合同等其他的材料要保留好，如果发生其他情况可作为证据，对于合同内容部分应该也必须加盖相应的公章，否则合同也是无效的合同，有些中介根本就没有合同或者合同很粗糙（严格来说不算合同），那你就得注意了，希望大家在租房的时候多留意，多长点心眼；还有就是租房的时候不要租刚装修完的房子，看着很干净，实则甲醛等严重超标，最好时租之前有人住过的房子就基本没什么问题。最后送给大家一句话，害人之心不可有，防人之心不可无！</p><p>如果，你也在租房时遇到坑了，欢迎在下方评论，让更多的人看到，另外你觉得文章不错的话，欢迎点赞和转发，原创不易，且行且珍惜，谢谢你们！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;你租的房子遇-“坑”-了么？&quot;&gt;&lt;a href=&quot;#你租的房子遇-“坑”-了么？&quot; class=&quot;headerlink&quot; title=&quot;你租的房子遇 “坑” 了么？&quot;&gt;&lt;/a&gt;你租的房子遇 “坑” 了么？&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;前段时间真的是太忙
      
    
    </summary>
    
      <category term="生活" scheme="http://www.x-sir.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="租房" scheme="http://www.x-sir.com/tags/%E7%A7%9F%E6%88%BF/"/>
    
      <category term="生活" scheme="http://www.x-sir.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你搭建 Hexo + GitHub 博客</title>
    <link href="http://www.x-sir.com/2018/10/10/HexoBlogBuild/"/>
    <id>http://www.x-sir.com/2018/10/10/HexoBlogBuild/</id>
    <published>2018-10-10T15:47:57.000Z</published>
    <updated>2018-12-08T15:34:36.684Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-环境安装"><a href="#1-环境安装" class="headerlink" title="1.环境安装"></a>1.环境安装</h2><h3 id="1-1-Git"><a href="#1-1-Git" class="headerlink" title="1.1 Git"></a>1.1 Git</h3><p>Windows:<br><a href="https://gitforwindows.org/" target="_blank" rel="noopener">https://gitforwindows.org/</a></p><p>如果是 Mac 电脑的话，请先安装 Xcode，因为 Xcode 自带 Git.</p><h3 id="1-2-Node-js"><a href="#1-2-Node-js" class="headerlink" title="1.2 Node.js"></a>1.2 Node.js</h3><p>下载对应系统的 node 安装包，一路 next 无脑安装即可；</p><p><a href="https://nodejs.org/en/" target="_blank" rel="noopener">https://nodejs.org/en/</a></p><h3 id="1-3-hexo"><a href="#1-3-hexo" class="headerlink" title="1.3 hexo"></a>1.3 hexo</h3><p>因为 npm 命令是 node 中的，所有需要先安装node 然后再安装 hexo，然后利用 npm 命令即可安装 hexo（Windows 在任意位置点击鼠标右键，选择 Git bash，Mac 直接在终端中如下执行命令即可）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure><p>提示本篇文章可能存在时效性，最新版本 hexo 的安装请查看官方文档：</p><p><a href="https://hexo.io/docs/" target="_blank" rel="noopener">https://hexo.io/docs/</a></p><p>报错:</p><p>npm ERR! registry error parsing json 错误，可能需要设置 npm 代理，执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry http://registry.cnpmjs.org</span><br></pre></td></tr></table></figure><p>hexo:command not found<br>删除刚刚安装的 npm 目录，重新执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure><p>来安装 hexo。</p><h2 id="2-开始搭建"><a href="#2-开始搭建" class="headerlink" title="2.开始搭建"></a>2.开始搭建</h2><p>首先创建 hexo 文件夹，如 HexoBlog，注意创建的文件夹一定是空的！！！进入 HexoBlog 目录并执行以下指令(Windows 在 HexoBlog 文件夹内点击鼠标右键，选择 Git bash，Mac 直接 cd 进入)，Hexo 即会自动在文件夹生成网站所需要的所有文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>安装依赖包:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><p>报错：</p><p>evernotecid://785B2D88-EE4A-435D-8F13-6593AEC86C1F/appyinxiangcom/15001405/ENResource/p25846<img src="http://pcobk8jbf.bkt.clouddn.com/FhjB0eR8pfC5j4rXk0pept0hCEwJ" alt=""></p><p>根据错误提示，是系统没有 <strong>package.json</strong> 这个文件导致。这个文件的作用就是管理你本地安装的<strong>npm</strong> 包，一个 <strong>package.json</strong> 文件可以做如下事情：</p><p>1.展示项目所依赖的npm包；<br>2.允许你指定一个包的版本[范围]；<br>3.让你建立起稳定，意味着你可以更好的与其他开发者共享；</p><p>此刻我们需要执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure><p>创建package.json文件，系统会提示相关配置，也可以使用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure><p>直接创建 <strong>package.json</strong> 文件，这样创建好处是必填项已经帮你填好，执行完命令后可以看到用户路径下多了一个 <strong>package.json</strong> 文件。</p><p>温馨提示：如果是 Mac 的话，执行每一步命令记得都需要加 sudo !</p><p>现在我们已经搭建起本地的 hexo 博客了，执行以下命令，然后到浏览器输入<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>hexo generate<br>hexo server<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">好了，至此，我们本地博客已经搭建起来了，这里只能本地访问，别人看不到的，我们搭建的博客如果只是在本地那是没有任何意义的，接下来，我们需要把本地的博客部署到 GitHub 上去。</span><br><span class="line"></span><br><span class="line">报错：</span><br><span class="line"></span><br><span class="line">执行 ```hexo server``` 提示找不到该指令!</span><br><span class="line"></span><br><span class="line">解决办法：</span><br><span class="line"></span><br><span class="line">在 **Hexo 3.0** 后 **server** 被单独出来了，需要安装 **server**，安装的命令如下：</span><br></pre></td></tr></table></figure></p><p>npm install hexo -server –save<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">安装 **server** 后再试，问题解决~</span><br><span class="line"></span><br><span class="line">## 3.GitHub 创建博客</span><br><span class="line"></span><br><span class="line">如果已经有 GitHub 账号就创建一个仓库，仓库的名字需要和你的账号对应，格式为: **yourname.github.io** 其中 yourname 就是你的 GitHub 的用户名。</span><br><span class="line"></span><br><span class="line">如果没有 GitHub 账号，您需要先注册一个账号，注册完之后需要把你本地机器的 公钥添加到 GitHub 中去。</span><br><span class="line"></span><br><span class="line">### 3.1 生成 SSH 密钥</span><br><span class="line"></span><br><span class="line">打开 Git Bash 执行如下命令行：</span><br></pre></td></tr></table></figure></p><p>ssh-keygen -t rsa -C “youremailaddress”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">执行完会提示你输入一些信息，这里我们直接一路回车即可，密码设置为空。</span><br><span class="line"></span><br><span class="line">### 3.2 查看 SSH 密钥</span><br><span class="line"></span><br><span class="line">SSH 公钥默认储存在账户的主目录下的 ~/.ssh 目录，进入 .ssh 目录下，命令行：</span><br></pre></td></tr></table></figure></p><p>ls<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">查看如果显示 id_rsa 和 id_rsa.pub，说明已经成功生成了 SSH 公钥。</span><br><span class="line"></span><br><span class="line">### 3.3 添加 SSH 密钥</span><br><span class="line"></span><br><span class="line">打开 id_rsa.pub（Windows 可用任意一个文本编辑器打开，Mac 下用 cat 或者 vim 编辑器查看）复制里面的全部内容到:</span><br><span class="line"></span><br><span class="line">[https://github.com/settings/ssh](https://github.com/settings/ssh) </span><br><span class="line"></span><br><span class="line">找到 Add SSH key，粘贴进去并保存～</span><br><span class="line"></span><br><span class="line">添加 ssh 的作用是你的 GitHub 就可以和你本地的机器进行 push 和 pull 操作了，不需要输入任何的密码，GitHub 就已经知道你是操作的了。</span><br><span class="line"></span><br><span class="line">## 4.Hexo 的使用</span><br><span class="line"></span><br><span class="line">### 4.1 Hexo 的目录结构</span><br><span class="line"></span><br><span class="line">![](http://pcobk8jbf.bkt.clouddn.com/Fpjfqr-LghTX4LF8Ivk4U06WdRNo)</span><br><span class="line"></span><br><span class="line">### 4.2 全局配置文件_config.yml</span><br></pre></td></tr></table></figure></p><h1 id="Hexo-Configuration"><a href="#Hexo-Configuration" class="headerlink" title="Hexo Configuration"></a>Hexo Configuration</h1><h1 id="Docs-http-hexo-io-docs-configuration-html"><a href="#Docs-http-hexo-io-docs-configuration-html" class="headerlink" title="Docs: http://hexo.io/docs/configuration.html"></a>Docs: <a href="http://hexo.io/docs/configuration.html" target="_blank" rel="noopener">http://hexo.io/docs/configuration.html</a></h1><h1 id="Source-https-github-com-hexojs-hexo"><a href="#Source-https-github-com-hexojs-hexo" class="headerlink" title="Source: https://github.com/hexojs/hexo/"></a>Source: <a href="https://github.com/hexojs/hexo/" target="_blank" rel="noopener">https://github.com/hexojs/hexo/</a></h1><h1 id="Site-站点信息"><a href="#Site-站点信息" class="headerlink" title="Site #站点信息"></a>Site #站点信息</h1><p>title:  #标题<br>subtitle:  #副标题<br>description:  #站点描述，给搜索引擎看的<br>author:  #作者<br>email:  #电子邮箱<br>language: zh-CN #语言</p><h1 id="URL-链接格式"><a href="#URL-链接格式" class="headerlink" title="URL #链接格式"></a>URL #链接格式</h1><p>url:  #网址<br>root: / #根目录<br>permalink: :year/:month/:day/:title/ #文章的链接格式<br>tag_dir: tags #标签目录<br>archive_dir: archives #存档目录<br>category_dir: categories #分类目录<br>code_dir: downloads/code<br>permalink_defaults:</p><h1 id="Directory-目录"><a href="#Directory-目录" class="headerlink" title="Directory #目录"></a>Directory #目录</h1><p>source_dir: source #源文件目录<br>public_dir: public #生成的网页文件目录</p><h1 id="Writing-写作"><a href="#Writing-写作" class="headerlink" title="Writing #写作"></a>Writing #写作</h1><p>new_post_name: :title.md #新文章标题<br>default_layout: post #默认的模板，包括 post、page、photo、draft（文章、页面、照片、草稿）<br>titlecase: false #标题转换成大写<br>external_link: true #在新选项卡中打开连接<br>filename_case: 0<br>render_drafts: false<br>post_asset_folder: false<br>relative_link: false<br>highlight: #语法高亮<br>  enable: true #是否启用<br>  line_number: true #显示行号<br>  tab_replace:</p><h1 id="Category-amp-Tag-分类和标签"><a href="#Category-amp-Tag-分类和标签" class="headerlink" title="Category &amp; Tag #分类和标签"></a>Category &amp; Tag #分类和标签</h1><p>default_category: uncategorized #默认分类<br>category_map:<br>tag_map:</p><h1 id="Archives"><a href="#Archives" class="headerlink" title="Archives"></a>Archives</h1><p>2: 开启分页<br>1: 禁用分页<br>0: 全部禁用<br>archive: 2<br>category: 2<br>tag: 2</p><h1 id="Server-本地服务器"><a href="#Server-本地服务器" class="headerlink" title="Server #本地服务器"></a>Server #本地服务器</h1><p>port: 4000 #端口号<br>server_ip: localhost #IP 地址<br>logger: false<br>logger_format: dev</p><h1 id="Date-Time-format-日期时间格式"><a href="#Date-Time-format-日期时间格式" class="headerlink" title="Date / Time format #日期时间格式"></a>Date / Time format #日期时间格式</h1><p>date_format: YYYY-MM-DD #参考<a href="http://momentjs.com/docs/#/displaying/format/" target="_blank" rel="noopener">http://momentjs.com/docs/#/displaying/format/</a><br>time_format: H:mm:ss</p><h1 id="Pagination-分页"><a href="#Pagination-分页" class="headerlink" title="Pagination #分页"></a>Pagination #分页</h1><p>per_page: 10 #每页文章数，设置成 0 禁用分页<br>pagination_dir: page</p><h1 id="Disqus-Disqus评论，替换为多说"><a href="#Disqus-Disqus评论，替换为多说" class="headerlink" title="Disqus #Disqus评论，替换为多说"></a>Disqus #Disqus评论，替换为多说</h1><p>disqus_shortname:</p><h1 id="Extensions-拓展插件"><a href="#Extensions-拓展插件" class="headerlink" title="Extensions #拓展插件"></a>Extensions #拓展插件</h1><p>theme: landscape-plus #主题<br>exclude_generator:<br>plugins: #插件，例如生成 RSS 和站点地图的</p><ul><li>hexo-generator-feed</li><li>hexo-generator-sitemap<h1 id="Deployment-部署，将-lmintlcx-改成用户名"><a href="#Deployment-部署，将-lmintlcx-改成用户名" class="headerlink" title="Deployment #部署，将 lmintlcx 改成用户名"></a>Deployment #部署，将 lmintlcx 改成用户名</h1>deploy:<br>type: git<br>repo: <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:yourgithub/yourgithub.github.io.git<br>branch: master<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">编辑 **config.yml** 文件将 repo: git@github.com:yourgithub/yourgithub.github.io.git 替换为你刚建的 GitHub 仓库的地址。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">每一行配置文件的冒号 “:” 后面有一个空格！</span><br><span class="line">repo 的这种形式的是配置了SSH Key之后的，如果没有配置则使用 https 形式的地址。</span><br><span class="line"></span><br><span class="line">然后执行如下命令即可完成生成静态网页 &amp; 部署：</span><br></pre></td></tr></table></figure></li></ul><p>hexo generate<br>hexo deploy<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">提示：每次在执行上面两条命令之前先 hexo clean 一下，这样可以防止缓存的影响。</span><br><span class="line"></span><br><span class="line">如上命令可以简写，简写和全写命令对应如下：</span><br></pre></td></tr></table></figure></p><p>hexo n == hexo new<br>hexo g == hexo generate<br>hexo s == hexo server<br>hexo d == hexo deploy<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">问题：</span><br><span class="line"></span><br><span class="line">![](http://pcobk8jbf.bkt.clouddn.com/FiSI_f8EBlBMHZXLfeqVa0kTQvt8)</span><br><span class="line"></span><br><span class="line">安装 deployer:</span><br></pre></td></tr></table></figure></p><p>npm install hexo-deployer-git –save<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">再重新 hexo d，如果显示以下提示说明部署成功：</span><br></pre></td></tr></table></figure></p><p>[info] Deploy done: git<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">然后打开浏览器输入：yourgithub.github.io</span><br><span class="line"></span><br><span class="line">如果你看到了和刚才本地访问一样的网页，说明我们的博客已经成功的部署到了 GitHub 了。</span><br><span class="line"></span><br><span class="line">## 5.绑定域名</span><br><span class="line"></span><br><span class="line">博客搭建完，默认的域名只能是：yourgithub.github.io 而且是不能修改的，如果要想逼格更高点，想绑定自己的域名也是可以的。</span><br><span class="line"></span><br><span class="line">### 5.1 购买域名</span><br><span class="line"></span><br><span class="line">首先你需要购买一个域名，现在基本都是到万网或者腾讯等也可以购买域名，购买也比较简单，这里放出阿里万网购买地址：</span><br><span class="line"></span><br><span class="line">[https://wanwang.aliyun.com/](https://wanwang.aliyun.com/)</span><br><span class="line"></span><br><span class="line">### 5.2 配置DNS地址</span><br><span class="line"></span><br><span class="line">这里以万网为例，进入万网的管理控制台(阿里云手机 APP 也可以)进行修改，修改 DNS 为 DNSPod 的免费 DNS 地址：</span><br></pre></td></tr></table></figure></p><p>f1g1ns1.dnspod.net<br>f1g1ns2.dnspod.net<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 5.3 域名解析</span><br><span class="line"></span><br><span class="line">登录万网控制台或阿里云手机 APP 之后，把我们新注册的域名加进去，在域名解析列表中国添加 3 条解析记录：</span><br></pre></td></tr></table></figure></p><p>@         A         192.30.252.153<br>@         A         192.30.252.154<br>www      CNAME      yourname.github.io<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">其中A的两条记录指向的 ip 地址是 GitHub Pages 的提供的 ip，如何知道你的 GitHub 上项目的 ip？</span><br><span class="line"></span><br><span class="line">### 5.4 添加 CNAME 文件</span><br><span class="line"></span><br><span class="line">新建一个名为 CNAME 的文件，无后缀，内容为你的域名地址，将该文件放入本地博客的 source 文件夹里面，执行下面命令并更新到 Github。</span><br></pre></td></tr></table></figure></p><p>hexo clean<br>hexo g<br>hexo d<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">注意：域名的地址不需要添加协议头 **http://** ,直接写域名即可，例如：www.baidu.com</span><br><span class="line"></span><br><span class="line">然后在你的浏览器中输入你的域名，是不是和之前一样，如果一样，说明你的域名已经绑定成功了～</span><br><span class="line"></span><br><span class="line">搭建博客本身的难度不大，重要的是搭建博客这个过程，主要考验自己的动手能力和问题解决能力，过程中你可能会遇见各种各样的问题，然后你会一个个的解决掉这些问题，这本身就是学习的过程，希望大家也能多多动手，希望大家搭建成功～</span><br><span class="line"></span><br><span class="line">最后晒上我的博客地址：</span><br><span class="line"></span><br><span class="line">[http://www.x-sir.com](http://www.x-sir.com)</span><br><span class="line"></span><br><span class="line">## 6.Hexo 博客主题美化</span><br><span class="line"></span><br><span class="line">### 6.1 clone 主题</span><br><span class="line"></span><br><span class="line">Hexo官网：</span><br><span class="line"></span><br><span class="line">[https://hexo.io/themes](https://hexo.io/themes)</span><br><span class="line"></span><br><span class="line">里面有特别多的主题可以选择，我在这里选的是 next这个主题，下载主题：</span><br></pre></td></tr></table></figure></p><p>cd themes<br>git clone <a href="https://github.com/Fechin/hexo-theme-diaspora.git" target="_blank" rel="noopener">https://github.com/Fechin/hexo-theme-diaspora.git</a> diaspora<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 6.2 启用主题</span><br><span class="line"></span><br><span class="line">修改Hexo配置文件 _config.yml 主题项设置为diaspora</span><br></pre></td></tr></table></figure></p><p>…<br>theme: diaspora<br>…<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 6.3 更新主题</span><br><span class="line"></span><br><span class="line">注意：请在更时主题时备份_config.yml配置文件</span><br></pre></td></tr></table></figure></p><p>cd themes/diaspora<br>git pull<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 6.4 发布新主题</span><br><span class="line"></span><br><span class="line">执行如下命令然后浏览器中输入博客地址查看：</span><br></pre></td></tr></table></figure></p><p>hexo clean<br>hexo g<br>hexo d<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">注意：更换新的主题，可能会有一些延迟！</span><br><span class="line"></span><br><span class="line">## 7.Hexo 博客细节配置</span><br><span class="line"></span><br><span class="line">需要修改的内容可以参考网站：</span><br><span class="line"></span><br><span class="line">[https://hexo.io/zh-cn/docs/configuration](https://hexo.io/zh-cn/docs/configuration)</span><br><span class="line"></span><br><span class="line">里面对各个参数有一些详细的解释，我这里修改一些博客的标题，副标题，描述，语言等，建议大家修改一项，重新部署网站一下，因为一旦出错，这样就比较容易找到原因。</span><br><span class="line"></span><br><span class="line">## 8.安装插件</span><br></pre></td></tr></table></figure></p><p>安装插件：npm install 插件名 –save<br>卸载插件：npm uninstall 插件名<br>更新插件和博客框架：npm update<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">执行以下命令安装 RSS 插件:</span><br></pre></td></tr></table></figure></p><p>npm install hexo-generator-feed –save<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">生成站点地图:</span><br></pre></td></tr></table></figure></p><p>npm install hexo-generator-sitemap –save<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">生成百度站点地图:</span><br></pre></td></tr></table></figure></p><p>npm install hexo-generator-baidu-sitemap –save<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SEO 优化:</span><br></pre></td></tr></table></figure></p><p>npm install hexo-generator-seo-friendly-sitemap –save<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">HTML 压缩:</span><br></pre></td></tr></table></figure></p><p>npm install hexo-html-minifier –save<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">CSS 压缩:</span><br></pre></td></tr></table></figure></p><p>npm install hexo-clean-css –save<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">JS 压缩:</span><br></pre></td></tr></table></figure></p><p>npm install hexo-uglify –save<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">imagages 压缩:</span><br></pre></td></tr></table></figure></p><p>npm install hexo-imagemin –save<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">插件开启配置</span><br><span class="line"></span><br><span class="line">根目录下的 `_config.yml`，添加以下代码:</span><br></pre></td></tr></table></figure></p><h1 id="RSS"><a href="#RSS" class="headerlink" title="RSS"></a>RSS</h1><p>feed:<br>type: atom<br>path: atom.xml<br>limit: 20</p><h1 id="sitemap"><a href="#sitemap" class="headerlink" title="sitemap"></a>sitemap</h1><h1 id="提交给谷歌搜素引擎，SEO优化开启配置是一样的"><a href="#提交给谷歌搜素引擎，SEO优化开启配置是一样的" class="headerlink" title="提交给谷歌搜素引擎，SEO优化开启配置是一样的"></a>提交给谷歌搜素引擎，SEO优化开启配置是一样的</h1><p>sitemap:<br>    path: sitemap.xml</p><h1 id="提交百度搜索引擎"><a href="#提交百度搜索引擎" class="headerlink" title="提交百度搜索引擎"></a>提交百度搜索引擎</h1><p>baidusitemap:<br>    path: baidusitemap.xml </p><h1 id="HTML压缩"><a href="#HTML压缩" class="headerlink" title="HTML压缩"></a>HTML压缩</h1><p>html_minifier:<br>  exclude:     </p><h1 id="css压缩"><a href="#css压缩" class="headerlink" title="css压缩"></a>css压缩</h1><p>clean_css:<br>  exclude: </p><pre><code>- &apos;*.min.css&apos;</code></pre><h1 id="js压缩"><a href="#js压缩" class="headerlink" title="js压缩"></a>js压缩</h1><p>uglify:<br>  mangle: true<br>  output:<br>  compress:<br>  exclude: </p><pre><code>- &apos;*.min.js&apos;</code></pre><h1 id="image压缩"><a href="#image压缩" class="headerlink" title="image压缩"></a>image压缩</h1><p>imagemin:<br>  enable     : true<br>  interlaced : false<br>  multipass  : false<br>  optimizationLevel: 2<br>  pngquant   : false<br>  progressive: false<br><code>`</code></p><p>注意：目前设置 HTML 压缩有报错！<br>图片压缩会导致图片破损！<br>package.json 文件中可以看安装了哪些插件。</p><h2 id="9-安装-gitalk-评论插件"><a href="#9-安装-gitalk-评论插件" class="headerlink" title="9.安装 gitalk 评论插件"></a>9.安装 gitalk 评论插件</h2><p>参考下面的博客即可，写的比较详细：</p><p><a href="https://segmentfault.com/a/1190000014085547" target="_blank" rel="noopener">https://segmentfault.com/a/1190000014085547</a></p><p>如果安装过程中，出现问题请先戳gitalk issue 区看看有没有解决方案：</p><p><a href="https://github.com/gitalk/gitalk/issues" target="_blank" rel="noopener">https://github.com/gitalk/gitalk/issues</a></p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://hexo.io/docs/" target="_blank" rel="noopener">https://hexo.io/docs/</a></li><li><a href="http://wuxiaolong.me/2015/07/31/build-blog-by-hexo/" target="_blank" rel="noopener">http://wuxiaolong.me/2015/07/31/build-blog-by-hexo/</a></li><li><a href="https://www.jianshu.com/p/e5f95eb990ad" target="_blank" rel="noopener">https://www.jianshu.com/p/e5f95eb990ad</a></li><li><a href="https://github.com/Fechin/hexo-theme-diaspora" target="_blank" rel="noopener">https://github.com/Fechin/hexo-theme-diaspora</a></li><li><a href="https://www.jianshu.com/p/77db3862595c" target="_blank" rel="noopener">https://www.jianshu.com/p/77db3862595c</a></li><li><a href="https://www.jianshu.com/p/86557c34b671" target="_blank" rel="noopener">https://www.jianshu.com/p/86557c34b671</a></li><li><a href="https://github.com/gitalk/gitalk" target="_blank" rel="noopener">https://github.com/gitalk/gitalk</a></li><li><a href="https://www.jianshu.com/p/9be29ed2f4b7" target="_blank" rel="noopener">https://www.jianshu.com/p/9be29ed2f4b7</a></li><li><a href="https://imsun.net/posts/gitment-introduction/#more" target="_blank" rel="noopener">https://imsun.net/posts/gitment-introduction/#more</a></li><li><a href="https://calpa.me/2018/03/10/gitalk-error-validation-failed-442-solution" target="_blank" rel="noopener">https://calpa.me/2018/03/10/gitalk-error-validation-failed-442-solution</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-环境安装&quot;&gt;&lt;a href=&quot;#1-环境安装&quot; class=&quot;headerlink&quot; title=&quot;1.环境安装&quot;&gt;&lt;/a&gt;1.环境安装&lt;/h2&gt;&lt;h3 id=&quot;1-1-Git&quot;&gt;&lt;a href=&quot;#1-1-Git&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="Android" scheme="http://www.x-sir.com/categories/Android/"/>
    
    
      <category term="iTunes" scheme="http://www.x-sir.com/tags/iTunes/"/>
    
      <category term="Windows" scheme="http://www.x-sir.com/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>技术人如何提升自己（推荐必读）</title>
    <link href="http://www.x-sir.com/2018/09/24/%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87%E8%87%AA%E5%B7%B1%EF%BC%88%E6%8E%A8%E8%8D%90%E5%BF%85%E8%AF%BB%EF%BC%89/"/>
    <id>http://www.x-sir.com/2018/09/24/技术人如何提升自己（推荐必读）/</id>
    <published>2018-09-24T15:47:57.000Z</published>
    <updated>2018-12-08T15:04:07.935Z</updated>
    
    <content type="html"><![CDATA[<center>点击关注<span style="color:#0000ff;">“IT大飞说”</span>，置顶或星标公众号</center><br><center>订阅公众号（<strong>ID：ITBigFly</strong>）第一时间收到推送</center><p><img src="http://pcobk8jbf.bkt.clouddn.com/FlN7rYqRCcxStKbnJhYl-MSOaW80" alt=""></p><blockquote><p>作为一个技术人，我们不仅要不断地学习来提升自己不被淘汰，另外也要不断总结自己的经验和教训，踩过的坑、走过的弯路要善于去思考如何避免下次再踩坑？我们也不要一直局限于自己的技术世界一心只敲代码，两耳不闻窗外事，这样未免就有点太局限了，也不利于自己的发展。我们经历着互联网飞速发展的时代，从最初的 PC 时代，到移动互联网，然后到近几年的大数据、人工智能、区块链等技术，技术迭代的速度比以前更加快速了，这也意味着新的技术也会慢慢的代替掉一些旧的技术，因此你也要跟随着时代的变化，不断更新自己的技术栈，去适应新的技术环境，提升自己的核心竞争力！一些新兴技术行业的兴盛必然会导致另一些技术的衰落，衰落这个词用的不是太恰当，举个例子，例如 12、13 年很火的移动开发到这几年逐渐的也没那么火了，其实经过这几年的发展，开发的门槛越来越低，对技术人才的需求也日渐趋于饱和了，但是初级工程师还是占很大一部分，高级工程师还是比较少，所以中间出现了断层的现象，如果你是初级者，怎样更快速地去提升自己，实现向高级的跨越？这应该是你需要思考的问题。如果是中高级开发者，也应该有一些危机感，这样才能时刻提醒自己去不断的学习，不断地去改变和适应技术的发展，跟随技术的潮流不断前进，以至于才不会被淘汰！另外，也不要一直守着自己的一亩三分地，要适当的多学习一些其他方面的技术，培养自己的第二技术能力，前提是首先得干好自己的本职工作，利用闲余时间去学习一些其他技术，技术之间也是相通的，如果你对某一个方面研究比较透彻的话，学习其他方面的技术也是很容易能够上手的。之前看过美国那些 FLAG 公司，他们一般招聘都不会去明确的注明招聘的岗位，一般面试主要都是让你做算法题，他们认为你把算法这么难的东西都搞会了，不管干其他什么岗位工作都是没有问题的。另外在工作的同时也要注重提升自己的技术影响力，我觉得这个也是比较重要的一方面，好处是不仅可以帮你之后找工作、升职、加薪和赚钱都是有帮助的，那么该如何提升自己呢？</p></blockquote><h2 id="1-坚持写作"><a href="#1-坚持写作" class="headerlink" title="1.坚持写作"></a>1.坚持写作</h2><p>我认为，写作对于一个技术人来说太重要了，一方面不仅可以提高自己的写作水平，另一方面也可以锻炼自己的语言组织和表达能力，巩固知识点，加深理解和记忆。写作有形式可以是写博客和公众号，还有像知乎这种其他平台。特别说一下写博客，现在的博客平台有很多，比较有名的有 CSDN、简书、掘金等平台，基本都可以使用可视化的 MarkDown 编辑器来写，用 MarkDown 的好处是语法简单，显示效果很简洁，不需要去特别排版，这样写作的效率就提高了；作为技术文章，我强烈建议大家原创，只有这样才能将自己的学到的知识总结并且转化为自己的输出，更重要的是在写作的过程中会让你有更加深刻的理解，有时候虽然你学会了某个新技术，但是你不一定能写的出来，可以这么说，学会了是一个境界，理解了又是一个境界，理解了并写出来又是另一个境界，写出来并且让别人能看懂又是一种更高的境界！建议大家在技术的道路上切勿眼高手低，实践是检验真理的唯一标准！实践出真知！写作要多站到读者的角度去思考怎么写？怎么写才能让读者更容易的理解？怎样写才能适合不同技术水平层次的人理解？多思考几个为什么，不骄不躁，慢慢地一步一个脚印，写的时间长了也就得心应手了，如果你能一直坚持下去，越往后写你会发现你会喜欢上写作的，一天不写你就会觉得手痒痒，习惯一旦养成了，就自然而然的去执行了，即习惯成自然。随着你坚持写作的时间越来越长，你的读者和文章的阅读量也会越来越多，可能还有读者给你留言与你交流，这时候你需要和读者一起互动或者耐心的帮助他们解答问题，这样可以增加读者对你的好感度，容易积攒自己的口碑，口碑上去了影响力自然就有了，容易提升个人品牌的知名度！知名度上去了就会产生品牌效应。当然，要想达到这种程度，非常的难，好多人坚持到一半就坚持不下去了，如果你能一直坚持下去你就成功了一半，你看好多公号大V，大多都是吭哧吭哧坚持写了好几年，最好才成大V的。不必羡慕别人，你需要做的是静下心，坚持下去，在对的时间做对的事，剩下的就交给时间，相信功夫不负有心人，你要的岁月都会给你！</p><h2 id="2-热爱开源"><a href="#2-热爱开源" class="headerlink" title="2.热爱开源"></a>2.热爱开源</h2><p>作为全世界最大的同 xing 交(开)友(源)社区GitHub，被大家戏称为 GayHub，我想作为一个程序员应该都不陌生吧，说实在的，开源社区真的是我们程序员的福利之地啊，好多大厂包括 Google、FaceBook、Square、Apache、阿里、腾讯等都开源了好多优秀的框架，大大提升了程序员开发效率，也降低了开发的成本。我是在 14 年的时候就申请了 GitHub 账号，刚开始只是在上面找一些东西，也不怎么会用，也不会开源项目，直到 16 年的时候看了一些 GitHub 的教程，逐渐的发现了它的好，它的强大之处，然后开始为开源世界做贡献，从此一发不可收拾，慢慢的就喜欢上 GitHub 了…什么？卧槽！你特么 qinshou 啊，连 GitHub 都不放过! 汗====囧 emmmmmmmmmmm~ 我竟无言以对，感觉自己有点方啊！好了，言归正传，继续说我们的 GitHub，GitHub 汇集了全世界好多的优秀开源项目和一大批的优秀开发者，从此学习交流不分国界，不仅可以和全世界各地的开发者一起沟通交流，fork 优秀的开源项目来进行学习，另外可以 PR 和提 issue，一起为开源世界做贡献，时间长了，你会发现这是一件很有成就感的事情。当你看到自己提交的历史，特别有成就感！</p><p>下面是我的 commit map.</p><p><img src="http://pcobk8jbf.bkt.clouddn.com/FqgLWwe7EtwvYq_LqVAL3R0Uhq9q" alt=""></p><p>我虽然也不是每天都 commit，但不定期零零散散都会坚持去 commit，在使用 GitHub 的这几年，我也收到了好几份的面试邀请邮件，其中包括几个大厂，有 Amazon、阿里等，这个好像也是根据 GitHub 排名和贡献来发招聘邀请邮件的，虽说这种招人的方式有一定的局限，但是我觉得最起码可以体现出，你一定是一个热爱开源，热于分享的程序员，没毛病！</p><p><img src="http://pcobk8jbf.bkt.clouddn.com/FoiqSg-OIVmO8sVL7LY1CIZa8Jg5" alt=""></p><p>下面是我收到的邮件：<br><img src="http://pcobk8jbf.bkt.clouddn.com/FozVZjrf495JcLfX4BUcM6XSUAQF" alt=""></p><p><img src="http://pcobk8jbf.bkt.clouddn.com/FqQ7EmzqVhd5iqhpoyYiWArN8MsP" alt=""></p><h2 id="3-多向大牛学习"><a href="#3-多向大牛学习" class="headerlink" title="3.多向大牛学习"></a>3.多向大牛学习</h2><p>大牛之所以是大牛，肯定是在某一方很厉害，有值得你去学习的地方，跟着大牛的脚步可以让你事半功倍，不仅可以借鉴一下大牛们的成功经验，也可以让我们少走弯路，这里的少走弯路的意思是避免让你走错方向，把时间浪费在不必要的地方，当然学习过程中遇到的坎和坑，该经历的还是要经历的，遇到的坑多了以后你就都能应对自如了，这就是经验吧！只有自己亲身体会了、总结了才能转化为自己的经验。多与大牛接触和交流，学习大牛解决问题的方式，然后结合自身去不断实践，取长补短，不断总结并完善自己！那么怎样向大牛学习呢？大牛们一般都有自己的公号，博客或者技术圈子，你可以关注大牛的公号或博客来学习，另外，这两年知识付费也火热起来，像知识星球、极客时间等一些有代表性的平台更是火热，一些大牛也有自己的知识星球或者是付费专栏，你可以选择几个适合自己的然后加入圈子学习，这样就可以更近距离的与大牛交流和学习了。知识付费还有一个作用就是对信息的筛选，说实在的，我们都处在信息爆炸的时代，每天都会接受到各种各样的信息，当然也包括各种垃圾信息，很容易让人眼花缭乱，知识的内容也鱼龙混杂，质量也参差不齐，而知识付费的好处就是别人帮你把知识已经筛选好了，而且质量也比较有保证，接下来你只要安心的学习就好了！而有的人就是喜欢免费的，之前听有人说：“现在学习还要花钱啊，网上一找一大堆！” 是，没错！现在网上最不缺的就是免费的学习资源了，这么多资源，你知道课程的质量怎么样么？你如何才能筛选出最好的资源？这些资源都是你需要花时间和精力去做的事情，而且找到的并不一定好，而大牛们用他们多年来的经验然后总结出来的东西，你只需要花几十块或者上百块买来去学习，何乐而不为呢？这样大佬们也乐于分享，你也得到了一个学习的圈子，加入圈子的人都和你一样，都是为了学习才加入的，相当于是给你们营造了一个学习的氛围，物以类聚，人以群分，和学习的人在一起，你学习的动力也有了，学习也就更快了，这样你自己的时间成本也会省下来，相当于是用钱买时间，有的人就是算不清这个账，愿意花上百块的钱去玩，也不愿意花钱去投资自己的学习，那么我只能说你的目光太短浅了，我希望大家不要只看到眼前的利益，目光放长远一些，多提高一些自己的认知能力，建议大家能用钱解决问题的一定要用钱去解决！</p><p>好了，今天的分享就到这里，如果我的文章对你有帮助、有启发，请帮我点个赞，谢谢！另外也欢迎大家在下方评论留言与我交流。</p><p><strong>猜你喜欢：</strong><br><a href="https://mp.weixin.qq.com/s/ReJJFmQm6l55r9pvo7aFIA" target="_blank" rel="noopener">给大家推荐一个神器</a><br><a href="https://mp.weixin.qq.com/s/hVhhDdr3Bo4qLIdOkHsM_Q" target="_blank" rel="noopener">Android 最全 Intent 传递数据姿势</a> </p><p><img src="http://pcobk8jbf.bkt.clouddn.com/FijAsROsRHuwVUivQ8M9D5o3RSdP" alt=""></p><center><span style="color:#bdbdbd;">欢迎扫码关注我的公众号</span></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;点击关注&lt;span style=&quot;color:#0000ff;&quot;&gt;“IT大飞说”&lt;/span&gt;，置顶或星标公众号&lt;/center&gt;&lt;br&gt;&lt;center&gt;订阅公众号（&lt;strong&gt;ID：ITBigFly&lt;/strong&gt;）第一时间收到推送&lt;/center&gt;

&lt;
      
    
    </summary>
    
      <category term="阅读" scheme="http://www.x-sir.com/categories/%E9%98%85%E8%AF%BB/"/>
    
    
      <category term="GitHub" scheme="http://www.x-sir.com/tags/GitHub/"/>
    
      <category term="技术提升" scheme="http://www.x-sir.com/tags/%E6%8A%80%E6%9C%AF%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>825 安卓巴士精华总结</title>
    <link href="http://www.x-sir.com/2018/08/24/825%20%E5%AE%89%E5%8D%93%E5%B7%B4%E5%A3%AB%E7%B2%BE%E5%8D%8E%E6%80%BB%E7%BB%93/"/>
    <id>http://www.x-sir.com/2018/08/24/825 安卓巴士精华总结/</id>
    <published>2018-08-24T15:47:57.000Z</published>
    <updated>2018-12-08T14:26:59.113Z</updated>
    
    <content type="html"><![CDATA[<p>一年一度的安卓巴士开发者大会在上海隆重举行，有幸亲临参加了本次大会，本篇文章仅对本次大会的个人感受和各位技术大佬的分享以及未来的技术趋势与大家分享。</p><p>本次大会的主要内容有：技术大咖的个人主题分享，互动抽奖环节，圆桌会议，下午茶休息（提供各种水果和小吃甜点等），抽奖的奖品也比较丰厚，有技术图书，贴纸，抱枕，T恤，GDD 大会门票，各种小玩具等，奖品也比较丰厚。</p><h2 id="上午场"><a href="#上午场" class="headerlink" title="上午场"></a>上午场</h2><p>上午第一位分享的嘉宾是 openinstall 的联合创始人徐兴，分享的是 openinstall 的 App  免邀请码安装及 App 安装来源的数据统计等技术功能，对于App的推广和数据统计来说是一把利器，相比传统的邀请码安装方式更简单、更容易，想了解更多请到官网进行详细了解，这里就不赘述了。</p><p>上午第二位分享的嘉宾是饿了么大佬王雨威（江湖人称：巴掌），主要分享了一个饿了么的来源库：UETool ，简单说，它是一个让程序员，设计师，测试可以动态调试 View 各种属性的工具，功能很强大，大大提高了开发的效率，更多介绍请戳 GitHub：</p><p><a href="https://github.com/eleme/UETool" target="_blank" rel="noopener">https://github.com/eleme/UETool</a> </p><p>上午第三位分享的嘉宾是手机淘宝无线技术专家费义云，主要是先从计算机图形学引申到手机上的图形开发处理技术，从 GPU 底层的到上层应用进行详细的讲解，理论性和专业性都比较强，另外还有3D、AR、VR、OpenGL ES 等方面都做了细致的介绍，最后他还提出技术人提升的三层模型的观点，为技术人指明了方向，值得技术人思考。</p><h2 id="下午场"><a href="#下午场" class="headerlink" title="下午场"></a>下午场</h2><p>下午第一位分享的嘉宾是张涛，大家可能都知道他的张涛实验室，分享的主题是《Android 十年，还有哪些可以做的》，主要从 Android 的过去到现在的发展，以及Android 技术演变的历程为主线，以几个大厂商 App 为例，回顾了 Android 的技术演变和 App 架构演变历程，中间贯穿了各种技术知识，分享很棒，回顾过去，展望未来，对于 Android 未来技术的发展趋势也指明了方向。</p><p>下午第二位分享的嘉宾是美图高级安卓开发工程师邱炬，分享的主题是《全面解析Android 线程》，由浅入深，从上层到底层的线程创建，让我们更清楚的了解了线程的本质，还对线程的优先级进行详细的介绍，另外还对线程池及多线程开发的注意事项进行详细的讲解，还对线程的性能及安全性问题做了很细致的分享，这些问题都是实际开发中经常遇到的问题，真的是收益匪浅！</p><p>下午第三位分享的嘉宾是我们的刘哥，也就是《Android进阶之光》的作者刘望舒，分享的主题是《Android应用开发如何更高效的阅读系统源码》，主要从：为何要阅读系统源码？如何阅读系统源码？系统源码的知识体系等几个问题来给大家分享了阅读系统源码的重要性和好处，这样以便于我们更好的理解 Android，理解 Android 系统，方便我们写出更高质量的代码，也可以解决一些难以解决的问题，最后还给大家推荐了一些优秀的博客作者和工具，干货满满，刘哥的演讲有激情、有速度！期待刘哥的新书《Android进阶解密》。</p><p>下午第三个进行分享的是：四位嘉宾的圆桌会议，四位嘉宾分别是：纪元（大数据嘉宾）MobData运营VP，费义云（机器学习嘉宾）手机淘宝无线技术专家，任义（区块链嘉宾）米客思科技公司董事长，章国良（人工智能嘉宾）AIhub 人工智能助推器CEO，四位大咖从各自不同的技术领域分享了如何用技术解决现实的问题，以及未来技术的发展趋势，开阔了我们的眼界，同时让我们对未来进行思考，我们不要仅仅停留在自己的一亩三分地，更应该去提升自己的技术栈和眼界，不断提高自身的能力，勇于创新，这样才能弯道超车！</p><p>下午第四位分享的嘉宾是前爱奇艺多媒体开发何俊林，也就是我们的鱼哥，分享的主题是《Android音视频知识分享》，主要从多媒体基础概念，Android平台播放器，常见音视频开发中的问题总结，播放案例介绍等几个方面详细介绍了音视频的相关知识，讲的很详细很系统。这两年音视频也算是比较火的一个方向，对于音视频开发者来说，真的是干货很足！</p><p>下午第五位分享的嘉宾是扔物线朱凯，也是最后一位分享嘉宾，分享的主题是《从图片上传说起：我们究竟需要怎样的Android工程师》，主要从图片上传怎么做？BASE64 更安全和稳定？怎么给服务器提交信息？Retrofit 比 OkHttp 好用？等几个问题，由浅入深地进行讲解，简单明了，作为技术人应该知其然，也要知其所以然。最后还为我们的安卓工程师指明了方向，分析了特殊时代的困境和机遇，如何迈向「高级」工程师，我想每个人自己的心里都有一个答案。</p><p>总体来说，本次大会真的是收益匪浅，不仅可以和大佬们面对面分享，另外还可以认识一些同行的朋友，建议大家以后有机会多参加一些这样的活动。本文只对本次大会做简单的总结，如果想查看本次大会的视频，照片，PPT可关注“安卓巴士Android开发者门户”公众号，回复关键字：「825资料」、「825视频」、「825照片」即可获取。</p><p>声明一下，本文没有任何商业推广等利益关系，纯粹是为了给大家分享技术来进行学习交流！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一年一度的安卓巴士开发者大会在上海隆重举行，有幸亲临参加了本次大会，本篇文章仅对本次大会的个人感受和各位技术大佬的分享以及未来的技术趋势与大家分享。&lt;/p&gt;
&lt;p&gt;本次大会的主要内容有：技术大咖的个人主题分享，互动抽奖环节，圆桌会议，下午茶休息（提供各种水果和小吃甜点等），
      
    
    </summary>
    
      <category term="Android" scheme="http://www.x-sir.com/categories/Android/"/>
    
    
      <category term="GitHub" scheme="http://www.x-sir.com/tags/GitHub/"/>
    
      <category term="openinstall" scheme="http://www.x-sir.com/tags/openinstall/"/>
    
      <category term="UETool" scheme="http://www.x-sir.com/tags/UETool/"/>
    
  </entry>
  
  <entry>
    <title>给大家推荐一个神器</title>
    <link href="http://www.x-sir.com/2018/08/24/%E7%BB%99%E5%A4%A7%E5%AE%B6%E6%8E%A8%E8%8D%90%E4%B8%80%E4%B8%AA%E7%A5%9E%E5%99%A8/"/>
    <id>http://www.x-sir.com/2018/08/24/给大家推荐一个神器/</id>
    <published>2018-08-24T15:47:57.000Z</published>
    <updated>2018-12-08T14:31:08.727Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>今天不扯淡，给你们来点干的，推荐给你们一个神器…<br>这个神器是什么呢？</p></blockquote><p>现如今，对于广大 IT 从业人员来说，很重要的三项技能是编程、英语和写作，编程不用说了，我们就靠这个吃饭的；英语对大多数的人来说，可能比较差，也算是比较头疼的，对于编程人员来说，对英语门槛的要求还算比较低的，因为写代码基本都是一些常用的编程语法词汇，另外对于英文的技术文档的阅读也还好，其实也就那么多的词汇，基本都是一些专业词汇，英文技术文档看多了，基本也没太多的生词，偶尔遇到不会的生词，用翻译软件查一下也特别的方便，但是我认为这只达到了编程所具备的基本英语水平，不算是真正的会英语，语言就是用来交流的，如果你能流畅的用英语交流才算是自己的一项技能，真正的会英语。对于大多数中国人来说，从小学到现在，学了差不多十几年，但是学的都是哑巴英语，老师大多发音也不标准，然后为了考试学习一堆的语法知识，全都是为了考试，根本没法用来交流，所以你英语没学好也不全是自己的原因。我自认为我自己的英语水平还可以，不算很厉害，但是在同龄人中应该算是比较偏上吧，一方面是有兴趣、喜欢学，另一方面自己也总结了一些学习英语方面的方法和技巧，回头有时间给大家整理一篇关于英语学习方面的文章，今天这里就不展开赘述了；另外一个技能就是写作了，对于大多数程序员来说，写作也算是比较困难的，尤其是刚开始写作，想半天写不出来一句话，说实话我自己也是，万事开头难，但是我相信只要坚持写作，坚持阅读，慢慢地一点一点，然后再写作过程中不断的总结，相信写多了你的写作水平会提高的，进步总有一个过程，写作这个技能还是要慢慢要磨出来的，不要寻求什么捷径，一夜变成大文豪，那是不可能的！回头有时间给大家整理一篇关于如何写作方面的文章。</p><p>如果说一篇文章内容很好，但是排版很差你会看吗？我想我是没有看下去的欲望，先抛开内容不说，排版可以说是一篇文章的脸面，第一印象不好，读者也就没有看下去的欲望了，所以一篇文章的第一印象是非常重要的。一篇好的文章排版肯定是经过精心设计的，包括文字的字体大小、颜色，字间距、行间距等等，另外还有文章的配图，颜色的搭配，文章段落的划分，文章的两端缩进等，总之一句话，好的排版会让你感觉看着很舒服，阅读起来也不会累。我刚开始写作的时候也遇到了排版的问题，不管怎么排，还是感觉怪怪的，没有达到自己想要的那种效果，我平时也比较喜欢写博客，现在好多博客平台大都支持 MarkDown 语法，你用 MarkDown 写完之后直接导入就行了，也不用过多的修改效果也很好，简单、清晰！但是还有一些平台是不支持 MarkDown 的，所以排版就是一个问题了，后来发现微信公众号有一个第三方的插件叫壹伴助手，试用过一段时间，不过他是收费的，后来我又发现了一个免费排版神器，也就是我现在一直用的，用了这么长时间感觉用的很爽，也很方便，所以我就推荐给大家，它叫 「Md2All」，是一个在线 MarkDown 排版神器，浏览器访问地址为：<a href="http://md.aclickall.com" target="_blank" rel="noopener">http://md.aclickall.com</a> 可能一些读者已经用过了，用过的就不用往下看了，下面我就做一个简单的介绍和使用。</p><p>说一下我觉得比较好的地方：</p><ul><li>支持一键排版；</li><li>支持几十种代码主题；</li><li>支持代码显示行数及代码紧凑；</li><li>支持导出带样式的 html;</li><li>支持上传到七牛云图床；</li><li>…</li></ul><p>更多功能介绍及使用，请访问：<a href="http://md.aclickall.com" target="_blank" rel="noopener">http://md.aclickall.com</a> 查看，或者关注作者的微信公众号：颜家大少。</p><p>编辑面截图如下：</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/Fibvp8KrdOR0LafZfeJlE4V8nYF4H1zFicosPAa478L0EfHELAHJflGrcE4XaAQAfqRJqp1lobtV20JL0gJrYz3w/0?wx_fmt=png" alt="image"></p><p>左边是 MarkDown 编辑区，右边是预览，界面很清晰、简洁！基本上，我每次排版的步骤是：</p><ol><li>先用本地的 Markdown 编辑器写文章；</li><li>然后复制到 Md2All 的 MarkDown 编辑区；</li><li>设置文章的主题及边距、字体颜色大小等参数；</li><li>点击一键排版(自动会给你排好版);</li><li>点击复制，然后粘贴到微信公众号或者 CSDN、cnblog 的 html 编辑器中就可以发布文章了；</li></ol><p><img src="https://mmbiz.qpic.cn/mmbiz_png/Fibvp8KrdOR0LafZfeJlE4V8nYF4H1zFic9vSSvCsT7h5vPaXf7lWagbNYfl3HNqVn8zMuzp8q1DmLnEFTZGYH0w/0?wx_fmt=png" alt="image"></p><p>根据我以往的经验，如果是发布到 CSDN 或 cnblog，直接发布即可，如果是发布到微信公众号，你可以先推送到手机上预览一下，一般情况下做一些微调就可以了，例如字间距、行间距、两端缩进等，你可以参考本篇文章的排版效果。</p><p>好了，今天的推荐就到这里，声明一下，本篇文章没有任何利益及商业互推关系，纯粹是发自内心的觉得这个工具好用，所以就推荐给大家，好东西是要分享出来的，这样才有意义！</p><p>大家好，才是真的好！</p><p>喜欢我的话，就关注一下呗！</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/Fibvp8KrdOR3R9eSia2xaQhTua1DicaGhWVpFxsQZJicvmlHnic1mBxqNDw7HeBu0aIUHD3Fcd9r5E1EElaGO4Z38lA/0?wx_fmt=jpeg" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;今天不扯淡，给你们来点干的，推荐给你们一个神器…&lt;br&gt;这个神器是什么呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现如今，对于广大 IT 从业人员来说，很重要的三项技能是编程、英语和写作，编程不用说了，我们就靠这个吃饭的；英语对大多数的人来说，
      
    
    </summary>
    
      <category term="工具" scheme="http://www.x-sir.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="写作" scheme="http://www.x-sir.com/tags/%E5%86%99%E4%BD%9C/"/>
    
      <category term="MarkDown" scheme="http://www.x-sir.com/tags/MarkDown/"/>
    
  </entry>
  
</feed>
