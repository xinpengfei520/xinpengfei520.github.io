<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>程序员飞飞</title>
  
  <subtitle>码农，产品思维实践者，终身学习者，微信公众号：「程序员飞飞」。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.vance.xin/"/>
  <updated>2024-05-12T05:02:43.596Z</updated>
  <id>https://www.vance.xin/</id>
  
  <author>
    <name>程序员飞飞</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Xcode常用快捷键</title>
    <link href="https://www.vance.xin/2022/10/19/Xcode%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>https://www.vance.xin/2022/10/19/Xcode常用快捷键/</id>
    <published>2022-10-19T22:02:52.000Z</published>
    <updated>2024-05-12T05:02:43.596Z</updated>
    
    <content type="html"><![CDATA[<p>打开默认快捷键设置：<strong>preferences</strong> 里找到 <strong>Key Bindings</strong></p><h3 id="1、格式化代码"><a href="#1、格式化代码" class="headerlink" title="1、格式化代码"></a>1、格式化代码</h3><p>选中要格式化的代码，<code>ctrl + i</code></p><h3 id="2、关闭-tab-窗口"><a href="#2、关闭-tab-窗口" class="headerlink" title="2、关闭 tab 窗口"></a>2、关闭 tab 窗口</h3><p>cmd + w</p><h3 id="3、快速搜索"><a href="#3、快速搜索" class="headerlink" title="3、快速搜索"></a>3、快速搜索</h3><p><code>Shift + Command + O</code> 來快速打開，並按下 <strong>Option</strong> 鍵來選取檔案</p><h3 id="4、清理工程"><a href="#4、清理工程" class="headerlink" title="4、清理工程"></a>4、清理工程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* Clean: ⌘ + ⇧ + K</span><br><span class="line">* Clean the build folder: ⌘ + ⇧ + ⌥ + K</span><br></pre></td></tr></table></figure><h3 id="5、排序語句"><a href="#5、排序語句" class="headerlink" title="5、排序語句"></a>5、排序語句</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">⌘ + ⌥ + ] or [</span><br></pre></td></tr></table></figure><h3 id="6、全局搜索："><a href="#6、全局搜索：" class="headerlink" title="6、全局搜索："></a>6、全局搜索：</h3><p>Shift + Command + F</p><h3 id="7、minimap-視圖"><a href="#7、minimap-視圖" class="headerlink" title="7、minimap 視圖"></a>7、minimap 視圖</h3><p>Shift + Control + Command + M</p><h3 id="8、当前文件栈-前进｜后退"><a href="#8、当前文件栈-前进｜后退" class="headerlink" title="8、当前文件栈 前进｜后退"></a>8、当前文件栈 前进｜后退</h3><p>command + ctrl + ➡️ ｜ ⬅️</p><h3 id="9、Xcode-使用-TODO、FIXME、-、-、MARK标记用法"><a href="#9、Xcode-使用-TODO、FIXME、-、-、MARK标记用法" class="headerlink" title="9、Xcode 使用 TODO、FIXME、!!!、???、MARK标记用法"></a>9、Xcode 使用 TODO、FIXME、!!!、???、MARK标记用法</h3><p>// MARK: 标记，和#pragma mark效果类似 </p><p>// TODO: 标示处有功能代码待编写 </p><p>// FIXME: 标示处代码需要修正 </p><p>// !!!: 标示处代码需要注意（警告） </p><p>// ???: 标示处代码有疑问 （这里代码是个坑）</p><h3 id="10、添加自定义快捷键"><a href="#10、添加自定义快捷键" class="headerlink" title="10、添加自定义快捷键"></a>10、添加自定义快捷键</h3><p><a href="https://www.jianshu.com/p/cc6e13365b7e" target="_blank" rel="noopener">https://www.jianshu.com/p/cc6e13365b7e</a></p><h3 id="11、h-和-m-文件切换"><a href="#11、h-和-m-文件切换" class="headerlink" title="11、h 和 .m 文件切换"></a>11、h 和 .m 文件切换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Command + Control + Up/Down</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;打开默认快捷键设置：&lt;strong&gt;preferences&lt;/strong&gt; 里找到 &lt;strong&gt;Key Bindings&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;1、格式化代码&quot;&gt;&lt;a href=&quot;#1、格式化代码&quot; class=&quot;headerlink&quot; title=&quot;1、格式化代码&quot;&gt;&lt;/a&gt;1、格式化代码&lt;/h3&gt;&lt;p&gt;选中要格式化的代码，&lt;code&gt;ctrl + i&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;2、关闭-tab-窗口&quot;&gt;&lt;a href=&quot;#2、关闭-tab-窗口&quot; class=&quot;headerlink&quot; title=&quot;2、关闭 tab 窗口&quot;&gt;&lt;/a&gt;2、关闭 tab 窗口&lt;/h3&gt;&lt;p&gt;cmd + w&lt;/p&gt;
&lt;h3 id=&quot;3、快速搜索&quot;&gt;&lt;a href=&quot;#3、快速搜索&quot; class=&quot;headerlink&quot; title=&quot;3、快速搜索&quot;&gt;&lt;/a&gt;3、快速搜索&lt;/h3&gt;&lt;p&gt;&lt;code&gt;Shift + Command + O&lt;/code&gt; 來快速打開，並按下 &lt;strong&gt;Option&lt;/strong&gt; 鍵來選取檔案&lt;/p&gt;
&lt;h3 id=&quot;4、清理工程&quot;&gt;&lt;a href=&quot;#4、清理工程&quot; class=&quot;headerlink&quot; title=&quot;4、清理工程&quot;&gt;&lt;/a&gt;4、清理工程&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;* Clean: ⌘ + ⇧ + K&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;* Clean the build folder: ⌘ + ⇧ + ⌥ + K&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;5、排序語句&quot;&gt;&lt;a href=&quot;#5、排序語句&quot; class=&quot;headerlink&quot; title=&quot;5、排序語句&quot;&gt;&lt;/a&gt;5、排序語句&lt;/h3&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://www.vance.xin/categories/iOS/"/>
    
    
      <category term="iOS" scheme="https://www.vance.xin/tags/iOS/"/>
    
      <category term="Xcode" scheme="https://www.vance.xin/tags/Xcode/"/>
    
  </entry>
  
  <entry>
    <title>初学者的iOS开发学习笔记</title>
    <link href="https://www.vance.xin/2022/10/18/%E5%88%9D%E5%AD%A6%E8%80%85%E7%9A%84iOS%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://www.vance.xin/2022/10/18/初学者的iOS开发学习笔记/</id>
    <published>2022-10-18T21:52:52.000Z</published>
    <updated>2024-05-12T05:02:43.596Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个 iOS 开发的初学者，记录一下自己自学 iOS 过程中的一些坑和问题，仅供参考。</p><h2 id="1、Main-Bundle-Id-Extension-Bundle-Id（小组件）"><a href="#1、Main-Bundle-Id-Extension-Bundle-Id（小组件）" class="headerlink" title="1、Main Bundle Id + Extension Bundle Id（小组件）"></a>1、Main Bundle Id + Extension Bundle Id（小组件）</h2><p><strong>规则：前半部分相同，后半部分 + .extension</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Main app bundle id: com.myapp.testapp</span><br><span class="line">Extension app bundle id: com.myapp.testapp.myextension</span><br></pre></td></tr></table></figure><h2 id="2、iOS-加异常断点"><a href="#2、iOS-加异常断点" class="headerlink" title="2、iOS 加异常断点"></a>2、iOS 加异常断点</h2><p><a href="https://blog.csdn.net/wu_shu_jun/article/details/9045911" target="_blank" rel="noopener">https://blog.csdn.net/wu_shu_jun/article/details/9045911</a></p><p><a href="https://www.jianshu.com/p/3a0803406d04" target="_blank" rel="noopener">https://www.jianshu.com/p/3a0803406d04</a></p><p><a href="https://www.jianshu.com/p/7c0352231eca" target="_blank" rel="noopener">https://www.jianshu.com/p/7c0352231eca</a></p><h2 id="3、Incompatible-block-pointer-types-sending-‘void"><a href="#3、Incompatible-block-pointer-types-sending-‘void" class="headerlink" title="3、Incompatible block pointer types sending ‘void"></a>3、Incompatible block pointer types sending ‘void</h2><p>找到对应的报错库，添加：<code>-Xclang -fcompatibility-qualified-id-block-type-checking</code></p><p>链接：<a href="https://www.jianshu.com/p/317bdbe86454" target="_blank" rel="noopener">https://www.jianshu.com/p/317bdbe86454</a></p><p>这种是临时解决方案，最好的方式是升级对应的第三方库；</p><h2 id="4、uncaught-exception-‘NSInvalidArgumentException’-reason-‘-LSDefaults-sharedInstance-unrecognized-selector-sent-to-class"><a href="#4、uncaught-exception-‘NSInvalidArgumentException’-reason-‘-LSDefaults-sharedInstance-unrecognized-selector-sent-to-class" class="headerlink" title="4、uncaught exception ‘NSInvalidArgumentException’, reason: ‘+[_LSDefaults sharedInstance]: unrecognized selector sent to class"></a>4、uncaught exception ‘NSInvalidArgumentException’, reason: ‘+[_LSDefaults sharedInstance]: unrecognized selector sent to class</h2><p><a href="https://blog.csdn.net/survivorsfyh/article/details/104942440" target="_blank" rel="noopener">https://blog.csdn.net/survivorsfyh/article/details/104942440</a></p><h2 id="5、从-pod-删除第三方库："><a href="#5、从-pod-删除第三方库：" class="headerlink" title="5、从 pod 删除第三方库："></a>5、从 pod 删除第三方库：</h2><p>先在 podfile 文件中删除 pod ‘JSONKit’，然后在执行更新命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod update  --no-repo-update</span><br></pre></td></tr></table></figure><h2 id="6、‘sharedApplication’-is-unavailable-not-available-on-iOS-App-Extension-Use-view-controller-based"><a href="#6、‘sharedApplication’-is-unavailable-not-available-on-iOS-App-Extension-Use-view-controller-based" class="headerlink" title="6、‘sharedApplication’ is unavailable: not available on iOS (App Extension) - Use view controller based"></a>6、<strong>‘sharedApplication’ is unavailable: not available on iOS (App Extension) - Use view controller based</strong></h2><p><strong>小组件中不能使用</strong> <strong>sharedApplication 获取 UIApplication 对象；</strong></p><p><a href="https://stackoverflow.com/questions/29288217/watchkit-sharedapplication-is-unavailable-not-available-on-ios-app-extensi" target="_blank" rel="noopener">https://stackoverflow.com/questions/29288217/watchkit-sharedapplication-is-unavailable-not-available-on-ios-app-extensi</a></p><h2 id="7、设置APPLICATION-EXTENSION-API-ONLY"><a href="#7、设置APPLICATION-EXTENSION-API-ONLY" class="headerlink" title="7、设置APPLICATION_EXTENSION_API_ONLY"></a>7、设置APPLICATION_EXTENSION_API_ONLY</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">post_install do |installer_representation|</span><br><span class="line">installer_representation.pods_project.targets.each do |target|</span><br><span class="line">target.build_configurations.each do |config|</span><br><span class="line">config.build_settings[&apos;APPLICATION_EXTENSION_API_ONLY&apos;] = &apos;NO&apos;</span><br><span class="line">end</span><br><span class="line">end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="8、页面（ViewController）跳转"><a href="#8、页面（ViewController）跳转" class="headerlink" title="8、页面（ViewController）跳转"></a>8、页面（ViewController）跳转</h2><h3 id="8-1-Push"><a href="#8-1-Push" class="headerlink" title="8.1 Push"></a>8.1 Push</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BadgeController *vc = [[BadgeController alloc] init];</span><br><span class="line">[self.navigationController pushViewController:vc animated:YES];</span><br></pre></td></tr></table></figure><h3 id="8-2-Pop-关闭页面"><a href="#8-2-Pop-关闭页面" class="headerlink" title="8.2 Pop(关闭页面)"></a>8.2 Pop(关闭页面)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[self dismissViewControllerAnimated:YES completion:^&#123;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">// 或者</span><br><span class="line">[self.navigationController dismissViewControllerAnimated:true completion:nil];</span><br><span class="line"></span><br><span class="line">// 或者</span><br><span class="line">[self.navigationController popViewControllerAnimated:YES];</span><br></pre></td></tr></table></figure><h2 id="9、ViewController中用代码实现显示-UIImageView-UILabel-UIButton-UI-控件"><a href="#9、ViewController中用代码实现显示-UIImageView-UILabel-UIButton-UI-控件" class="headerlink" title="9、ViewController中用代码实现显示 UIImageView UILabel UIButton UI 控件"></a>9、ViewController中用代码实现显示 UIImageView UILabel UIButton UI 控件</h2><p>页面步骤如下：</p><p>跟在Android中差不多：</p><p>1、创建view对象；</p><p>2、设置view的各种属性，如大小摆放位置等；</p><p>3、添加到父视图中；</p><h2 id="10、Programming-with-Objective-C-（Apple-Development）"><a href="#10、Programming-with-Objective-C-（Apple-Development）" class="headerlink" title="10、Programming with Objective-C （Apple Development）"></a>10、Programming with Objective-C （Apple Development）</h2><p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/DefiningClasses/DefiningClasses.html#//apple_ref/doc/uid/TP40011210-CH3-SW1" target="_blank" rel="noopener">https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/DefiningClasses/DefiningClasses.html#//apple_ref/doc/uid/TP40011210-CH3-SW1</a></p><h2 id="11、iOS-设置点击事件："><a href="#11、iOS-设置点击事件：" class="headerlink" title="11、iOS 设置点击事件："></a>11、iOS 设置点击事件：</h2><p>// 方式一</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[self.infoView addTapActionWithBlock:^(UIGestureRecognizer *gestureRecoginzer) &#123;</span><br><span class="line">@strongify(self)</span><br><span class="line">// todo</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>// 方式二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">UIImageView *iKnowIcon = [CYResource loadImageView:@&quot;free-question-once-more-i-know.png&quot;];</span><br><span class="line">iKnowIcon.top = questionIcon.top + scaleWidthWith320(200);</span><br><span class="line">iKnowIcon.centerX = self.width / 2;</span><br><span class="line">[self addSubview:iKnowIcon];</span><br><span class="line">UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(dismiss)];</span><br><span class="line">iKnowIcon.userInteractionEnabled = YES;</span><br><span class="line">[iKnowIcon addGestureRecognizer:tap];</span><br></pre></td></tr></table></figure><p>方式三：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 步骤1：创建手势响应函数</span><br><span class="line">- (void)event:(UITapGestureRecognizer *)gesture</span><br><span class="line">&#123;</span><br><span class="line">   //处理事件</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 步骤2：创建手势</span><br><span class="line">UITapGestureRecognizer * tapGesture = [[UITapGestureRecognizer alloc] initWithTarget:self action:@selector(event:)];</span><br><span class="line"></span><br><span class="line">// 步骤3：给View添加手势</span><br><span class="line">//设置需要连续点击几次才响应，默认点击1次</span><br><span class="line">[tapGesture setNumberOfTapsRequired:1];</span><br><span class="line">[topView addGestureRecognizer:tapGesture];</span><br></pre></td></tr></table></figure><h2 id="12、iOS-事件传递"><a href="#12、iOS-事件传递" class="headerlink" title="12、iOS 事件传递"></a>12、iOS 事件传递</h2><p>iOS 中只有继承了 <strong>UIResponse</strong> 的对象才能够接受处理事件。UIResponse是响应对象的基类，定义了处理上述各种事件的接口。常见的子类有：UIView，UIViewController，UIApplication和UIApplicationDelegate.</p><p>链接：<a href="https://juejin.cn/post/6873761108662943757" target="_blank" rel="noopener">https://juejin.cn/post/6873761108662943757</a></p><p>记账 app 中设置的点击事件</p><p>因为 MineController 是 UIResponse 的子类，而 UIResponse 扩展了QFEventHandle，实现了<strong>routerEventWithName</strong> 方法，所以，在 MineController 中实现了 <strong>routerEventWithName</strong> 方法，子 <strong>View</strong> 在调用这个方法时，传递了点击事件类型，<strong>MineController</strong> 中会收到回调，而它里面绑定了各种点击事件类型的处理，所有可以处理点击事件。</p><h2 id="13、屏幕底部显示如下样式的popup-window"><a href="#13、屏幕底部显示如下样式的popup-window" class="headerlink" title="13、屏幕底部显示如下样式的popup window"></a>13、屏幕底部显示如下样式的popup window</h2><p><img src="https://cdn.jsdelivr.net/gh/xinpengfei520/my-cloud-picture@master/IMG_2022/202210182210481.jpg" alt="IMG_4466"></p><p>// 更多登录方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (IBAction)moreBtnClick:(UIButton *)sender &#123;</span><br><span class="line">  UIActionSheet *sheet = [[UIActionSheet alloc] initWithTitle:nil delegate:nil cancelButtonTitle:@&quot;取消&quot; destructiveButtonTitle:nil otherButtonTitles:@&quot;注册&quot;, @&quot;手机登录&quot;, nil];</span><br><span class="line"></span><br><span class="line">  [sheet showInView:self.view];</span><br><span class="line">  [[sheet rac_buttonClickedSignal] subscribeNext:^(NSNumber *number) &#123;</span><br><span class="line">NSInteger index = [number integerValue];</span><br><span class="line"></span><br><span class="line">// 注册</span><br><span class="line">if (index == 0) &#123;</span><br><span class="line">RE1Controller *vc = [[RE1Controller alloc] init];</span><br><span class="line">[self.navigationController pushViewController:vc animated:YES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 手机登录</span><br><span class="line">else if (index == 1) &#123;</span><br><span class="line">PhoneController *vc = [[PhoneController alloc] init];</span><br><span class="line">[self.navigationController pushViewController:vc animated:YES];</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="14、NSNotificationCenter-使用（类似于EventBus）"><a href="#14、NSNotificationCenter-使用（类似于EventBus）" class="headerlink" title="14、NSNotificationCenter 使用（类似于EventBus）"></a>14、NSNotificationCenter 使用（类似于EventBus）</h2><p>// 前一个页面监听通知</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)rac_notification_register &#123;</span><br><span class="line">  @weakify(self)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  // 登录完成</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[[[[NSNotificationCenter defaultCenter] rac_addObserverForName:LOPGIN_LOGIN_COMPLETE object:nil] takeUntil:self.rac_willDeallocSignal] subscribeNext:^(id x) &#123;</span><br><span class="line">@strongify(self)</span><br><span class="line">// 回调</span><br><span class="line">if (self.complete) &#123;</span><br><span class="line">self.complete();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 关闭</span><br><span class="line">[self.navigationController dismissViewControllerAnimated:true completion:nil];</span><br><span class="line">  &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>// 后一个页面发送通知</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[NSNotificationCenter defaultCenter] postNotificationName:LOPGIN_LOGIN_COMPLETE object:nil];</span><br></pre></td></tr></table></figure><h2 id="15、将View-跟-xib-文件绑定到一起"><a href="#15、将View-跟-xib-文件绑定到一起" class="headerlink" title="15、将View 跟 xib 文件绑定到一起"></a>15、将View 跟 xib 文件绑定到一起</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[_collection registerNib:[UINib nibWithNibName:@&quot;FindBookCell&quot; bundle:nil] forCellWithReuseIdentifier:@&quot;FindBookCell&quot;];</span><br></pre></td></tr></table></figure><h2 id="16、控件不显示"><a href="#16、控件不显示" class="headerlink" title="16、控件不显示"></a>16、控件不显示</h2><p>如果不显示，可能是被其他控件遮挡住了，设置的约束有问题，可通过 Debug View Hierarchy 看 View 的层级；</p><h2 id="17、UIButton-才可以设置点击事件，UIImageView-不可以；"><a href="#17、UIButton-才可以设置点击事件，UIImageView-不可以；" class="headerlink" title="17、UIButton 才可以设置点击事件，UIImageView 不可以；"></a>17、UIButton 才可以设置点击事件，UIImageView 不可以；</h2><p>如果需要给 <strong>UIImageView</strong> 设置点击事件，需要设置它可点击。</p><h2 id="18、-OC-中-pragma-mark的意义和作用"><a href="#18、-OC-中-pragma-mark的意义和作用" class="headerlink" title="18、 OC 中 #pragma mark的意义和作用"></a>18、 OC 中 #pragma mark的意义和作用</h2><p>它们告诉<a href="https://so.csdn.net/so/search?q=Xcode&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener">Xcode</a>编译器，要在编辑器窗格顶部的方法和函数弹出菜单中将代码分隔开，一些类（尤其是一些控制器类）可能很长，方法和函数弹出菜单可以便于代码导航。此时加入 <code>#pragma</code> 指令对代码进行逻辑组织很有效果。</p><h2 id="19、设置启动图"><a href="#19、设置启动图" class="headerlink" title="19、设置启动图"></a>19、设置启动图</h2><p>有两种方式，方式一：<strong>LaunchImage</strong>，已被废弃，官方推荐使用 <strong>LaunchScreen.storyboard</strong> 配置启动图，从 <strong>2020.4.30</strong> 开始提交 <strong>App Store</strong> 必须使用故事板来设置启动图。</p><h2 id="20、判断相等"><a href="#20、判断相等" class="headerlink" title="20、判断相等"></a>20、判断相等</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void f1() &#123;</span><br><span class="line">  NSNumber* num1 = [NSNumber numberWithInt:23];</span><br><span class="line">  NSNumber* num2 = [NSNumber numberWithFloat:23.0f];</span><br><span class="line">  BOOL b = [num1 isEqualToNumber:num2];</span><br><span class="line">  if (b) &#123;</span><br><span class="line">NSLog(@&quot;相等&quot;);</span><br><span class="line">  &#125;else &#123;</span><br><span class="line">NSLog(@&quot;不相等&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="21、《Objective-C-For-Absolute-Beginners》源码"><a href="#21、《Objective-C-For-Absolute-Beginners》源码" class="headerlink" title="21、《Objective-C For Absolute Beginners》源码"></a>21、《Objective-C For Absolute Beginners》源码</h2><p><a href="https://github.com/Apress/Objct-C-Abs-Begs" target="_blank" rel="noopener">https://github.com/Apress/Objct-C-Abs-Begs</a></p><p><a href="https://github.com/Apress/objective-c-for-absolute-begs-3ed" target="_blank" rel="noopener">https://github.com/Apress/objective-c-for-absolute-begs-3ed</a></p><p><a href="https://github.com/Apress/objective-c-for-absolute-begs-11" target="_blank" rel="noopener">https://github.com/Apress/objective-c-for-absolute-begs-11</a></p><p><a href="https://github.com/Apress/objective-c-for-absolute-begs" target="_blank" rel="noopener">https://github.com/Apress/objective-c-for-absolute-begs</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一个 iOS 开发的初学者，记录一下自己自学 iOS 过程中的一些坑和问题，仅供参考。&lt;/p&gt;
&lt;h2 id=&quot;1、Main-Bundle-Id-Extension-Bundle-Id（小组件）&quot;&gt;&lt;a href=&quot;#1、Main-Bundle-Id-Extension-Bundle-Id（小组件）&quot; class=&quot;headerlink&quot; title=&quot;1、Main Bundle Id + Extension Bundle Id（小组件）&quot;&gt;&lt;/a&gt;1、Main Bundle Id + Extension Bundle Id（小组件）&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;规则：前半部分相同，后半部分 + .extension&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Main app bundle id: com.myapp.testapp&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Extension app bundle id: com.myapp.testapp.myextension&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;2、iOS-加异常断点&quot;&gt;&lt;a href=&quot;#2、iOS-加异常断点&quot; class=&quot;headerlink&quot; title=&quot;2、iOS 加异常断点&quot;&gt;&lt;/a&gt;2、iOS 加异常断点&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/wu_shu_jun/article/details/9045911&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/wu_shu_jun/article/details/9045911&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/3a0803406d04&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/3a0803406d04&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/7c0352231eca&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.jianshu.com/p/7c0352231eca&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;3、Incompatible-block-pointer-types-sending-‘void&quot;&gt;&lt;a href=&quot;#3、Incompatible-block-pointer-types-sending-‘void&quot; class=&quot;headerlink&quot; title=&quot;3、Incompatible block pointer types sending ‘void&quot;&gt;&lt;/a&gt;3、Incompatible block pointer types sending ‘void&lt;/h2&gt;&lt;p&gt;找到对应的报错库，添加：&lt;code&gt;-Xclang -fcompatibility-qualified-id-block-type-checking&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://www.vance.xin/categories/iOS/"/>
    
    
      <category term="View" scheme="https://www.vance.xin/tags/View/"/>
    
      <category term="iOS" scheme="https://www.vance.xin/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>只需7步大幅提升你的AS编译速度</title>
    <link href="https://www.vance.xin/2022/10/18/%E5%8F%AA%E9%9C%807%E6%AD%A5%E5%A4%A7%E5%B9%85%E6%8F%90%E5%8D%87%E4%BD%A0%E7%9A%84AS%E7%BC%96%E8%AF%91%E9%80%9F%E5%BA%A6/"/>
    <id>https://www.vance.xin/2022/10/18/只需7步大幅提升你的AS编译速度/</id>
    <published>2022-10-18T21:25:01.000Z</published>
    <updated>2024-05-12T05:02:43.596Z</updated>
    
    <content type="html"><![CDATA[<h2 id="7-Tips-to-Improve-Gradle-Build-Speed-in-Android-Studio"><a href="#7-Tips-to-Improve-Gradle-Build-Speed-in-Android-Studio" class="headerlink" title="7 Tips to Improve Gradle Build Speed in Android Studio"></a>7 Tips to Improve Gradle Build Speed in Android Studio</h2><ul><li><p>Keep your tools up to date.</p></li><li><p>Enable Gradle Daemon.</p></li><li><p>Use More Memory. </p></li><li><p>Avoid Dynamic Dependencies.</p></li><li><p>Use WebP Images. </p></li><li><p>Remove Unused Resources. </p></li><li><p>Disable ProGuard in Debug Mode.</p></li></ul><h2 id="译"><a href="#译" class="headerlink" title="译"></a>译</h2><ul><li><p>保持你的工具是最新的。</p></li><li><p>启用 Gradle Daemon。</p></li><li><p>使用更多的内存。</p></li><li><p>避免动态依赖。</p></li><li><p>使用 WebP 图像。</p></li><li><p>移除未使用的资源。</p></li><li><p>在调试模式下关闭 ProGuard 功能。</p></li></ul><p>在 <strong>gradle.properties</strong> 文件中可以对 Gradle 进行各种配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">org.gradle.jvmargs=-Xmx4096m -Dfile.encoding=UTF-8</span><br><span class="line">org.gradle.daemon=true</span><br><span class="line">org.gradle.parallel=true</span><br></pre></td></tr></table></figure><p>如果你的项目中放了大的静态文件，比如字体库、数据库等等，可能会导致编译出错，这时候你需要设置更大内存，比如 6G，才能编译并运行你的项目，参考设置如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.gradle.jvmargs=-Xmx6g -XX:MaxMetaspaceSize=2048m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8</span><br></pre></td></tr></table></figure><p>默认情况下，如果你已经成功编译并运行过一次项目了，那么你可以开启离线模式，也可以提升编译速度，如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/xinpengfei520/my-cloud-picture@master/IMG_2022/202210182130728.png" alt="image-20221018213023067"></p><p>离线模式下，它不回去在线检查下载最新的依赖库或者工具，在一定程度下也会提升编译速度。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;7-Tips-to-Improve-Gradle-Build-Speed-in-Android-Studio&quot;&gt;&lt;a href=&quot;#7-Tips-to-Improve-Gradle-Build-Speed-in-Android-Studio&quot; class=&quot;headerlink&quot; title=&quot;7 Tips to Improve Gradle Build Speed in Android Studio&quot;&gt;&lt;/a&gt;7 Tips to Improve Gradle Build Speed in Android Studio&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Keep your tools up to date.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Enable Gradle Daemon.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Use More Memory. &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Avoid Dynamic Dependencies.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Use WebP Images. &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Remove Unused Resources. &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Disable ProGuard in Debug Mode.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;译&quot;&gt;&lt;a href=&quot;#译&quot; class=&quot;headerlink&quot; title=&quot;译&quot;&gt;&lt;/a&gt;译&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;保持你的工具是最新的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;启用 Gradle Daemon。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用更多的内存。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;避免动态依赖。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;使用 WebP 图像。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;移除未使用的资源。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在调试模式下关闭 ProGuard 功能。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 &lt;strong&gt;gradle.properties&lt;/strong&gt; 文件中可以对 Gradle 进行各种配置：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;org.gradle.jvmargs=-Xmx4096m -Dfile.encoding=UTF-8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;org.gradle.daemon=true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;org.gradle.parallel=true&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果你的项目中放了大的静态文件，比如字体库、数据库等等，可能会导致编译出错，这时候你需要设置更大内存，比如 6G，才能编译并运行你的项目，参考设置如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;org.gradle.jvmargs=-Xmx6g -XX:MaxMetaspaceSize=2048m -XX:+HeapDumpOnOutOfMemoryError -Dfile.encoding=UTF-8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;默认情况下，如果你已经成功编译并运行过一次项目了，那么你可以开启离线模式，也可以提升编译速度，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xinpengfei520/my-cloud-picture@master/IMG_2022/202210182130728.png&quot; alt=&quot;image-20221018213023067&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://www.vance.xin/categories/Android/"/>
    
    
      <category term="Android" scheme="https://www.vance.xin/tags/Android/"/>
    
      <category term="AndroidStudio" scheme="https://www.vance.xin/tags/AndroidStudio/"/>
    
  </entry>
  
  <entry>
    <title>Android 获取 View 在屏幕中的位置</title>
    <link href="https://www.vance.xin/2022/10/18/Android%20%E8%8E%B7%E5%8F%96View%E5%9C%A8%E5%B1%8F%E5%B9%95%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE/"/>
    <id>https://www.vance.xin/2022/10/18/Android 获取View在屏幕中的位置/</id>
    <published>2022-10-18T21:17:57.000Z</published>
    <updated>2024-05-12T05:02:43.596Z</updated>
    
    <content type="html"><![CDATA[<p>我们在开发过程中，有时候需要获取一个 <strong>View</strong> 在屏幕中的位置，比如这个 <strong>View</strong> 是否在屏幕中显示，还是在屏幕之外等等。</p><p>我们可以通过位置，对其做一些操作，以便完成我们的业务需求。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> location = IntArray(<span class="number">2</span>)</span><br><span class="line">it.getLocationOnScreen(location)</span><br><span class="line"><span class="keyword">val</span> x = location[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">val</span> y = location[<span class="number">1</span>]</span><br><span class="line">Log.d(<span class="string">"TAG"</span>, <span class="string">"getLocationOnScreen  x = <span class="variable">$x</span> ;  y = <span class="variable">$y</span>"</span>)</span><br><span class="line"></span><br><span class="line">it.getLocationInWindow(location)</span><br><span class="line"><span class="keyword">val</span> x1 = location[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">val</span> y2 = location[<span class="number">1</span>]</span><br><span class="line">LogUtil.d(<span class="string">"TAG"</span>, <span class="string">"getLocationInWindow  x1 = <span class="variable">$x1</span> ;  y2 = <span class="variable">$y2</span>"</span>)</span><br><span class="line"></span><br><span class="line">Log.d(<span class="string">"TAG"</span>, <span class="string">"left:"</span> + it.left)</span><br><span class="line">Log.d(<span class="string">"TAG"</span>, <span class="string">"right:"</span> + it.right)</span><br><span class="line">Log.d(<span class="string">"TAG"</span>, <span class="string">"Top:"</span> + it.top)</span><br><span class="line">Log.d(<span class="string">"TAG"</span>, <span class="string">"bottom:"</span> + it.bottom)</span><br><span class="line">Log.d(<span class="string">"TAG"</span>, <span class="string">"width:"</span> + it.width)</span><br><span class="line">Log.d(<span class="string">"TAG"</span>, <span class="string">"height:"</span> + it.height)</span><br></pre></td></tr></table></figure><p><strong>getLocationOnScreen</strong> 是 <strong>View</strong> 相对于物理手机屏幕的位置。</p><p><strong>getLocationInWindow</strong> 是 <strong>View</strong> 相对于窗口的位置，Window 是安卓系统中的一个类，不包括状态栏。</p><p>而 <strong>View</strong> 的 left、top、right、bottom 是它在父 View 中的位置。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在开发过程中，有时候需要获取一个 &lt;strong&gt;View&lt;/strong&gt; 在屏幕中的位置，比如这个 &lt;strong&gt;View&lt;/strong&gt; 是否在屏幕中显示，还是在屏幕之外等等。&lt;/p&gt;
&lt;p&gt;我们可以通过位置，对其做一些操作，以便完成我们的业务需求。&lt;/p&gt;
&lt;figure class=&quot;highlight kotlin&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; location = IntArray(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;it.getLocationOnScreen(location)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; x = location[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; y = location[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Log.d(&lt;span class=&quot;string&quot;&gt;&quot;TAG&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;getLocationOnScreen  x = &lt;span class=&quot;variable&quot;&gt;$x&lt;/span&gt; ;  y = &lt;span class=&quot;variable&quot;&gt;$y&lt;/span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;it.getLocationInWindow(location)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; x1 = location[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; y2 = location[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;LogUtil.d(&lt;span class=&quot;string&quot;&gt;&quot;TAG&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;getLocationInWindow  x1 = &lt;span class=&quot;variable&quot;&gt;$x1&lt;/span&gt; ;  y2 = &lt;span class=&quot;variable&quot;&gt;$y2&lt;/span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Log.d(&lt;span class=&quot;string&quot;&gt;&quot;TAG&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;left:&quot;&lt;/span&gt; + it.left)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Log.d(&lt;span class=&quot;string&quot;&gt;&quot;TAG&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;right:&quot;&lt;/span&gt; + it.right)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Log.d(&lt;span class=&quot;string&quot;&gt;&quot;TAG&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Top:&quot;&lt;/span&gt; + it.top)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Log.d(&lt;span class=&quot;string&quot;&gt;&quot;TAG&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;bottom:&quot;&lt;/span&gt; + it.bottom)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Log.d(&lt;span class=&quot;string&quot;&gt;&quot;TAG&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;width:&quot;&lt;/span&gt; + it.width)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Log.d(&lt;span class=&quot;string&quot;&gt;&quot;TAG&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;height:&quot;&lt;/span&gt; + it.height)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;getLocationOnScreen&lt;/strong&gt; 是 &lt;strong&gt;View&lt;/strong&gt; 相对于物理手机屏幕的位置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;getLocationInWindow&lt;/strong&gt; 是 &lt;strong&gt;View&lt;/strong&gt; 相对于窗口的位置，Window 是安卓系统中的一个类，不包括状态栏。&lt;/p&gt;
&lt;p&gt;而 &lt;strong&gt;View&lt;/strong&gt; 的 left、top、right、bottom 是它在父 View 中的位置。&lt;/p&gt;

    
    </summary>
    
      <category term="Android" scheme="https://www.vance.xin/categories/Android/"/>
    
    
      <category term="Android" scheme="https://www.vance.xin/tags/Android/"/>
    
      <category term="View" scheme="https://www.vance.xin/tags/View/"/>
    
  </entry>
  
  <entry>
    <title>每个人都是一座宝藏，请不要吝啬挖掘你自己</title>
    <link href="https://www.vance.xin/2022/09/26/%E6%AF%8F%E4%B8%AA%E4%BA%BA%E9%83%BD%E6%98%AF%E4%B8%80%E5%BA%A7%E5%AE%9D%E8%97%8F%E8%AF%B7%E4%B8%8D%E8%A6%81%E5%90%9D%E5%95%AC%E6%8C%96%E6%8E%98%E4%BD%A0%E8%87%AA%E5%B7%B1/"/>
    <id>https://www.vance.xin/2022/09/26/每个人都是一座宝藏请不要吝啬挖掘你自己/</id>
    <published>2022-09-26T23:28:01.000Z</published>
    <updated>2024-05-12T05:02:43.600Z</updated>
    
    <content type="html"><![CDATA[<p>大家好，我是 Vance。</p><p>你是不是有时候感觉自己一事无成？这也做不好，那也做不好？<br>没关系啦，其实，每个人都是一座宝藏。</p><p>如果你觉得自己不是，只是你不知道自己是宝藏而已，重要的是，请不要吝啬挖掘你自己。</p><p>如何挖掘自己？我的答案在文中，咱们先看文章。</p><h2 id="1、理想很丰满，现实很骨感"><a href="#1、理想很丰满，现实很骨感" class="headerlink" title="1、理想很丰满，现实很骨感"></a>1、理想很丰满，现实很骨感</h2><p>我先简单介绍下自己。我叫 Vance，男，93 年的，朋友们都叫我飞飞，现居上海。</p><p>2015 年大学毕业，像很多刚毕业的大学生一样，毕业即失业，也对未来充满了迷茫，为了生存我不得不去电子厂打工谋生。</p><p>但是我很清楚，这里不属于我，我只是短暂的过渡一下，几个月之后，我怀揣着梦想去了北京，开始了我的北漂之旅。</p><p>我本身学的是计算机专业，我个人对技术也比较感兴趣，所以就选择了程序员这个职业。</p><p>刚开始工作的时候，因为自己技术很菜，每解决一个问题，我就记录下来，一是加深自己的印象，二是下次再遇到同样的问题方便查找。</p><p>还有一些学到的新东西，也会整理成文档，好记性不如烂笔头嘛。后来有个同学告诉我，为什么不写博客呢？于是乎，我将自己遇到的问题和学习笔记写成博客发布到网上。</p><p>刚开始，每写完一篇发布到网上，感觉很新奇，也很有成就感，就这样，后面所有写的东西都发在博客网站上了。</p><p>17 年那会我关注了很多公众号，有一些是技术相关的公众号，我就在想，我也可以写呀，一拍脑袋，申请了公众号，就开始了自己的公众号之旅。</p><p>我的想法很简单，跟博客一样，写技术相关的，把博客的内容在公众号上再发一遍。</p><p>刚开始关注我的人很少，阅读量也很低，好不容易花很长时间写了一篇文章，没有人评论，也没有人点赞，发了一篇文章，感觉就像石沉大海了一样没有任何反馈。<br>跟我想的完全不一样，博客多少还有一些阅读量，公众号基本没有人看，自己也不知道为什么。</p><p>后来，又断断续续写了一些，感觉没有动力坚持下去，再到后来，过了一阵子，就放弃了。</p><h2 id="2、不放弃，就会有希望"><a href="#2、不放弃，就会有希望" class="headerlink" title="2、不放弃，就会有希望"></a>2、不放弃，就会有希望</h2><p>现在回头看，一方面是自己写的太少坚持不够，另一方面缺少正反馈，也不知道自己的问题出在哪，自己瞎琢磨也琢磨不出什么。</p><p>还有一个很重要的原因是，自己不相信自己，这也可能是大部分人坚持不下去的原因。</p><p>现在想想当时的自己，一下子感觉清晰了很多，虽然没坚持下来，但是幸运的是，一直没有放弃学习，没有放弃想要学好写作，那个小火苗一直还在，只是暂时熄灭了。</p><p>直到遇见了粥老师的写作训练营，重燃了我心中的那个小火苗。</p><p>记得很早之前就关注了粥老师的公众号，也知道老师有写作课，一直没有报名，因为自己对自己没有信心，所以，一直犹豫和徘徊了很久。</p><p>人生最大的遗憾不是选错，而是一直犹豫徘徊浪费时间。</p><p>选错不可怕，就算选错了，也至少能让你自己知道，自己确实不适合做这件事，也是帮你排除了一个选择，也算是一种收获。</p><p>所以，我们要敢于去试错，敢于选择，在自己可接受的范围内试错是可取的，能用钱解决的事情就用钱解决，毕竟时间错过了就真的错过了。</p><p>现在想想，为什么没有早点遇见粥老师，为什么不早点报粥老师的写作课？人生没有后悔药，幸运的是现在还不算太晚。</p><p>我之前关注了粥老师的视频号，所以每次他直播我都会收到推送，有时候我会点进去看看粥老师在讲什么。</p><p>陆陆续续听了好几次，粥老师每次都会讲很多干货，感觉很有用，每次听直播都会做笔记，慢慢的我发现粥老师讲的真好，我想粥老师的写作课也一定会讲的更好，我果断报名了。</p><p>首先报的是7天写作训练营，虽然只有 9.9，但是学到了很多的东西，收获满满，学完后，果断又连报了 21 天和高阶训练营。</p><p>现在看来，这是我 2021 年最超值的一次投资学习。</p><p>一个人走得快，一群人走得远。</p><p>一个人走得再快，也有累的时候。就像我刚开始的写作的时候，虽然写了一些文章，但是很难持续和坚持，容易受自己的主观情绪影响。</p><p>一群人就不一样了，自从加入了粥老师的写作训练营，每天有老师提醒你写作业，帮你点评作业，还有同学们的加油鼓励，看到优秀的人都还那么努力，为什么你还不努力呢？</p><p>很重要的一个原因是，这里有很棒的学习氛围，有真实的反馈，然后你再根据反馈不断迭代，在这种环境下，你不成长才怪呢。</p><p>自己立的 flag，跪着也要走完。</p><p>刚开始的入营的时候，我是不知道我自己每天能坚持下去的，刚开始我记得有一次作业，让我们写自己的目标，我就给自己立下了一个 flag：坚持每天打卡，不允许补卡。</p><p>既然立下了，就要严格执行下去，不管遇到什么困难，都要想办法克服，马上训练营结束了，到现在我还没有补过卡，大概率剩下的几天也不会补卡，给坚持的自己点个大大的赞，我真棒！</p><p>坚持说起来容易，做起来难。记得有好几次都是快到晚上 12 点了才打的卡，接近 996 的工作，每天晚上下班回来差不多快 10 点了，洗漱完后差不多 10 点半左右，留给我写作的时间只有 1 个半小时。</p><p>每当我坚持不下去的时候，想想自己的立的 flag，还有那么多优秀的同学，立马就有动力了，然后给自己一个积极的心理暗示，坚持的自己最酷了！</p><h2 id="3、挖掘自己，其实你也很优秀"><a href="#3、挖掘自己，其实你也很优秀" class="headerlink" title="3、挖掘自己，其实你也很优秀"></a>3、挖掘自己，其实你也很优秀</h2><p>在训练营的这段时间，自己的作业被精选了好几次，每一次精选都让自己很开心，还会一次被评为了精选优秀作业，班班还给我发了一个电子贺卡，老师在那么多同学的群里表扬我，满满的成就感，那种成长的感觉真的爽爆了！</p><p>小成绩也有大的力量感。这些虽然都是小小的成绩，但是它给我的力量是巨大的，让我知道我自己也是可以写好的，我也是优秀的。</p><p>当局者迷，旁观者清。</p><p>爱因斯坦曾说过：“每个人都是天才，但如果你用爬树的能力评断一条鱼，它将终其一生觉得自己是个笨蛋。”</p><p>这句话是什么意思呢？我的理解是，我们每个人来到这个世上，都有他自己擅长的东西，当你觉得自己一事无成的时候，恰恰是你需要挖掘自己的时候。</p><p>人们往往会觉得自己很了解自己，其实大多数人只是表面地了解自己。</p><p>我们经常说，“当局者迷，旁观者清”。大概意思是，比喻当事人会被事实真相所迷惑，处理事情往往糊涂，局外人反而看得清楚一些，说的就是这个道理。</p><p>找到自己热爱的事情是一件多么开心的事情，慢慢地发现，我热爱分享，喜欢帮助别人，我的内心是有分享欲的，因为帮助别人是一件让我觉得很开心的事情。</p><p>认真听取别人对你的评价。在训练营每一天的作业，都有老师和热心的同学给你评价，感谢你们给我的评价，不管好的坏的我都有认真看。</p><p>是你们让我变得越来越优秀，越来越有力量感。</p><p>再次谢谢你们，一起向上生长。被肯定只是优秀的开始，未来的每一天才是真正的蜕变。</p><p>在粥老师的写作训练营，让我真正地找到了我自己，挖掘了我自己。</p><p>每个人都是一座宝藏，挖掘自己，其实你也很优秀！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大家好，我是 Vance。&lt;/p&gt;
&lt;p&gt;你是不是有时候感觉自己一事无成？这也做不好，那也做不好？&lt;br&gt;没关系啦，其实，每个人都是一座宝藏。&lt;/p&gt;
&lt;p&gt;如果你觉得自己不是，只是你不知道自己是宝藏而已，重要的是，请不要吝啬挖掘你自己。&lt;/p&gt;
&lt;p&gt;如何挖掘自己？我的答案在文中，咱们先看文章。&lt;/p&gt;
&lt;h2 id=&quot;1、理想很丰满，现实很骨感&quot;&gt;&lt;a href=&quot;#1、理想很丰满，现实很骨感&quot; class=&quot;headerlink&quot; title=&quot;1、理想很丰满，现实很骨感&quot;&gt;&lt;/a&gt;1、理想很丰满，现实很骨感&lt;/h2&gt;&lt;p&gt;我先简单介绍下自己。我叫 Vance，男，93 年的，朋友们都叫我飞飞，现居上海。&lt;/p&gt;
&lt;p&gt;2015 年大学毕业，像很多刚毕业的大学生一样，毕业即失业，也对未来充满了迷茫，为了生存我不得不去电子厂打工谋生。&lt;/p&gt;
&lt;p&gt;但是我很清楚，这里不属于我，我只是短暂的过渡一下，几个月之后，我怀揣着梦想去了北京，开始了我的北漂之旅。&lt;/p&gt;
&lt;p&gt;我本身学的是计算机专业，我个人对技术也比较感兴趣，所以就选择了程序员这个职业。&lt;/p&gt;
&lt;p&gt;刚开始工作的时候，因为自己技术很菜，每解决一个问题，我就记录下来，一是加深自己的印象，二是下次再遇到同样的问题方便查找。&lt;/p&gt;
    
    </summary>
    
      <category term="生活" scheme="https://www.vance.xin/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="个人提升" scheme="https://www.vance.xin/tags/%E4%B8%AA%E4%BA%BA%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>我，牛逼吹大了。。</title>
    <link href="https://www.vance.xin/2022/09/25/%E6%88%91%E7%89%9B%E9%80%BC%E5%90%B9%E5%A4%A7%E4%BA%86/"/>
    <id>https://www.vance.xin/2022/09/25/我牛逼吹大了/</id>
    <published>2022-09-25T23:02:57.000Z</published>
    <updated>2024-05-12T05:02:43.596Z</updated>
    
    <content type="html"><![CDATA[<p>是这样的。</p><p>我在《<a href="http://mp.weixin.qq.com/s?__biz=MzU4MTIzNjg0Ng==&amp;mid=2247484609&amp;idx=1&amp;sn=4ab56b18f2aeb9ebea80286380b97d1e&amp;chksm=fd4be5c0ca3c6cd644c6f755b26353e82884e3461b26bd281340057b2539b37924092cd322fe&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">2021年个人总结</a>》中，信誓旦旦、意志坚定地给自己立了几个 flag，请看图</p><p><img src="https://cdn.jsdelivr.net/gh/xinpengfei520/my-cloud-picture@master/IMG_2022/202210061615018.png" alt=""></p><p>我一直以为离年底还早呢，突然想起来自己的立的 flag，到现在只完成了 <strong>10%</strong> 不到，这下牛逼真吹大了。。</p><p>人就是这样，没烧到眉毛就永远不会急，人性是懒的，我一直以为自己还算勤奋，现在才知道，我是假勤奋，不知道你也有没有这种拖延的习惯？</p><p>2022 年还剩 97 天，简单分解下我的 flag，要完成目标，平均 2 天要写一篇文章，每天要拍一条短视频，每周要跑 7km。</p><p>确实压力是有点大，谁让自己吹牛吹得这么大呢？</p><p>简单复盘下，为什么会没有严格执行下去呢？</p><p>我认为主要有三点：</p><p>1、目标清晰，但是没有拆分目标，比如拆分到月目标，每个月结束的时候进行复盘和调整；</p><p>2、没有监督、和奖惩制度机制，虽然我在文中邀请大家进行监督，但是我认为还不够，最好是找一个你身边熟悉的人，这样他就可以定期监督你了；</p><p>另外一个就是奖惩机制，比如，完成了一个阶段性的目标之后，就给自己一个奖励，如果没完成就设定一个惩罚，这样也是逼自己去完成目标；</p><p>3、懒，喜欢给自己找借口，说自己忙，其实，时间挤挤总是有的，每天再忙也可以挤出几十分钟去跑步锻炼吧，每天再忙，但是每天玩手机的时间也不少；</p><p>因为玩手机可以给自己短暂的快感，不用思考，但是之后，你会发现自己好多事还没做；人都是懒的，所以，还是要通过制度去逼自己去行动起来。</p><p>其实，行动起来并不难，难的是思想的转变，当你做一件事的时候，你脑子里就会有两个小人在打架，做？还是不做？做的话是需要费气力和费脑子的，人性都是懒的，所以，大多数情况下都会选择不费气力的事，因为躺着肯定比跑步轻松多了。</p><p>这个时候，最好给自己一个比较有诱惑力的奖励，比如跑完了，你就可以买 xxx 了，这时候你的大脑就开始兴奋了，因为你想要那个东西，所以不得不去跑，其实迈出第一步，其实并没有想的那么难，反而在跑的过程中感觉身心得到了放松，路上还可以看风景，还是蛮不错的。</p><p><strong>人很容易给自己找借口</strong></p><p>如果，你不想完成一件事，你可以给自己找一万个不做的借口，人就是这样。</p><p>何况是跑步健身，写文章，拍短视频这种费体力、脑力的事情，短期得不到任何好处，也看不实实在在的结果的事情，<strong>人们往往会高估短期的价值，而忽略长期的价值。</strong></p><p>像跑步健身、写文章、拍短视频，都是慢功夫，短期是看不到任何结果的，但是长期坚持下去，会受益无穷，很多事情，不仅仅是做到这么简单，还需要付出时间去坚持，量变才能引起质变。</p><p><strong>现在越来越觉得，人要对自己诚实，多反思，多总结，多思考，每日精进一点，坚持下去，其实已经超过大部分人了。</strong></p><p>加油吧，说的再多不如做的多，通过我这次吹牛逼的经历，让我知道了，吹牛逼不要吹的太大。</p><p>否则，自己吹的牛逼，跪着也要走完。 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;是这样的。&lt;/p&gt;
&lt;p&gt;我在《&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU4MTIzNjg0Ng==&amp;amp;mid=2247484609&amp;amp;idx=1&amp;amp;sn=4ab56b18f2aeb9ebea80286380b97d1e&amp;amp;chksm=fd4be5c0ca3c6cd644c6f755b26353e82884e3461b26bd281340057b2539b37924092cd322fe&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;2021年个人总结&lt;/a&gt;》中，信誓旦旦、意志坚定地给自己立了几个 flag，请看图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xinpengfei520/my-cloud-picture@master/IMG_2022/202210061615018.png&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;我一直以为离年底还早呢，突然想起来自己的立的 flag，到现在只完成了 &lt;strong&gt;10%&lt;/strong&gt; 不到，这下牛逼真吹大了。。&lt;/p&gt;
&lt;p&gt;人就是这样，没烧到眉毛就永远不会急，人性是懒的，我一直以为自己还算勤奋，现在才知道，我是假勤奋，不知道你也有没有这种拖延的习惯？&lt;/p&gt;
&lt;p&gt;2022 年还剩 97 天，简单分解下我的 flag，要完成目标，平均 2 天要写一篇文章，每天要拍一条短视频，每周要跑 7km。&lt;/p&gt;
&lt;p&gt;确实压力是有点大，谁让自己吹牛吹得这么大呢？&lt;/p&gt;
&lt;p&gt;简单复盘下，为什么会没有严格执行下去呢？&lt;/p&gt;
&lt;p&gt;我认为主要有三点：&lt;/p&gt;
&lt;p&gt;1、目标清晰，但是没有拆分目标，比如拆分到月目标，每个月结束的时候进行复盘和调整；&lt;/p&gt;
    
    </summary>
    
      <category term="个人生活" scheme="https://www.vance.xin/categories/%E4%B8%AA%E4%BA%BA%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="Plan" scheme="https://www.vance.xin/tags/Plan/"/>
    
      <category term="复盘" scheme="https://www.vance.xin/tags/%E5%A4%8D%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>Virtual和Vagrant 安装 CentOS7 虚拟机</title>
    <link href="https://www.vance.xin/2020/04/06/Virtual%20%E5%92%8C%20Vagrant%20%E5%AE%89%E8%A3%85%20CentOS7%20%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>https://www.vance.xin/2020/04/06/Virtual 和 Vagrant 安装 CentOS7 虚拟机/</id>
    <published>2020-04-06T17:18:57.000Z</published>
    <updated>2024-05-12T05:02:43.596Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-下载安装-VirtualBox"><a href="#1-下载安装-VirtualBox" class="headerlink" title="1.下载安装 VirtualBox"></a>1.下载安装 VirtualBox</h2><p><a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="noopener">https://www.virtualbox.org/wiki/Downloads</a></p><p>根据自己的操作系统类型下载安装即可！</p><p>支持的操作系统类型有：</p><ul><li>Windows hosts</li><li>OS X hosts</li><li>Linux distributions</li><li>Solaris hosts</li></ul><p>温馨提示：如果是 Windows 系统用户，需要再 BIOS 中设置开启 CPU 虚拟化！！！</p><h2 id="2-下载安装-Vagrant"><a href="#2-下载安装-Vagrant" class="headerlink" title="2.下载安装 Vagrant"></a>2.下载安装 Vagrant</h2><p><a href="https://www.vagrantup.com/downloads.html" target="_blank" rel="noopener">https://www.vagrantup.com/downloads.html</a></p><p>根据自己的操作系统类型下载安装即可！</p><p>支持的操作系统类型有：</p><p><img src="https://img-blog.csdnimg.cn/2020040617022531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbnBlbmdmZWk1MjE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="3-安装虚拟机"><a href="#3-安装虚拟机" class="headerlink" title="3.安装虚拟机"></a>3.安装虚拟机</h3><p>先打开 VirtualBox；</p><p>打开 Windows 的 cmd 或者 mac 的 Terminal 工具，输入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant</span><br></pre></td></tr></table></figure><p>如果有反应，说明我们的 <strong>vagrant</strong> 安装没有问题，可以进行下一步了。</p><p>输入命令初始化一个 centos7 虚拟机文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant init centos/7</span><br></pre></td></tr></table></figure><p>执行完上面的命令后会在用户目录下（Windows 在Users下面，mac 在用户姓名的目录下）生成一个 <strong>Vagrantfile</strong> 文件。</p><p>上面命令中的 <strong>centos/7</strong> 代表我们需要安装 CentOS7 的虚拟机，如果你要安装其他虚拟机就替换它就可以了。注意 <strong>/</strong> 不能省略掉！！！</p><p>支持的虚拟机类型在下面的网站可以查找到：</p><p><a href="https://app.vagrantup.com/boxes/search" target="_blank" rel="noopener">https://app.vagrantup.com/boxes/search</a></p><p>部分截图如下：</p><p><img src="https://img-blog.csdnimg.cn/20200406171236954.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbnBlbmdmZWk1MjE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>途中标红的就是安装的虚拟机的名称，如果要安装 Ubuntu 就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant init ubuntu/trusty64</span><br></pre></td></tr></table></figure><p>继续执行下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant up</span><br></pre></td></tr></table></figure><p>这个是安装启动虚拟机，如果是第一次，它会下载对应的虚拟机镜像文件，下载完成了之后就会自动启动虚拟机，以后再执行这个命令就是启动已经安装的虚拟机了。</p><p>实际情况在执行这个命令的时候，速度会特别慢，我这边显示剩余需要 30 多个小时，太漫长了，而且中间断了之后又要重新开始。</p><h3 id="3-设置第三方镜像"><a href="#3-设置第三方镜像" class="headerlink" title="3.设置第三方镜像"></a>3.设置第三方镜像</h3><p>下面的地址中下载你想要的镜像：</p><p><a href="http://www.vagrantbox.es/" target="_blank" rel="noopener">http://www.vagrantbox.es/</a></p><p>然后执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant box add &#123;title&#125; &#123;url&#125;</span><br><span class="line">$ vagrant init &#123;title&#125;</span><br><span class="line">$ vagrant up</span><br></pre></td></tr></table></figure><p>实际测试要比源下载地址快一些。</p><h3 id="4-本地安装"><a href="#4-本地安装" class="headerlink" title="4.本地安装"></a>4.本地安装</h3><p>本地安装，就是先通过网盘等下载别人分享的虚拟机 box 到本地，然后通过命令进行安装。</p><p>以 CentOS7 为例：</p><p>先下载 box，链接: <a href="https://pan.baidu.com/s/1HYnVmvgOnxuhWef6bRglRw" target="_blank" rel="noopener">https://pan.baidu.com/s/1HYnVmvgOnxuhWef6bRglRw</a> 提取码: tfn3</p><p>然后执行如下命令：</p><p>1.添加 vagrant box 到 box list</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant box add centos7 &lt;path&gt;</span><br></pre></td></tr></table></figure><p>path 为你下载的 box 镜像路径。</p><p>2.初始化一个虚拟机使用刚才添加的 vagrant box</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant init centos7</span><br></pre></td></tr></table></figure><p>温馨提示：如果你之前执行过初始化的命令，那个在执行这个命令的时候它会从去网上下载镜像，因此你需要找到 <strong>Vagrantfile</strong> 文件删除掉，然后再执行上面的命令就没问题了，安装完成后，下载的镜像文件也可以删掉了。</p><p>3.启动 vagrant box 虚拟机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant up</span><br></pre></td></tr></table></figure><h2 id="5-常用命令"><a href="#5-常用命令" class="headerlink" title="5.常用命令"></a>5.常用命令</h2><p>连接到 ssh:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant ssh</span><br></pre></td></tr></table></figure><p>这样就可以操作虚拟机了，当然也可以用其他第三方的连接工具。</p><p>默认登录进去的是 vagrant 用户。</p><p>所以执行有些命令的时候需要加 sudo，或者切换到 root 用户:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su root</span><br></pre></td></tr></table></figure><p>默认 root 用户的密码为：vagrant</p><h2 id="6-设置网络"><a href="#6-设置网络" class="headerlink" title="6.设置网络"></a>6.设置网络</h2><p>默认情况下，VirtualBox 使用的是网络地址转换和端口转发的方式实现了本地系统和虚拟机地址的问题，如下图所示。</p><p><img src="https://img-blog.csdnimg.cn/202004061746446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbnBlbmdmZWk1MjE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在实际使用过程中，对我们可能不太方便。</p><p>举个例子，比如我们的虚拟机中装了很多东西，比如 MySQL 数据库，Redis 等等，在虚拟机内部是没有问题的，MySQL 数据库的端口默认是 3306，虚拟机可能给我们映射出来的端口就可能不是 3306 了，这对于我们再本机器的进行测试是及其不方便的。</p><p>因此，我们不使用这种默认的方式，我们可以设置一个私有的 ip 实现本地系统和虚拟机系统之间的互通。</p><p>打开 cmd 输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig -a</span><br></pre></td></tr></table></figure><p>找到 VirtualBox 的虚拟网卡地址：</p><p>我的是：192.168.56.2</p><p>编辑 <strong>Vagrantfile</strong> 文件，找到如下一行，去掉注释并修改 ip 为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.vm.network &quot;private_network&quot;, ip: &quot;192.168.56.10&quot;</span><br></pre></td></tr></table></figure><p>其中 192.168.56 是固定的，10 也可以换成其他的，最大不要超过 255 就可以了！</p><p>重新加载配置文件，并重启 vagrant:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant reload</span><br></pre></td></tr></table></figure><p>启动完成后，本地系统和虚拟机之间相互 Ping ，如果没有问题，说明网络配置就好了！</p><p>例如，在虚拟机中 ping 本地的地址为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping 192.168.1.103</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2020040618555381.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbnBlbmdmZWk1MjE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>在本地 Ping 虚拟机的 ip (刚才配置文件中配置的那个 IP)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping 192.168.56.10</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200406185705163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbnBlbmdmZWk1MjE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>OK，这样算就是配置完成了！</p><p>今天的分享就到这里，如果对你有帮助，请给我点个赞，或者有任何问题都可以在评论区与我交流哦！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-下载安装-VirtualBox&quot;&gt;&lt;a href=&quot;#1-下载安装-VirtualBox&quot; class=&quot;headerlink&quot; title=&quot;1.下载安装 VirtualBox&quot;&gt;&lt;/a&gt;1.下载安装 VirtualBox&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.virtualbox.org/wiki/Downloads&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.virtualbox.org/wiki/Downloads&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;根据自己的操作系统类型下载安装即可！&lt;/p&gt;
&lt;p&gt;支持的操作系统类型有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Windows hosts&lt;/li&gt;
&lt;li&gt;OS X hosts&lt;/li&gt;
&lt;li&gt;Linux distributions&lt;/li&gt;
&lt;li&gt;Solaris hosts&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;温馨提示：如果是 Windows 系统用户，需要再 BIOS 中设置开启 CPU 虚拟化！！！&lt;/p&gt;
&lt;h2 id=&quot;2-下载安装-Vagrant&quot;&gt;&lt;a href=&quot;#2-下载安装-Vagrant&quot; class=&quot;headerlink&quot; title=&quot;2.下载安装 Vagrant&quot;&gt;&lt;/a&gt;2.下载安装 Vagrant&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.vagrantup.com/downloads.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.vagrantup.com/downloads.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;根据自己的操作系统类型下载安装即可！&lt;/p&gt;
&lt;p&gt;支持的操作系统类型有：&lt;/p&gt;
    
    </summary>
    
      <category term="JavaEE" scheme="https://www.vance.xin/categories/JavaEE/"/>
    
    
      <category term="CentOS7" scheme="https://www.vance.xin/tags/CentOS7/"/>
    
      <category term="vm" scheme="https://www.vance.xin/tags/vm/"/>
    
      <category term="Vagrant" scheme="https://www.vance.xin/tags/Vagrant/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7 安装 Docker（小白精简版）！！！</title>
    <link href="https://www.vance.xin/2020/04/06/CentOS7%20%E5%AE%89%E8%A3%85%20Docker%EF%BC%88%E5%B0%8F%E7%99%BD%E7%B2%BE%E7%AE%80%E7%89%88%EF%BC%89%EF%BC%81%EF%BC%81%EF%BC%81/"/>
    <id>https://www.vance.xin/2020/04/06/CentOS7 安装 Docker（小白精简版）！！！/</id>
    <published>2020-04-06T17:17:57.000Z</published>
    <updated>2024-05-12T05:02:43.596Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要参考 Docker 官方文档的安装为主，官方文档比较繁琐，而且是英文的，因此，我简化了安装的步骤，更适合小白安装。</p><p>官网：<a href="https://www.docker.com/" target="_blank" rel="noopener">https://www.docker.com/</a></p><h2 id="1-卸载旧版本"><a href="#1-卸载旧版本" class="headerlink" title="1.卸载旧版本"></a>1.卸载旧版本</h2><p>较旧的Docker版本称为docker或docker-engine。如果已安装这些程序，请卸载它们以及相关的依赖项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure><h2 id="2-使用存储库安装"><a href="#2-使用存储库安装" class="headerlink" title="2.使用存储库安装"></a>2.使用存储库安装</h2><p>在新主机上首次安装Docker Engine-Community之前，需要设置Docker存储库。之后，您可以从存储库安装和更新Docker。</p><h3 id="设置存储库"><a href="#设置存储库" class="headerlink" title="设置存储库"></a>设置存储库</h3><p>1.安装所需的软件包。yum-utils提供了yum-config-manager 效用，并device-mapper-persistent-data和lvm2由需要 devicemapper存储驱动程序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install -y yum-utils \</span><br><span class="line">  device-mapper-persistent-data \</span><br><span class="line">  lvm2</span><br></pre></td></tr></table></figure><p>2.使用以下命令来设置稳定的存储库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><h3 id="3-安装DOCKER-ENGINE-社区"><a href="#3-安装DOCKER-ENGINE-社区" class="headerlink" title="3.安装DOCKER ENGINE-社区"></a>3.安装DOCKER ENGINE-社区</h3><p>安装最新版本的Docker Engine-Community和containerd，或者转到下一步安装特定版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure><p>中间一路输入 y 确认回车即可！</p><p>安装完成后，启动Docker。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure><p>设置 Docker 开机自启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure><p>其他常用命令：</p><p>查看 docker 版本:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -v</span><br></pre></td></tr></table></figure></p><p>查看 docker 镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p>今天的分享就到这里，如果对你有帮助，请给我点个赞，或者有任何问题都可以在评论区与我交流哦！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要参考 Docker 官方文档的安装为主，官方文档比较繁琐，而且是英文的，因此，我简化了安装的步骤，更适合小白安装。&lt;/p&gt;
&lt;p&gt;官网：&lt;a href=&quot;https://www.docker.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.docker.com/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-卸载旧版本&quot;&gt;&lt;a href=&quot;#1-卸载旧版本&quot; class=&quot;headerlink&quot; title=&quot;1.卸载旧版本&quot;&gt;&lt;/a&gt;1.卸载旧版本&lt;/h2&gt;&lt;p&gt;较旧的Docker版本称为docker或docker-engine。如果已安装这些程序，请卸载它们以及相关的依赖项。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ sudo yum remove docker \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                  docker-client \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                  docker-client-latest \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                  docker-common \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                  docker-latest \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                  docker-latest-logrotate \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                  docker-logrotate \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                  docker-engine&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;2-使用存储库安装&quot;&gt;&lt;a href=&quot;#2-使用存储库安装&quot; class=&quot;headerlink&quot; title=&quot;2.使用存储库安装&quot;&gt;&lt;/a&gt;2.使用存储库安装&lt;/h2&gt;&lt;p&gt;在新主机上首次安装Docker Engine-Community之前，需要设置Docker存储库。之后，您可以从存储库安装和更新Docker。&lt;/p&gt;
&lt;h3 id=&quot;设置存储库&quot;&gt;&lt;a href=&quot;#设置存储库&quot; class=&quot;headerlink&quot; title=&quot;设置存储库&quot;&gt;&lt;/a&gt;设置存储库&lt;/h3&gt;&lt;p&gt;1.安装所需的软件包。yum-utils提供了yum-config-manager 效用，并device-mapper-persistent-data和lvm2由需要 devicemapper存储驱动程序。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ sudo yum install -y yum-utils \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  device-mapper-persistent-data \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  lvm2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JavaEE" scheme="https://www.vance.xin/categories/JavaEE/"/>
    
    
      <category term="Docker" scheme="https://www.vance.xin/tags/Docker/"/>
    
      <category term="CentOS7" scheme="https://www.vance.xin/tags/CentOS7/"/>
    
  </entry>
  
  <entry>
    <title>如何评价 iOS 微信深色模式丨第一视角体验分享</title>
    <link href="https://www.vance.xin/2020/03/28/%E5%A6%82%E4%BD%95%E8%AF%84%E4%BB%B7%20iOS%20%E5%BE%AE%E4%BF%A1%E6%B7%B1%E8%89%B2%E6%A8%A1%E5%BC%8F%E4%B8%A8%E7%AC%AC%E4%B8%80%E8%A7%86%E8%A7%92%E4%BD%93%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    <id>https://www.vance.xin/2020/03/28/如何评价 iOS 微信深色模式丨第一视角体验分享/</id>
    <published>2020-03-28T11:34:57.000Z</published>
    <updated>2024-05-12T05:02:43.596Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间，苹果要求微信支持 iOS13 的暗黑模式，否则会面临下架风险。</p><p>广大网友纷纷评论说，如果我要是微信我就和苹果硬刚，哈哈哈哈。。。</p><p>其实也不是谁强谁弱的问题，现在都是合作共赢的时代，相互都有利益上的关系，没办法，还是要妥协，只能根据苹果爸爸的要求改咯！</p><p>这不今天 iOS 版本的微信就更新了，支持了暗黑主题，还有一些小的优化和改进，我也都体验了下，很多地方还是适配的不是很好，有点影响用户体验。</p><p><img src="https://cdn.jsdelivr.net/gh/xinpengfei520/my-cloud-picture@master/IMG_2022/202210061614903.JPG" alt="1585365035" style="zoom:67%;"></p><p>如果不是程序员，可能会觉得支持暗黑模式不就换个字体颜色么？哪有那么复杂，其实我想说的是，还真比较复杂和麻烦。</p><p>要支持各种情况下的适配和用户体验问题，所以是比较麻烦的一件事。</p><p>另外，还更新了两个小功能：语音发送功能优化，和朋友圈跳到没看的位置。</p><p>先说第一个功能，用了下还是比较方便的，想发语音就发语音，想语音转文字就语音转文字。</p><p><img src="https://cdn.jsdelivr.net/gh/xinpengfei520/my-cloud-picture@master/IMG_2022/202210061614871.JPG" alt=""></p><p>对于不喜欢打字的人来说还是很方便的，可能有些人不知道，微信自己一直在做语音识别的技术，我感觉识别的正确率还是很高的。</p><p>再说下朋友圈跳转到上次没看的位置这个功能，现在的人大部分应该是朋友圈的重度用户，基本每一天都要刷的。</p><p><img src="https://cdn.jsdelivr.net/gh/xinpengfei520/my-cloud-picture@master/IMG_2022/202210061614946.JPG" alt=""></p><p>拿我来说，每天都必须要刷完，刷完的标志是，直到看到重复的内容为止。</p><p>有时候太忙，可能还没刷完就去干别的事了，过了一段时间后，再回来继续刷朋友圈。</p><p>当然你去干别的事的这段时间肯定是有好友发了新的朋友圈，你就这样一直往下刷，直到看到你刷过的内容。</p><p>因为还有你之前没有没有刷过的内容，通常的做法是快速向上滑，直到你刷到你没有看过的内容后继续刷。</p><p>不知道你们是不是也是这样的？</p><p>当有了这个功能之后就特别方便了，就相当于是微信给你在你看过的地方和没看过的地方打了一个标记。</p><p>点击标记就可以自动跳到你没有看的地方，一定程度上节约了时间，尤其是微信好友比较多的朋友。</p><p>我觉得这个功能真的很赞！</p><p>暗黑模式下，有的微信表情本来就是黑的，这就会导致发送的表情看不清楚，影响体验。</p><p>因为表情包大多都是网友或者第三方制作和提供的，微信也控制不了，所以表情包也要针对暗黑模式去做适配。</p><p>比如同一套表情包，应该有两种版本一种是正常模式下的，一种是暗黑模式下的，当你是暗黑模式下，就发送暗黑模式的表情包。</p><p>但是这个地方有个问题，比如你的微信是暗黑模式的，对方的微信是正常模式的，结果你发了一个暗黑模式下的表情包，结果对方看不清楚，这个问题是需要考虑的。</p><p>站在产品的角度，是不可能有两套表情包的，作为用户，每次发送之前还要根据是否是暗黑模式，去考虑应该用哪个表情包，这样太麻烦了，也不符合用户的使用习惯！</p><p>最好的办法是根据是否是暗黑模式去自动转换，或者是这种表情包不管是否是暗黑模式都能正常显示，这样是最好的。</p><p>这只是我自己的一些想法和猜测，微信肯定也会意识到这个问题的，相信后面也会去想办法解决的，毕竟是影响用户体验的问题。</p><p>如果你针对此次微信的更新有自己不同的想法，欢迎在评论区一起讨论！</p><p>科普一个小知识：</p><p>图四是微信钱包里面的账单页面，有的人可能会说，为什么不是黑色的页面？</p><p><img src="https://cdn.jsdelivr.net/gh/xinpengfei520/my-cloud-picture@master/IMG_2022/202210061614304.PNG" alt=""></p><p>这个问题问的好，它这个页面是 H5 页面，你可以理解成是网页，所以它是没办法做适配的，微信中加载的第三方网页链接也是一样的道理！</p><p>区别它是网页还是原生页面，之前没有暗黑模式的时候可以通过进度条来判断，大部分H5 页面在加载的时候都是可以通过是否有进度条就可以判断。</p><p>如果是安卓手机，可以打开手机的开发者选项 &gt; 显示布局边界，打开这个开关就可以了。</p><p>如果找不到开发者选项，因为默认情况下，这个功能是隐藏的，找到手机的的版本号，连续点击 5 次就可以开启，开启之后会有提示的。</p><p>打开微信的账单页面(看下图)，你会看到最顶部的 title 有红色的线条（专业的词叫布局边界），证明这个 title 是用原生写的，然后再看 title 下面的账单部分是没有红线的，说明它是网页。</p><p><img src="https://cdn.jsdelivr.net/gh/xinpengfei520/my-cloud-picture@master/IMG_2022/202210061614208.JPG" alt=""></p><p>这样就可以区分它是原生页面还是 H5 页面了，这种方法适用于安卓手机里的所有 App。</p><blockquote><p>另外，我还建了一个免费的知识星球，感兴趣的微信扫码即可加入！</p><p><img src="https://cdn.jsdelivr.net/gh/xinpengfei520/my-cloud-picture@master/IMG_2022/202210061615206.JPG" alt=""></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间，苹果要求微信支持 iOS13 的暗黑模式，否则会面临下架风险。&lt;/p&gt;
&lt;p&gt;广大网友纷纷评论说，如果我要是微信我就和苹果硬刚，哈哈哈哈。。。&lt;/p&gt;
&lt;p&gt;其实也不是谁强谁弱的问题，现在都是合作共赢的时代，相互都有利益上的关系，没办法，还是要妥协，只能根据苹果爸爸的要求改咯！&lt;/p&gt;
&lt;p&gt;这不今天 iOS 版本的微信就更新了，支持了暗黑主题，还有一些小的优化和改进，我也都体验了下，很多地方还是适配的不是很好，有点影响用户体验。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xinpengfei520/my-cloud-picture@master/IMG_2022/202210061614903.JPG&quot; alt=&quot;1585365035&quot; style=&quot;zoom:67%;&quot;&gt;&lt;/p&gt;
&lt;p&gt;如果不是程序员，可能会觉得支持暗黑模式不就换个字体颜色么？哪有那么复杂，其实我想说的是，还真比较复杂和麻烦。&lt;/p&gt;
&lt;p&gt;要支持各种情况下的适配和用户体验问题，所以是比较麻烦的一件事。&lt;/p&gt;
&lt;p&gt;另外，还更新了两个小功能：语音发送功能优化，和朋友圈跳到没看的位置。&lt;/p&gt;
&lt;p&gt;先说第一个功能，用了下还是比较方便的，想发语音就发语音，想语音转文字就语音转文字。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xinpengfei520/my-cloud-picture@master/IMG_2022/202210061614871.JPG&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="测评" scheme="https://www.vance.xin/categories/%E6%B5%8B%E8%AF%84/"/>
    
    
      <category term="微信" scheme="https://www.vance.xin/tags/%E5%BE%AE%E4%BF%A1/"/>
    
      <category term="深色模式" scheme="https://www.vance.xin/tags/%E6%B7%B1%E8%89%B2%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>程序员篇：不要把自己变成写代码的机器！</title>
    <link href="https://www.vance.xin/2020/03/22/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%AF%87%EF%BC%9A%E4%B8%8D%E8%A6%81%E6%8A%8A%E8%87%AA%E5%B7%B1%E5%8F%98%E6%88%90%E5%86%99%E4%BB%A3%E7%A0%81%E7%9A%84%E6%9C%BA%E5%99%A8%EF%BC%81/"/>
    <id>https://www.vance.xin/2020/03/22/程序员篇：不要把自己变成写代码的机器！/</id>
    <published>2020-03-22T14:20:58.000Z</published>
    <updated>2024-05-12T05:02:43.600Z</updated>
    
    <content type="html"><![CDATA[<p>看到这个标题你可能会想，程序员本来不就是写代码的么？</p><p>没错，程序员的主要工作就是写代码，或者说为了实现特定功能或者业务逻辑去写代码。</p><p>作为程序员，代码写得好，功能实现不就行了么？</p><p>这句话看似对，也不对。你品，你细细品！同样是写代码，但是写和写之间差多了。</p><p>初级程序员为了实现功能，更多的是复制粘贴，或者去找一些现成的轮子，这里并不是说复制粘贴不好，不要全部代码都复制粘贴，如果后面需求变了，你可能就束手无策了，要知其然知其所以然。</p><p>中级程序员会考虑如果把代码写的更好，会如何更好的封装代码，比如提高代码的复用性等，会去了解框架的一些原理，也可以根据需求去修改轮子。</p><p>高级程序员会去设计代码，写轮子。另外，还懂一些产品知识，会去了解和讨论需求，会思考这个需求解决了用户的什么问题？有没有解决用户的痛点？有没有更好的实现方式？用户体验怎么样？等等。</p><p>再往上，到了专家的级别，不仅要会架构，而且还要会写 PPT，各种软实力也是必须的，还要有全局观，要能站到更高的维度去思考问题，要有统筹全局的能力。</p><p>你看看，写代码之间的差别大了吧。</p><p>每次产品经理扔给你一个需求，你二话不说，一顿操作猛如虎，就干起来了，等你干完了，等到交付的时候，产品经理告诉你做的不对，应该是怎样怎样的，顿时你心里一万只草泥马奔腾而过。。。</p><p>这也不怪谁，因为每个人的理解能力不同，所以对于同一件事就会产生不同的理解，进而产生偏差。</p><p>当然这种情况是可以避免的，在拿到需求后，首先根据需求的描述，和产品经理一起确认下需求，具体怎么做呢？</p><p>按照自己对需求的理解，复述讲给产品经理听，然后产品经理边听边确认你的理解是否正确，如果有偏差，沟通讨论直到没有异议，经过这个过程后肯定是没有问题的。</p><p>然后再去根据需求去实现代码就 OK 了，如果开发过程中又有问题，那继续去找产品经理讨论沟通就行了。</p><p>最后，经过自己不懈努力地 coding，终于实现了功能，测试也通过了，高高兴兴的交付了，产品也上线了。</p><p>没过几天，产品经理找你说，前几天开发的这个功能要进行修改（需求变更），卧槽！心里又有一万只草泥马奔腾而过。。。</p><p>然后看了看自己的代码，发现前几天写的不能重用，还要大改，顿时感觉自己欲哭无泪，你说作为一个程序员咋就这么苦逼呢？</p><p>说实话，这种感觉我是深有体会的，不是被产品经理折磨，就是被产品经理折磨的路上，不是和产品经理撕逼，就是和产品经理撕逼的路上。</p><p>说实话，需求的变更是很正常的一件事，一个功能不可能永远不变，只要产品在更新迭代，需求就会一直有变更的可能。</p><p>所以，作为程序员不要去埋怨产品经理给你提的需求和需求变更，理论上讲，这种事情是会不间断一直发生的。</p><p>你要做的是，要想方设法去应对各种需求的变更，不管需求怎么变，我的代码都能够灵活应对，或者是尽可能少的改动就能实现了需求的变更。</p><p>这就要你从开始写代码之前就需要去考虑的问题，比如，怎么去设计自己的代码？提前假设下，如果后面需求有变化的时候该怎么办？等类似的问题。</p><p>这样做可以将问题进行前置，由被动应对改为提前主动预防应对，大大提升了代码应对需求变化的适应性。</p><p>虽然这样做前期可能花的时间稍微多一些，但是后面你会省去很多麻烦，节约很多时间，不要想着去返工，那样的效率真的很低，还增加了开发成本！</p><p>有时候，你也会碰见一些比较傻逼的产品经理（不懂产品），给你提的各种奇葩的需求，如果你也不是很懂产品的话，你很可能会被带到沟里去。</p><p>所以，在开发之前一定要先确认需求，去了解这个需求解决了用户的什么问题？这个需求是强需求还是弱需求？这些都要问清楚，不然到后面做完了才发现，费了九牛二虎之力开发的东西没有用，那就尴尬了！</p><p>遇到这种情况就要勇敢的怼回去，不要怕，这样可以避免很多不必要工作量，不是不想做，而是提的需求不合理，给你做毛线！</p><p>都知道我们程序员大多都比较憨厚老实，善良耿直，每天和机器打交道，培养了自己标准的线性思维模式，在程序员的的世界里，不是 true 就是 false。</p><p>有时候在遇到事情的时候，不会太变通，容易钻牛角尖，容易把自己绕进去出不来，所以，平时要和别人多交流，多打交道，变通去思考和解决问题。</p><p>大家都知道去年在网上流传的很火的一个视频，某个公司的产品经理要求程序员实现一个需求，要根据手机壳的颜色来实现 App 主题的变化，这个程序员听完之后就和产品经理打起来了。</p><p>假设当你们遇到这个需求的时候，你会怎么做？后来网上也出现了各种奇葩的解决方案，比如，手机壳的颜色会反射到眼睛里，然后手机再通过摄像头去进行眼睛虹膜识别出颜色，然后再设置主题色。等等还有很多比较新奇的答案。</p><p>我想说的是，大家的脑洞是真的大，真的是感觉眼界大开，眼前一亮的感觉。</p><p>这个问题说到底，其实还是思维方式的差异，程序员的思维方式是偏向于解决问题，怎样做才能实现这个功能？而产品经理更加关心的是这个功能的效果，不管你怎样去实现。</p><p>因此，换位思考是特别重要的，程序员冲动打人是不对的，不管什么需求，先去沟通，去了解，相信很多问题都是可以通过沟通去解决的。</p><p>就拿刚才那个需求来说（先不讨论这个需求解决了什么问题），你可能稍微变通一下就可以解决，用户肯定是知道自己手机壳的颜色的，当用户打开 App 的时候，可以让用户选择设置一下不就可以了吗？非要搞得那么复杂干嘛。</p><p>冲动是魔鬼！</p><p>对于程序员来说，敲代码重要，但是沟通技巧，产品思维，也同样重要，程序是为产品服务的，产品是为用户服务的。</p><p>作为程序员，要学会聪明地去敲代码，而不是把自己变成一个敲代码的机器！</p><p>希望能引起大家的思考，当然也欢迎大家在评论区一起学习讨论。</p><p>如果我上面写的文章中，有一到两点对你来说有帮助或者启发，我觉得就已经很开心了，如果你觉得我的文章写的不错，可以给我点个在看，如果你有什么问题，也可以在评论区给我留言。</p><p>如果您觉得我的文章对你有帮助，可不可以给我打赏一下，一块就好，对你来说可能一块钱没什么，但对于写作者来说，这个意义重大，它是坚持写作下去的动力，这样也能为读者持续不断的创造价值！</p><p>再次感谢我亲爱的读者朋友们！</p><p>另外，我还建了一个免费的知识星球，感兴趣的微信扫码即可加入！</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLngtc2lyLmNvbS96c3hxX3FyY29kZXpzeHFfcXJjb2RlLmpwZw?x-oss-process=image/format,png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看到这个标题你可能会想，程序员本来不就是写代码的么？&lt;/p&gt;
&lt;p&gt;没错，程序员的主要工作就是写代码，或者说为了实现特定功能或者业务逻辑去写代码。&lt;/p&gt;
&lt;p&gt;作为程序员，代码写得好，功能实现不就行了么？&lt;/p&gt;
&lt;p&gt;这句话看似对，也不对。你品，你细细品！同样是写代码，但是写和写之间差多了。&lt;/p&gt;
&lt;p&gt;初级程序员为了实现功能，更多的是复制粘贴，或者去找一些现成的轮子，这里并不是说复制粘贴不好，不要全部代码都复制粘贴，如果后面需求变了，你可能就束手无策了，要知其然知其所以然。&lt;/p&gt;
&lt;p&gt;中级程序员会考虑如果把代码写的更好，会如何更好的封装代码，比如提高代码的复用性等，会去了解框架的一些原理，也可以根据需求去修改轮子。&lt;/p&gt;
&lt;p&gt;高级程序员会去设计代码，写轮子。另外，还懂一些产品知识，会去了解和讨论需求，会思考这个需求解决了用户的什么问题？有没有解决用户的痛点？有没有更好的实现方式？用户体验怎么样？等等。&lt;/p&gt;
&lt;p&gt;再往上，到了专家的级别，不仅要会架构，而且还要会写 PPT，各种软实力也是必须的，还要有全局观，要能站到更高的维度去思考问题，要有统筹全局的能力。&lt;/p&gt;
&lt;p&gt;你看看，写代码之间的差别大了吧。&lt;/p&gt;
&lt;p&gt;每次产品经理扔给你一个需求，你二话不说，一顿操作猛如虎，就干起来了，等你干完了，等到交付的时候，产品经理告诉你做的不对，应该是怎样怎样的，顿时你心里一万只草泥马奔腾而过。。。&lt;/p&gt;
    
    </summary>
    
      <category term="程序员" scheme="https://www.vance.xin/categories/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
    
      <category term="个人提升" scheme="https://www.vance.xin/tags/%E4%B8%AA%E4%BA%BA%E6%8F%90%E5%8D%87/"/>
    
      <category term="编程" scheme="https://www.vance.xin/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="经验分享" scheme="https://www.vance.xin/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    
      <category term="程序员" scheme="https://www.vance.xin/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
  </entry>
  
  <entry>
    <title>迟到的 2019 年个人总结</title>
    <link href="https://www.vance.xin/2020/01/22/%E8%BF%9F%E5%88%B0%E7%9A%84%202019%20%E5%B9%B4%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    <id>https://www.vance.xin/2020/01/22/迟到的 2019 年个人总结/</id>
    <published>2020-01-22T23:47:57.000Z</published>
    <updated>2024-05-12T05:02:43.600Z</updated>
    
    <content type="html"><![CDATA[<p>2019 年已经过去十多天了，前段时间真的是太忙了，公司的各种事情，工作述职，年会节目等等，忙的手忙脚乱，一直计划着的个人年终总结一直推迟到现在才写，我觉得还是有必要记录一下的。</p><p>对去年的工作、生活和学习做一个简单的复盘，总结下自己有哪些成长，哪些方面做的还不是很好，不好的地方要多去反思和改进，好的地方要继续保持和优化，这样才能不断成长和提升。</p><p>2019 年也是我心态转变最大的一年，经历和遇到了许多事情，经过这些事情，感觉自己越来越沉稳了，想明白了自己最想要什么，什么才是对自己最重要的东西，并且要朝着自己想要的方向去努力，下面就通过几个方面来说说吧。</p><h2 id="1-工作"><a href="#1-工作" class="headerlink" title="1. 工作"></a>1. 工作</h2><p>站在现在来看，我算是比较幸运的，18 年找工作的时候，当时经历了创业公司的坑，所以一心想找一个大一点稳定的公司，现在看来我当时的选择是挺正确的，从 18 年底到现在，整个大环境和各个行业都不是景气，而我们的公司去年的效益也不是很好，但是没有裁员，比较稳定，工作上也比较顺心，相比那些被裁的朋友们，我算是比较幸运的！</p><p>去年伊始，首先被曝出的是几个大公司的裁员和一些小公司的倒闭，就我知道的身边的有好几个同学他们的公司就被裁员和解散了，还有的小公司工资也发不起了，这就直接损害到的直接利益了，这就太坑了，后来大家也都知道某东、渣易等一些头部公司的裁员事件。</p><p>相比公司来说，员工是弱势群体，尤其是我们的程序员群体，大多都比较老实憨厚，容易被公司损害自己的合法利益，我们要做得是当我们的利益被损害的时候我们要保护好自己，保留好证据，通过法律程序来帮助我们，遇到侵害时，要及时止损！</p><p>虽说有法律来保护我们，但是我们也不能完全依靠法律，一般走法律途径也是需要时间和精力的，一般处理时间比较长，我们也要考虑自己的时间成本，因此我们要不断提升自我保护的意识，这样才能最大程度保护自己的合法权益不被侵害。</p><p>公司是商业机构，是要赚钱的，职场上不要讲什么人情，当你的利益受到损害时，老板还给你讲什么人情或者画大饼，如果你还去相信，我只能说你 too young, too naive 了！</p><p>关于裁员说几点，被裁了也没关系，如果你能力很强，不管在什么时候都是不怕找不到工作的，就怕是那些没能力，整天上班划水的人，我只能说不裁你裁谁呀？</p><h2 id="2-学习"><a href="#2-学习" class="headerlink" title="2. 学习"></a>2. 学习</h2><p>专业技能方面，更多地是在偏向于大前端的学习，大前端的概念这两年也是特别火的一个话题，也是未来移动开发的一个趋势吧，利用闲余时间学习了公众号的开发和微信小程序开发试水，Android 方向主要是学习 Google 的组件化架构和 jetpack 的相关东西。</p><p>另外也坚持在开源社区贡献自己的代码，GitHub 上显示 350 contributions，主要是维护和更新自己的开源项目，star 也相比之前多了几十个。</p><p>另外，在业余时间学习了后台的一些东西，比如SpringMVC、nginx、MySQL 数据库，Maven、Swagger 等相关的知识，更新和迭代了自己的 Java 后台项目。</p><p>还利用闲余时间坚持学习英语，主要是提升自己的口语能力，先是报了一个 100 天的水滴阅读课程，坚持打卡了 100 天，累计阅读字数 88895 字，阅读了三本英语原著，分别是《小王子》、《爱丽丝梦游仙境》、《彼得潘》三本书，并成功领取了三本实体的书，此处给自己的坚持打 call。</p><p>另外，在去年 7 月份的时候买了一个英语课程，共花费了 11660 元，主要是偏向于生活交流和口语的提升，说实话，这个课程打破了我以前对英语学习的一些错误的认知，对我来说帮助还是挺大的。</p><p>当然不止是英语，还有其他方面的提升，这里也不建议所有人都花钱去学习英语，把钱花在当下你最需要提升的技能上，如果你工作了，有经济能力，那么另说，一次性花这么多钱买课程是比较贵的，但是，如果你把眼光放长远，平均下来也还好，我现在我也有经济能力去支付课程的费用，现在对我来说最重要的是时间，时间一旦错过了就再也没有了。记住，学习是对自己的投资，不是消费，花多少钱都是值得的。</p><h2 id="3-写作"><a href="#3-写作" class="headerlink" title="3. 写作"></a>3. 写作</h2><p>主要还是偏向于技术方面的文章比较多，CSND 上发表原创文章 19 篇，总访问量将近 45w，总排名挤进了 1w 名内，也新增了两个新的专栏「RxJava2.x教程」和「Android 自定义View」,2020 年计划计划再写 10 篇左右的高质量原创技术文章，进一步提升自己的影响力，目标是拿到「技术专家」的勋章！总阅读量到年底的时候冲击 80w 访问量，加油吧！！！</p><p>另外，公众号上也发表了 16 篇原创文章，公众号没有好好运营，更新周期也不固定，粉丝数量也不太多，分析原因主要是写作缺少动力，每次写文章至少要花费好几个小时，而且阅读量也不高，导致很难坚持下去。</p><p>我的公众号还有一个问题，就是方向不确定，各种类型的文章都有，有技术的，有产品的，有自己思考的，还有思维方面的，所以比较杂乱，刚开始是想着做一个垂直的细分领域的技术号（Android方向），后来发现市面上已经有很多大佬已经做起来了，我不管怎么做也是竞争不过他们的。</p><p>还有一个考量是，微信公众号不适合写技术文章，我指的是某一个具体的代码实现等，因为这不符合用户的使用场景，大多数人都是利用闲鱼时间、或者公交地铁上看文章，我问下你自己，你会完整的看一篇贴了代码的文章吗？</p><p>大多数人其实都是快速浏览一下，然后点个收藏就完事了，然后你上班的时候遇到问题，还不是去度娘或者 Google 搜索吗，你说是不是？你收藏的文章基本上也是就死躺在那里了，所以技术文更适合于像 CSDN 这种博客平台好一些，所以，我现在大部分的文章首先会发布到 CSDN 等平台上。</p><p>大家可能都对写作有一些误解，说自己没文采，没写作的技巧等等，如果你去问一些头部的大 V 们，他们会说：写作哪有那么多的技巧，谁还不是吭哧吭哧坚持写了好多年，到最后才会看到效果，当然也不排除一些天生的写作奇才，但是哪些人能有几个呢？</p><p>我们都是普通人，还是踏踏实实的一步一个脚印坚持下去吧。2020 年计划，确定好公众号的方向，有几个问题是需要我考虑的，你的目标用户是谁？在哪里？你能提供什么价值给他们？确定好了之后，好好写几篇精品文章，不要注重文章的数量，要提升文章的质量，输出更多高质量的原创文章，降低推送的频率，然后去引流、获客！</p><p>年中的时候和几个公众号号主进行了一个互推的活动，效果不是很好，现在很多公号都在商业互吹，说白了就是共享自己的读者，相互关注，导致最后关注来关注去，到最后关注的公众号特别多，我记得我最多的时候关注了有 500 多个公众号。</p><p>说实话，你经常看的公众号其实也就那么几个，关注的大多数公众号的文章质量不高，大量的文章推送，抬高了读者筛选信息的门槛，打扰了读者，这不是一件好事情，所以，还是要想办法去给读者创造价值，只有你的文章有价值了，你的读者也会对你有价值！</p><p>如果你的文章写的真心不错，读者早晚会知道的，写作的时候少点功利心，踏实认真写字，把你的能量附着在你的字里行间，帮助读者解决问题，传递价值，你的文字早晚会发光的。</p><p>如果你是做自媒体的，现在公众号已经过了红利期，如果放到几年前，还是有机会的，现在做起来真的是比较困难的，你也许会说，不是也有一些新的公众号主不是也做起来了吗？是的，有啊，我说的是对于大部分普通人来说，想做起来是很不容易的。</p><p>现在做起来的也是凤毛麟角，而且有的人之前本身在其他平台写了很多年，已经有一些影响力的，积累了一些忠实读者，并且已经有很深的文字功底在那放着，人家是有那个实力做起来的，比如「半佛仙人」，当然像半佛仙人这种能有几个呢？</p><p>像写作这种技能，短期是看不到什么效果的，如果长期坚持下去，是有复利效果的，这也是我为什么推荐大家坚持写作的原因，对于刚开始写作的人来说，你只要能把一件事情用通俗易懂的话讲明白、说清楚就行了，其实大多数人缺的不是写作的技巧，缺的是行动力！</p><p>另外，再说一点，为什么说公众号是自媒体创作的首选呢？虽说公众号已经过了红利期，但是微信的生态对于创作者来说是非常友好的，比如对于原创文章的保护机制，还有读者和创作者的订阅关系，也就是说只要用户关注了你的公众号，他就可以收到你推送的文章，还有后期的变现等，最近微信又邀请公测了公众号付费阅读功能，这对创作者来说是一大利好啊！</p><p>而有的平台是推荐机制，比如微博、头条系等，你写的文章是通过推荐算法推荐给读者的，文章的阅读量都是不稳定的，阅读量都是可以靠一些手段刷上去的，有时候你在某个平台上看到有的文章的阅读量是 10w+，甚至上百万+，其实这并不代表什么，光看这个数字是很虚的！</p><p>像头条系这种，做的是下沉的用户，各种用户群体都有，文章的总体质量是不高的，但是它的流量是巨大的，所以，你可以用各种方法将流量导流到你的公众号上，这样的用户才是你的真正的用户，这样后期也比较好运营和变现。</p><p>再说下知乎，现在知乎也没以前那么火了，主要是内容的质量参差不齐，鱼龙混杂，好多带节奏的文章和回答，广大网民的辨别能力又比较差，很容易被带节奏，有时候也还会碰见一些喷子，有一句怎么说来着，不是煞笔变多了，而是煞笔学会上网了，在全民互联网时代，你会碰见各种奇葩的人和事，见多了也就不足为怪了。</p><p>如果是做自媒体的，知乎还是占很大一部分流量的，知乎也是推荐算法规则的玩法，一个知乎账号的综合等级主要看三个方面：权重、盐值和各类的百分比构成。权重就是你在某个垂直领域内回答问题，发表文章，点赞，评论和喜欢等行为，你的账号的权重越高，你的回答更容易被推荐而获得流量，点赞排名越靠前，你的影响程度也越高。</p><p>另外再说一下回答问题，多回答知乎邀请你让你回答的问题，最好是一些高质量的回答，在回答中也可以带一些勾子，你也可以在文章中放一些勾子，将其引流到你的公众号中，别看这小小的勾子，如果运用好的话，长期下来也会给你带来不少关注的。</p><p>再来看下我运营的知识星球，官方数据如下：共有 262 条主题，获得赞同 503 次，球友近 200，这个数据不是去年的数据，而是自星球创建一来总的数据，相比来说，这样的数据还是比较惨的。</p><p>主要是没有好好运营，人数也比较少，大多都在潜水，没有一些机制让球友主动分享和交流，后面要多思考，激发球友的分享热情，另外也可以设置一些奖励的机制等等，比如被加精的好文给赞赏，或者设置类似于「生财有术」星球的龙珠的玩法等。</p><p>另外还更新了自己的个人网站，重新使用 HEXO 搭建了下，现在 UI 界面更加美观和简洁了，另外还做了 SEO，网站主要是同步更新自己写过的一些文章，访问量也不是很高，另外还对网站做了公安备案！</p><p>感兴趣的可以去看：<a href="https://www.x-sir.com，搭建教程：[点击此处查看](https://mp.weixin.qq.com/s/V28ehCI6ep8t0zVR4R5uJg)" target="_blank" rel="noopener">https://www.x-sir.com，搭建教程：[点击此处查看](https://mp.weixin.qq.com/s/V28ehCI6ep8t0zVR4R5uJg)</a></p><p>如果在搭建过程中有什么问题，也欢迎大家在评论区留言，或者在我的知识星球「IT大本营（限免）」中进行提问。</p><h2 id="4-理财"><a href="#4-理财" class="headerlink" title="4. 理财"></a>4. 理财</h2><p>18 年的时候接触了“屁兔屁“，当时都还是没问题的，国内相关的公司特别多，当时也投了一部分，都是投的几个月短期的，没有问题，后来又一部分投的是 1 年期的，自从 18 年底开始，各大“屁兔屁“公司开始暴雷，我当时就有点慌了，干着急没办法，没到期又取不出来，只能祈祷在到期之前希望公司不要被清查，眼看着一家一家公司倒下去，我投资的那个平台不知道能撑多久。</p><p>故事的结尾都是悲伤的，就在资金还有两个月到期的时候，我投资的这个公司也被清查了，清查的好突然，在行业中这个公司也是比较有影响力的上市公司，也被清查了，后来也报案了，警方也在处理，不过这个过程处理的时间很长，通常是需要 2-3 年时间的，不知道到时候能拿回多少，我也就不报太大的希望了。</p><p>通过这件事，也算是给自己买了一个教训吧，总结下来就是当时对“屁兔屁“的认知不足，导致了自己的经济损失，也算是一次自我成长吧，在生命的长河中，人总是要经历点什么，才会变成为一个皮实的人！</p><p>后来又学习了一些股票和基金的相关知识，学习是为了对这个事物有更加清醒的认识，这样才能适应这个社会，在社会上立足，我从来不会在公众场合推荐大家去炒股，对于大多数人来说，都是韭菜，股市中，10 个人炒股，8 个人亏，1 一个人平，1 一个人盈，你觉得你是哪个幸运的人吗？</p><p>对于大多数人来说，买指数基金就行了，或者定投，这样可以强制自己储蓄，基金定投比较灵活也不用考虑高点还是低点，长期的坚持会拉平你定投的高低点，也不用花时间去了解各种 K 线图，特别适合大部分的普通人，巴菲特也说过一句话：买一支指数基金，然后努力工作吧。</p><p>大多数人对理财是有误区的，理财的首要目的是保值，因为国内通货膨胀的缘故，我们要分配自己的资金，好多人都想着通过炒股来赚钱，这个观念是错误的，凡是都是想通过炒股去一夜暴富的人都是不想去努力，偷机的人，就算你凭运气暴富了，你也会凭实力亏掉的！因为你的思维认知是驾驭不了与你自身实力相匹配的金钱的！</p><p>可能有的人对“屁兔屁“和基金股票之间的区别不太清楚，我这里就给大家简单讲下吧，“屁兔屁“严格来说是不合法的，资金不受国家监管，其实做的是表面合法，暗地里非法的生意，基金和股票是国家专门监管的，有严格的管理，所以，你的资金是不会有风险的，当然也就不存在跑路的情况。</p><p>去年 2 月份的时候接触了且慢，跟着 E 大投了长赢计划，通过这个计划，期间经历了钻石坑，一直坚持到了现在，目前收益还可以，中间真的是特别煎熬的，因为中国的股市是一个熊长牛短的过程，大部分的情况下你都是出于熊市的，真的挺磨炼人的心态，我很佩服 E 大的投资理念，真的是太理性了，特别喜欢他说的一句话：踏踏实实的，多大点事儿！</p><p>且慢的产品还是特别适合大部分上班族的，不需要太多的时间，就能理财，也不需要学习复杂的投资技巧，定投或者跟投就可以了，我这里也不推荐大家，自己去权衡吧，不一定适合所有人。</p><h2 id="5-消费"><a href="#5-消费" class="headerlink" title="5. 消费"></a>5. 消费</h2><p>今年最大的一笔开销是买了一部 iPhone Xs，这也算是今年的最大一笔消费吧，我是从 16 年开始用的 iPhone 手机，当时买的是 iPhone 6s，一直用到 19 年，用了 3 年多，现在感觉回不去了。</p><p>买 iPhone 倒不如说是买 iOS 系统，说实话 iPhone 系统的产品体验是非常好的，还有在安全性方面也是让人很放心的，大家都吐槽说它太封闭了，我认为正是因为它的封闭，才能保证产品的质量和用户的体验！</p><p>我的消费理念是，每天高频使用的东西，就是要买好的贵的，比如手机、电脑、电动牙刷等，这些东西不仅能提升你的效率，给你更好的用户体验，还能提升生活的品质，而且它也不是易耗品，买了之后你可以至少用个几年都没问题的。</p><h2 id="6-健身"><a href="#6-健身" class="headerlink" title="6. 健身"></a>6. 健身</h2><p>去年 3 月份的时候报了一个健身房，开始健身之旅，这也是我第一次报健身房，现在这个年龄，感觉身体是越来越重要了，尤其是现在的年轻人都是办公室上班，平时的运动量都比较少，因此我觉得如果条件允许报一个还是很有必须要的，为了身体健康，花多少钱都是值得的。</p><p>刚开始进健身房的时候，真的是一脸雾水，各种器械都不会用，只能是看着别人然后模仿着训练，回来后，在网上找一些视频学习，但是还是没有一个人指导自己，很容易把动作做错，也体会不到发力点，所以后来报了私教课，让教练一对一的辅导。</p><p>刚开始学的时候的动作必须是要做到位，否则错误的动作可能会导致一些反作用，比如你想练胸，结果臂越来越粗，这种钱的话我也觉得是有很必要花的，一旦学会了各种锻炼的方式方法，还有器械的使用，你后面就可以自己练习了，或者你找一个认识的人带带你也是可以的。</p><p>教练的作用就是给你传授一些锻炼的方式方法和督促的作用，主要还是要靠你自己，在这健身的期间，也学习到了很多健身的知识，比如饮食方面、健身的补充剂，注意事项等等，还有一些健身的误区，拉伸的技巧等。</p><p>锻炼了几个月，明显感觉到了身体的变化，但是健身是一个长期坚持的事情，一旦停下来，身体就会回到原来的状态了，贵在坚持吧。</p><p>我一般会习惯性的把每次健身的数据记录到 Keep 上，到目前为止，keep 显示跑步的数据为 267 km，健身 816 min，行走 1032 km，累计 494 day，总运动时长 21670 分钟，等级升到了 KG.9，这个数据不是去年的数据，是总数据，总的来说相比之前健身的时间更多了，2020 年继续抽出更多的时间去健身。</p><p>健身不仅让你的身体的体型体态会变的更好，也能锻炼你的意志力，也能提升你的自信，让你变的更年轻有活力，皮肤也会变好的，只有你的身体变强壮了，才能更好的工作和生活！何乐而不为呢？</p><h2 id="7-社交"><a href="#7-社交" class="headerlink" title="7. 社交"></a>7. 社交</h2><p>去年参加的社交活动比较少，平时也比较宅，其实我不是宅，我是不喜欢没有意义的社交活动，如果是我喜欢的，我还是比较喜欢出去浪的。</p><p>2020 年努力提升自己，希望多认识一些行业大佬，多交流或者线下面基，参加更多的社交活动，认识更多的牛人，其实这也算是结识人脉的一种方式吧，随着你年龄的增长，你会发现人脉越来越重要，说不定以后会帮到你，如果你可以提供价值，也是可以帮到别人的。</p><p>在信息高速发展的今天，很多人都是在网上聊，但是网上和线下是不一样的，有些话只能在线下见面说，有一句话怎么说来着：网上聊千遍，不如线下见一面。</p><h2 id="8-跨界学习"><a href="#8-跨界学习" class="headerlink" title="8. 跨界学习"></a>8. 跨界学习</h2><p>去年利用闲余时间学习了销售、心理学、公众演讲、性格、两性关系、潜意识、执行力等相关内容的学习，说真的，学到了不少东西。</p><p>为什么要学销售？大家可能对销售这个词的理解比较狭隘，它不仅仅是我们通常理解的卖东西，其实生活中的好多东西都是可以看做是销售的，比如，你找工作去面试，也可以看成是销售，你自己就是产品，公司就是目标客户，面试说白了就是你要想方设法把自己销售出去。</p><p>如果你要卖一个东西，你要先了解顾客的需求，可以通过简单的提问去了解顾客的真实的需求，而不是一上来就介绍你们的产品多好多好，很多时候你说的其实不是顾客真正想要的，真正的销售是你要引导顾客多说，你自己少说。</p><p>你要先了解顾客的心理，其实这又涉及到了心理学的相关知识，更严格的词叫做销售心理学，当你把握住了很多点的时候，然后你再去进行推销你的产品，这样才能更容易的达成成交！</p><p>现在的顾客都不傻，防备心都比较重，如果你不停的说，会让顾客很烦的，顾客一旦烦了，你的东西基本上是卖不出的，销售不是本文的重点，如果你们对销售感兴趣的话，我后面给大家写一篇很详细的文章。</p><p>大家对销售可能还有一个误区就是，销售是针对某个产品和领域的，其实不是，销售的技巧是通用的，不管是销售什么产品，都是可以灵活运用和切换的，当你学会了销售的套路了，不管什么东西你都是可以卖的。</p><p>我们再来看下公众演讲，首先给大家抛一个问题：为什么要会公众演讲呢？举个栗子，假设有两个销售人员，一个会公众演讲，一个不会，同样销售能力下，你觉得哪个销售人员的成交量更高一些？</p><p>答案肯定是显而易见了，如果你在一个 100 人的场合进行公众演讲，然后销售你的产品，假设成交率是 10%，也就是说成交了 10 个人，如果不会公众演讲的销售人员，它的平均成交是每天 1 个人，那么，公众演讲销售带来的成交相当于是普通销售员 10 天的成交人数，假设公众演讲的人数是 1000 人呢？然后再按年计算，每年平均讲 100 场，结果不用算了，是很恐怖的，至少是普通销售员的上百倍了。</p><p>这里我把它总结为：公众演讲 + 销售，销售只是一个具体的技能，也可以换成其他的技能，万能公式是：公众演讲 + ？，因此我觉得公众演讲也是一个非常重要的技能，当然不是每一个人都适合公众演讲的。</p><p>如果感兴趣的话可以尝试着去学习下，但是肯定是需要大量反复去练习的，你还要有强大的控场能力，幽默，还有随机应变的能力，一般来说，活跃型的人比较适合做演讲。</p><p>再来说下性格吧，我学习的是四象限的性格模型，有活跃型、能力型、完善型和平稳型四种，其实每个人一出生，性格都已经定了。</p><p>你从小孩的哭声就基本能判断出他是什么性格了，比如有的小孩就是特别喜欢哭和闹，那么他基本就是属于活跃型性格了，有的小孩特别安静、哭几声哄一哄立马就不哭了，那么大概率这个小孩是平稳型或者完善型的性格。</p><p>活跃型的人外向、多言者、乐观，大声、引人注意，好动、数字不敏感、健忘、先张嘴后思考、热情、说话喜欢夸张，情感与身心表现：天真、善变、心宽体胖，不生气，不记仇、外向情感型，对别人无所谓，对自己也无所谓。</p><p>能力型的人天生自信、权威、控制、好争论，坚持己见、好斗、义气、正直，生活在目标中，注重方向轻细节，急性子，有主见，行动力强，对别人要求严格，对自己无所谓。</p><p>完善型的人天生内向、思考着，悲观，表象与社交关键词：严肃、得体、礼貌、矛盾、紧张，先思考后发言，敏感，交友慎重，生活上整洁有条理，作息比较规律。情感与身心：生活在自己的内心感受里，消极，忧虑，消瘦，习惯计划，但常常难以行动，认真、理性，情绪化，内向情感型，对别人要求严格，对自己也要求严格。</p><p>平稳型的性格是天生的内向旁观者，悲观，平和、缓慢不愿引人注意，善良、幽默，能不开头尽量不开口，难以决定、好领导。生活在平静中，健康、冷静、太弱自然，有耐心，知足常乐，情感丰富、不露声色。对别人不要求，对自己不苛求！</p><p>其实，每个人都不止一种性格，每种性格所占的比例是不一样的，占比最高的就是你的主导性格，比如你完善型的性格占 70%，活跃型和能力型各站 15%，那么你的主导性格就是完善型。</p><p>你可以对照着上面的一些关键词来判断自己属于哪种性格，你可以判断其他人，当你了解了性格之后，然后戴着性格的眼睛去了解他人，和他人打交道，这样沟通和交流起来就比较容易了，他的很多行为你也就很容易理解了。</p><p>再说说两性关系吧，因为男女思维方式的差异，导致男生和女生思考问题的方式和角度是不一样的，因此，同一件事情思考不同，所关注的点不同，就会产生矛盾或者不和，其实这个不是谁对谁错的问题，女生一般考虑问题都是比较感性的，而男生的话都是比较理性和直接的，偏向于解决问题，而女生更注重感受或者是体验，是非理性的。</p><p>在遇到问题的时候，要多站到对方的角度去思考，所以你要先了解男女的思维上的差异，这样也就更能理解对方的一些行为了，还要多沟通，多交流，当你们敞开心扉把问题都说出了，其实问题也就迎刃而解了，最怕的是两个人都不说，谁都不低头，相互猜忌，导致最后变得很糟糕，作为男生就要主动一点，承担起责任，一起去解决问题！</p><p>情商也是非常重要的，同样一件事，情商高的人会让人觉得很舒服，包括两性关系也是如此，每个人都有自己的生活方式，每个人都有选择自己想要的生活的权利，不要试图要求或者强加对方，把对方变成自己想要的样子，可能最终的结果就是，Ta 再也不是当初的那个 Ta 了！</p><p>其实，情商也是分等级的，低阶情商是照顾他人的情绪，高阶情商是，传递价值，照顾他人的利益，首先要要学会控制自己的情绪，然后去察觉和影响他人，不要眼里只有自己，多替他人想一步，情商比智商更重要！</p><h2 id="9-旅行"><a href="#9-旅行" class="headerlink" title="9. 旅行"></a>9. 旅行</h2><p>很遗憾去年基本没出去玩过，都是在上海周边溜达了下，其实心里想去的地方还是很多的，比如成都、云南、厦门、三亚等，国外的话想去泰国、新加坡。从来没有出过国，一想到出过旅行，还是比较期待和激动的。</p><p>去年也已经办好了护照，也在网上了解了一些游玩的攻略，现在就等一个美好的时机了，趁着年轻多出去走走，看看别国的风土人情，会让你有不一样的感受的，世界那么大，我想去看看，期待 2020 年有机会看到最美的风景！</p><h2 id="10-2020-计划"><a href="#10-2020-计划" class="headerlink" title="10. 2020 计划"></a>10. 2020 计划</h2><p>①.学着做几个可口美味的菜，作为一个新时代的男性，要十八般武艺都会，不然很难在这个社会上立足，也是为了以后成家立业后，能给喜欢的人做一顿丰盛美味的拿手好菜，有一句话是这么说的，要想抓住 Ta 的人，首先要抓住 Ta 的味蕾。</p><p>②.英语口语练习，继续加强自己的练习，多学习，多积累，持续行动，到年底的时候尽量能达到脱口而出的程度，能和老外进行最基本的日常交流。</p><p>③.多读书、多旅行，多提升自己的内在，做一个内心强大的男人，努力让自己发光，你若盛开，蝴蝶自来。</p><p>④.多赚钱！多赚钱！多赚钱！重要的事情说三遍！没有一份工作是可以干一辈子的，靠死工资也是不会暴富的！尤其是程序员这个职业，行业普遍都认为是 35 岁危机，因此要提前做职业规划，发展第二职业也是非常有必要的。</p><p>其实，我很早之前就关注这方面了，前期主要是学习和积累的阶段，计划在今年进行各种尝试，发展几个自己的副业，目前比较好的方向和趋势有：社交电商、短视频领域，短视频尤其是以抖音为首的平台，现在的流量是非常巨大的，财报显示，字节跳动公司 2019 年营收超 1400 亿元，其中抖音至少贡献了一半的营收。</p><p>由短视频衍生出来的有短视频相关的工具，还有短视频的剪辑和后期的处理，还有拍摄制作等等，都是需要专业的人才的，以后的机会还是比较多的，随着 5G 越来越普及，短视频会越来越普遍的，大家发朋友圈可能都是以图片为主，以后可能人人都能随手发一个制作精美的视频了。</p><p>这个市场是非常巨大的，说实话，现在做短视频的人很多，但是能做起来的不多，不要一股脑子，一头扎进去，瞎忙活，我觉得前期还是要多学习一些头部号，多模仿，多分析火的视频为什么会火？要多站到消费者的角度去理解，多尝试、多总结。</p><p>现在实体行业越来越不好做了，主要是太重了，前期都要投入好多的资金进去，投进去之后也不知道什么时候才能回本，存在很大的风险，还有各种运营的成本都是比较高的，所以特别不好做。</p><p>这两年流行轻资产创业，轻资产创业就是产品越轻越好，投入越少越好，你可能只需要一台电脑、一部手机就可以了，基本没有什么投入，唯一投入的就是你的时间成本，而这种时间成本都是有复利效应的，就看你能把你的时间卖出多少份了，卖的份数越多，赚的越多！</p><p>另外，选择也是非常重要的，要借助平台的势能将自己的技能放大，尤其是一些新出来的高速发展的平台，比如拼夕夕，小红书等等。</p><p>最近 B 站又火了，大家都比较看好，都说 B 站有可能成为未来中国的 youtube，我知道的几个小伙伴 B 站的粉丝量都已经一两万了，有的小伙伴做的就是搬运工，从 youtube 把一些视频搬过来，都已经做的很不错了！</p><p>拼夕夕今年的市值也已经超过了京东，从以前大家骂他卖假货到去年的百亿补贴活动，品牌形象不断升级，现在大家通过补贴优惠买到东西的都说：真香！</p><p>大家还吐槽它的售后差，说实话，我之前也买过一个东西，退货确实挺麻烦的，时间也长，我相信后面会越来越好的，毕竟它还年轻，给它点时间成长。</p><p>⑤.最后，感谢 2019 的那些经历，让我成长，2020 继续加油干！！！</p><p>好了，我的个人总结就写完了，断断续续写了好多天，终于写完了，文章比较长，能看到最后的都是忠实的读者，给你们点赞！</p><p>标题虽说是个人总结，你读完了会发现，也不仅仅是，中间也有我的一些思考，和未来一些趋势的判断，希望对你们有价值！</p><p>因为每个人的阅历和知识储备都不一样，文章中有一些比较专业的词汇，如果不理解或者不懂的，可以打开维基百科查阅和学习。</p><p>如果我上面写的文章中，有一到两点对你来说有帮助或者启发，我觉得就已经很开心了，如果你觉得我的文章写的不错，可以给我点个在看，如果你有什么问题，也可以在评论区给我留言。</p><p>如果您觉得我的文章对你有帮助，可不可以给我打赏一下，一块就好，对你来说可能一块钱没什么，但对于写作者来说，这个意义重大，它是坚持写作下去的动力，这样也能为读者持续不断的创造价值！</p><p>这可能是我年前的最后一次推送了，首先再这里祝大家新年快了，心想事成！为了感谢读者朋友们长期对我的支持，我在读者朋友中，抽取 66 个幸运儿，奖励红包作为福利，获取方式：公众号后台回复“新年快乐”，长按小程序码即可抽奖！</p><p>再次感谢我亲爱的读者朋友们！</p><p>另外，我还建了一个免费的知识星球，感兴趣的微信扫码即可加入！</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLngtc2lyLmNvbS96c3hxX3FyY29kZXpzeHFfcXJjb2RlLmpwZw?x-oss-process=image/format,png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2019 年已经过去十多天了，前段时间真的是太忙了，公司的各种事情，工作述职，年会节目等等，忙的手忙脚乱，一直计划着的个人年终总结一直推迟到现在才写，我觉得还是有必要记录一下的。&lt;/p&gt;
&lt;p&gt;对去年的工作、生活和学习做一个简单的复盘，总结下自己有哪些成长，哪些方面做的还不是很好，不好的地方要多去反思和改进，好的地方要继续保持和优化，这样才能不断成长和提升。&lt;/p&gt;
&lt;p&gt;2019 年也是我心态转变最大的一年，经历和遇到了许多事情，经过这些事情，感觉自己越来越沉稳了，想明白了自己最想要什么，什么才是对自己最重要的东西，并且要朝着自己想要的方向去努力，下面就通过几个方面来说说吧。&lt;/p&gt;
&lt;h2 id=&quot;1-工作&quot;&gt;&lt;a href=&quot;#1-工作&quot; class=&quot;headerlink&quot; title=&quot;1. 工作&quot;&gt;&lt;/a&gt;1. 工作&lt;/h2&gt;&lt;p&gt;站在现在来看，我算是比较幸运的，18 年找工作的时候，当时经历了创业公司的坑，所以一心想找一个大一点稳定的公司，现在看来我当时的选择是挺正确的，从 18 年底到现在，整个大环境和各个行业都不是景气，而我们的公司去年的效益也不是很好，但是没有裁员，比较稳定，工作上也比较顺心，相比那些被裁的朋友们，我算是比较幸运的！&lt;/p&gt;
&lt;p&gt;去年伊始，首先被曝出的是几个大公司的裁员和一些小公司的倒闭，就我知道的身边的有好几个同学他们的公司就被裁员和解散了，还有的小公司工资也发不起了，这就直接损害到的直接利益了，这就太坑了，后来大家也都知道某东、渣易等一些头部公司的裁员事件。&lt;/p&gt;
&lt;p&gt;相比公司来说，员工是弱势群体，尤其是我们的程序员群体，大多都比较老实憨厚，容易被公司损害自己的合法利益，我们要做得是当我们的利益被损害的时候我们要保护好自己，保留好证据，通过法律程序来帮助我们，遇到侵害时，要及时止损！&lt;/p&gt;
&lt;p&gt;虽说有法律来保护我们，但是我们也不能完全依靠法律，一般走法律途径也是需要时间和精力的，一般处理时间比较长，我们也要考虑自己的时间成本，因此我们要不断提升自我保护的意识，这样才能最大程度保护自己的合法权益不被侵害。&lt;/p&gt;
&lt;p&gt;公司是商业机构，是要赚钱的，职场上不要讲什么人情，当你的利益受到损害时，老板还给你讲什么人情或者画大饼，如果你还去相信，我只能说你 too young, too naive 了！&lt;/p&gt;
&lt;p&gt;关于裁员说几点，被裁了也没关系，如果你能力很强，不管在什么时候都是不怕找不到工作的，就怕是那些没能力，整天上班划水的人，我只能说不裁你裁谁呀？&lt;/p&gt;
    
    </summary>
    
      <category term="程序员" scheme="https://www.vance.xin/categories/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
    
      <category term="个人提升" scheme="https://www.vance.xin/tags/%E4%B8%AA%E4%BA%BA%E6%8F%90%E5%8D%87/"/>
    
      <category term="程序员" scheme="https://www.vance.xin/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="写作" scheme="https://www.vance.xin/tags/%E5%86%99%E4%BD%9C/"/>
    
      <category term="个人总结" scheme="https://www.vance.xin/tags/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
      <category term="年终总结" scheme="https://www.vance.xin/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Android 自定义一个简单的刮奖 View</title>
    <link href="https://www.vance.xin/2019/09/18/Android%20%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%88%AE%E5%A5%96%20View/"/>
    <id>https://www.vance.xin/2019/09/18/Android 自定义一个简单的刮奖 View/</id>
    <published>2019-09-18T13:40:05.000Z</published>
    <updated>2024-05-12T05:02:43.596Z</updated>
    
    <content type="html"><![CDATA[<p>实现思路：</p><p>使用相对布局，先写一个 TextView，然后自定义一个 EraseView，写一个同样大小的 EraseView 覆盖在 TextView 上面即可。</p><p>先看下效果图:</p><p><img src="https://img-blog.csdnimg.cn/20190918133340585.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbnBlbmdmZWk1MjE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>代码也比较简单，我就直接贴上了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">public class EraseView extends View &#123;</span><br><span class="line"></span><br><span class="line">    private boolean isMove = false;</span><br><span class="line">    private Bitmap bitmap = null;</span><br><span class="line">    private Bitmap frontBitmap = null;</span><br><span class="line">    private Path path;</span><br><span class="line">    private Canvas mCanvas;</span><br><span class="line">    private Paint paint;</span><br><span class="line"></span><br><span class="line">    public EraseView(Context context) &#123;</span><br><span class="line">        this(context, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public EraseView(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        this(context, attrs, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public EraseView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">        super(context, attrs, defStyleAttr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">        super.onDraw(canvas);</span><br><span class="line">        if (mCanvas == null) &#123;</span><br><span class="line">            createEraseBitmap();</span><br><span class="line">        &#125;</span><br><span class="line">        canvas.drawBitmap(bitmap, 0, 0, null);</span><br><span class="line">        mCanvas.drawPath(path, paint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void createEraseBitmap() &#123;</span><br><span class="line">        bitmap = Bitmap.createBitmap(getWidth(), getHeight(), Config.ARGB_4444);</span><br><span class="line">        frontBitmap = createBitmap(Color.GRAY, getWidth(), getHeight());</span><br><span class="line"></span><br><span class="line">        paint = new Paint();</span><br><span class="line">        paint.setStyle(Paint.Style.STROKE);</span><br><span class="line">        paint.setXfermode(new PorterDuffXfermode(Mode.CLEAR));</span><br><span class="line">        paint.setAntiAlias(true);</span><br><span class="line">        paint.setDither(true);</span><br><span class="line">        paint.setStrokeJoin(Paint.Join.ROUND);</span><br><span class="line">        paint.setStrokeCap(Paint.Cap.ROUND);</span><br><span class="line">        paint.setStrokeWidth(60);</span><br><span class="line"></span><br><span class="line">        path = new Path();</span><br><span class="line"></span><br><span class="line">        mCanvas = new Canvas(bitmap);</span><br><span class="line">        mCanvas.drawBitmap(frontBitmap, 0, 0, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        float ax = event.getX();</span><br><span class="line">        float ay = event.getY();</span><br><span class="line"></span><br><span class="line">        if (event.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            isMove = false;</span><br><span class="line">            path.reset();</span><br><span class="line">            path.moveTo(ax, ay);</span><br><span class="line">            invalidate();</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else if (event.getAction() == MotionEvent.ACTION_MOVE) &#123;</span><br><span class="line">            isMove = true;</span><br><span class="line">            path.lineTo(ax, ay);</span><br><span class="line">            invalidate();</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return super.onTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Bitmap createBitmap(int color, int width, int height) &#123;</span><br><span class="line">        int[] rgb = new int[width * height];</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; rgb.length; i++) &#123;</span><br><span class="line">            rgb[i] = color;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return Bitmap.createBitmap(rgb, width, height, Config.ARGB_8888);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，今天的分享就到这里了。</p><p>最后，我这边有个技术交流群，平常我会分享一些学习资源到群里，还可以和大家一起交流学习，需要的朋友可以扫描下面的二维码加我微信并备注「加群」，拉你进入技术交流群！</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLngtc2lyLmNvbS9Gb2lFem5ZRjVlU1FTOFdNTjYyTnpVUTRnazQw?x-oss-process=image/format,png# =337x448" alt=""></p><p>飞哥带你去装逼，一直装逼到天黑！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实现思路：&lt;/p&gt;
&lt;p&gt;使用相对布局，先写一个 TextView，然后自定义一个 EraseView，写一个同样大小的 EraseView 覆盖在 TextView 上面即可。&lt;/p&gt;
&lt;p&gt;先看下效果图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190918133340585.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbnBlbmdmZWk1MjE=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
&lt;p&gt;代码也比较简单，我就直接贴上了：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public class EraseView extends View &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private boolean isMove = false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private Bitmap bitmap = null;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private Bitmap frontBitmap = null;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private Path path;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private Canvas mCanvas;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    private Paint paint;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public EraseView(Context context) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this(context, null);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public EraseView(Context context, AttributeSet attrs) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        this(context, attrs, 0);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public EraseView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        super(context, attrs, defStyleAttr);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @Override&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    protected void onDraw(Canvas canvas) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        super.onDraw(canvas);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (mCanvas == null) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            createEraseBitmap();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        canvas.drawBitmap(bitmap, 0, 0, null);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mCanvas.drawPath(path, paint);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public void createEraseBitmap() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        bitmap = Bitmap.createBitmap(getWidth(), getHeight(), Config.ARGB_4444);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        frontBitmap = createBitmap(Color.GRAY, getWidth(), getHeight());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        paint = new Paint();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        paint.setStyle(Paint.Style.STROKE);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        paint.setXfermode(new PorterDuffXfermode(Mode.CLEAR));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        paint.setAntiAlias(true);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        paint.setDither(true);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        paint.setStrokeJoin(Paint.Join.ROUND);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        paint.setStrokeCap(Paint.Cap.ROUND);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        paint.setStrokeWidth(60);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        path = new Path();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mCanvas = new Canvas(bitmap);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mCanvas.drawBitmap(frontBitmap, 0, 0, null);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    @Override&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public boolean onTouchEvent(MotionEvent event) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        float ax = event.getX();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        float ay = event.getY();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        if (event.getAction() == MotionEvent.ACTION_DOWN) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            isMove = false;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            path.reset();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            path.moveTo(ax, ay);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            invalidate();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return true;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; else if (event.getAction() == MotionEvent.ACTION_MOVE) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            isMove = true;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            path.lineTo(ax, ay);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            invalidate();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return true;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return super.onTouchEvent(event);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    public Bitmap createBitmap(int color, int width, int height) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        int[] rgb = new int[width * height];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for (int i = 0; i &amp;lt; rgb.length; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            rgb[i] = color;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        return Bitmap.createBitmap(rgb, width, height, Config.ARGB_8888);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;好了，今天的分享就到这里了。&lt;/p&gt;
&lt;p&gt;最后，我这边有个技术交流群，平常我会分享一些学习资源到群里，还可以和大家一起交流学习，需要的朋友可以扫描下面的二维码加我微信并备注「加群」，拉你进入技术交流群！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLngtc2lyLmNvbS9Gb2lFem5ZRjVlU1FTOFdNTjYyTnpVUTRnazQw?x-oss-process=image/format,png# =337x448&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;飞哥带你去装逼，一直装逼到天黑！&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://www.vance.xin/categories/Android/"/>
    
    
      <category term="自定义View" scheme="https://www.vance.xin/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="CustomView" scheme="https://www.vance.xin/tags/CustomView/"/>
    
      <category term="刮奖" scheme="https://www.vance.xin/tags/%E5%88%AE%E5%A5%96/"/>
    
  </entry>
  
  <entry>
    <title>Maven 项目集成 Swagger2</title>
    <link href="https://www.vance.xin/2019/07/13/Maven%20%E9%A1%B9%E7%9B%AE%E9%9B%86%E6%88%90%20Swagger2/"/>
    <id>https://www.vance.xin/2019/07/13/Maven 项目集成 Swagger2/</id>
    <published>2019-07-13T16:12:00.000Z</published>
    <updated>2024-05-12T05:02:43.596Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLngtc2lyLmNvbS9GZ2Q3cXZzN3l6UjcxRTdobWdJc2xVc1lPdVQ5" alt=""><br>题图：来自飞哥的图片工厂</p><p>音乐推荐：背叛<br>文丨IT大飞说<br>预计阅读时间：3.2 分钟</p><p>哈喽，朋友们，今天我们来学习下如何使用 Swagger2。</p><h2 id="什么是-Swagger"><a href="#什么是-Swagger" class="headerlink" title="什么是 Swagger?"></a>什么是 Swagger?</h2><p>Swagger 是一款 RESTFUL 接口的、基于YAML、JSON语言的文档在线自动生成、代码自动生成的工具。</p><h2 id="如何集成？"><a href="#如何集成？" class="headerlink" title="如何集成？"></a>如何集成？</h2><p>打开 pom.xml 文件，添加如下依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>注：编写本文时使用的最新版本是 2.9.2，当你看到这篇文章的时候可能会有更新，最新的版本可到 <a href="https://mvnrepository.com" target="_blank" rel="noopener">https://mvnrepository.com</a> 查看。</p><p>新建一个 Swagger2 类，完整代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableSwagger2 // 启用 Swagger</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class Swagger2 &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Docket createRestApi() &#123;</span><br><span class="line">        return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                // 为当前包路径</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(&quot;com.xpf.imoney&quot;))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 构建 api 文档的详细信息函数，注意这里的注解引用的是哪个</span><br><span class="line">     */</span><br><span class="line">    private ApiInfo apiInfo() &#123;</span><br><span class="line">        return new ApiInfoBuilder()</span><br><span class="line">                // 页面标题</span><br><span class="line">                .title(&quot;SSM Application [iMoney] Swagger2 RESTFul API&quot;)</span><br><span class="line">                // 创建人</span><br><span class="line">                .contact(new Contact(&quot;x-sir&quot;, &quot;http://www.x-sir.com&quot;, &quot;542270559@qq.com&quot;))</span><br><span class="line">                // 版本号</span><br><span class="line">                .version(&quot;1.0&quot;)</span><br><span class="line">                // 描述</span><br><span class="line">                .description(&quot;This is [iMoney] API doc&quot;)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后编译并启动你本地的服务，打开浏览器，输入下面的访问地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/JavaWeb/swagger-ui.html</span><br></pre></td></tr></table></figure><p>注：上面链接中的 JavaWeb 为你的项目名称，替换为你自己的！</p><p>正常情况下你就会看到下面的页面了：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLngtc2lyLmNvbS9GbDQ2b2p3cHY4d1hETXV1a3gyRjdDY0xmNjAt" alt=""></p><h2 id="Swagger-的几个常用注解"><a href="#Swagger-的几个常用注解" class="headerlink" title="Swagger 的几个常用注解"></a>Swagger 的几个常用注解</h2><ul><li>@Api：表示这个类是 Swagger 的资源；</li><li>@ApiOperation：用在方法上，说明方法的作用；</li><li>@ApiParam：用来修饰参数，表示对参数添加元数据；</li><li>@ApiModel：用于类，对类进行说明；</li><li>@ApiIgnore：用于类，方法，表示这个类或方法被忽略；</li><li>@ApiImplicitParam：用于方法，表示单独的请求参数；</li></ul><p>举个例子，我们的 UserController 中的简单使用，完整代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Api(value = &quot;/user&quot;, description = &quot;关于用户的一些操做。&quot;)</span><br><span class="line">@Controller</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private UserService userService;</span><br><span class="line"></span><br><span class="line">    @ResponseBody</span><br><span class="line">    @RequestMapping(value = &quot;/index&quot;)</span><br><span class="line">    @ApiOperation(value = &quot;通过 ID 查询 USER 信息&quot;, httpMethod = &quot;GET&quot;, notes = &quot;暂无&quot;)</span><br><span class="line">    public User index(@RequestParam(&quot;id&quot;) int id) &#123;</span><br><span class="line">        return userService.getUserById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本的用法就这些，好了，今天的分享就到这里了。</p><p>最后，我这边有个技术交流群，平常我会分享一些学习资源到群里，还可以和大家一起交流学习，需要的朋友可以扫描下面的二维码加我微信并备注「加群」，拉你进入技术交流群！</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLngtc2lyLmNvbS9Gb2lFem5ZRjVlU1FTOFdNTjYyTnpVUTRnazQw# =337x448" alt=""></p><p>飞哥带你去装逼，一直装逼到天黑！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLngtc2lyLmNvbS9GZ2Q3cXZzN3l6UjcxRTdobWdJc2xVc1lPdVQ5&quot; alt&gt;&lt;br&gt;题图：来自飞哥的图片工厂&lt;/p&gt;
&lt;p&gt;音乐推荐：背叛&lt;br&gt;文丨IT大飞说&lt;br&gt;预计阅读时间：3.2 分钟&lt;/p&gt;
&lt;p&gt;哈喽，朋友们，今天我们来学习下如何使用 Swagger2。&lt;/p&gt;
&lt;h2 id=&quot;什么是-Swagger&quot;&gt;&lt;a href=&quot;#什么是-Swagger&quot; class=&quot;headerlink&quot; title=&quot;什么是 Swagger?&quot;&gt;&lt;/a&gt;什么是 Swagger?&lt;/h2&gt;&lt;p&gt;Swagger 是一款 RESTFUL 接口的、基于YAML、JSON语言的文档在线自动生成、代码自动生成的工具。&lt;/p&gt;
&lt;h2 id=&quot;如何集成？&quot;&gt;&lt;a href=&quot;#如何集成？&quot; class=&quot;headerlink&quot; title=&quot;如何集成？&quot;&gt;&lt;/a&gt;如何集成？&lt;/h2&gt;&lt;p&gt;打开 pom.xml 文件，添加如下依赖：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;artifactId&amp;gt;springfox-swagger2&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;version&amp;gt;2.9.2&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;groupId&amp;gt;io.springfox&amp;lt;/groupId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;artifactId&amp;gt;springfox-swagger-ui&amp;lt;/artifactId&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;lt;version&amp;gt;2.9.2&amp;lt;/version&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/dependency&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;注：编写本文时使用的最新版本是 2.9.2，当你看到这篇文章的时候可能会有更新，最新的版本可到 &lt;a href=&quot;https://mvnrepository.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://mvnrepository.com&lt;/a&gt; 查看。&lt;/p&gt;
&lt;p&gt;新建一个 Swagger2 类，完整代码如下：&lt;/p&gt;
    
    </summary>
    
      <category term="JavaEE" scheme="https://www.vance.xin/categories/JavaEE/"/>
    
    
      <category term="Maven" scheme="https://www.vance.xin/tags/Maven/"/>
    
      <category term="Swagger" scheme="https://www.vance.xin/tags/Swagger/"/>
    
      <category term="Swagger2" scheme="https://www.vance.xin/tags/Swagger2/"/>
    
      <category term="Spring" scheme="https://www.vance.xin/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>RxJava2.x 操作符之 compose</title>
    <link href="https://www.vance.xin/2019/06/20/RxJava2.x%20%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B9%8B%20compose/"/>
    <id>https://www.vance.xin/2019/06/20/RxJava2.x 操作符之 compose/</id>
    <published>2019-06-20T20:03:01.000Z</published>
    <updated>2024-05-12T05:02:43.596Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/xinpengfei520/my-cloud-picture@master/IMG_2022/202210061613868.png" alt=""><br>题图：来自飞哥的图片工厂</p><p>音乐推荐：后来<br>文丨IT大飞说<br>预计阅读时间：2.3 分钟</p><p>哈喽，朋友们，之前我们学习了一些 RxJava2.x 的常用操作符，今天我们来继续学习一下 RxJava 的 compose 操作符。</p><p>compose 操作符能够从数据流中得到原始的被观察者，当创建被观察者时，compose 操作符会立即执行，而不像其他的操作符需要在 onNext() 调用后才能执行。</p><h2 id="使用场景一"><a href="#使用场景一" class="headerlink" title="使用场景一"></a>使用场景一</h2><p>我们可以用 compose 操作符来进行线程的切换，一般用在网络请求的地方。</p><p>原始的写法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.subscribeOn(Schedulers.io())</span><br><span class="line">.observeOn(AndroidSchedulers.mainThread())</span><br></pre></td></tr></table></figure><p>我们可以将上面的操作封装成一个简单的工具类来使用，我这里提供了 Java 版和 Kotlin 版本：</p><p>Java 版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import io.reactivex.FlowableTransformer;</span><br><span class="line">import io.reactivex.MaybeTransformer;</span><br><span class="line">import io.reactivex.ObservableTransformer;</span><br><span class="line">import io.reactivex.android.schedulers.AndroidSchedulers;</span><br><span class="line">import io.reactivex.schedulers.Schedulers;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by x-sir on 2019/4/19 :)</span><br><span class="line"> * Function:线程调度</span><br><span class="line"> */</span><br><span class="line">public class RxThreadUtils &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Flowable 切换到主线程</span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; FlowableTransformer&lt;T, T&gt; flowableToMain() &#123;</span><br><span class="line">        return upstream -&gt; upstream.subscribeOn(Schedulers.io())</span><br><span class="line">                .observeOn(AndroidSchedulers.mainThread());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Observable 切换到主线程</span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; ObservableTransformer&lt;T, T&gt; observableToMain() &#123;</span><br><span class="line">        return upstream -&gt; upstream.subscribeOn(Schedulers.io())</span><br><span class="line">                .observeOn(AndroidSchedulers.mainThread());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Maybe 切换到主线程</span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; MaybeTransformer&lt;T, T&gt; maybeToMain() &#123;</span><br><span class="line">        return upstream -&gt; upstream.subscribeOn(Schedulers.io())</span><br><span class="line">                .observeOn(AndroidSchedulers.mainThread());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kotlin 版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import io.reactivex.FlowableTransformer</span><br><span class="line">import io.reactivex.MaybeTransformer</span><br><span class="line">import io.reactivex.ObservableTransformer</span><br><span class="line">import io.reactivex.android.schedulers.AndroidSchedulers</span><br><span class="line">import io.reactivex.schedulers.Schedulers</span><br><span class="line">import java.util.concurrent.TimeUnit</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by x-sir on 2019-06-02 :)</span><br><span class="line"> * Function:RxJava2.x 线程切换工具类</span><br><span class="line"> */</span><br><span class="line">object RxThreadUtils &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Observable 切换到主线程</span><br><span class="line">     */</span><br><span class="line">    fun &lt;T&gt; observableToMain(): ObservableTransformer&lt;T, T&gt; &#123;</span><br><span class="line">        return ObservableTransformer &#123; upstream -&gt;</span><br><span class="line">            upstream.subscribeOn(Schedulers.io())</span><br><span class="line">                    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Flowable 切换到主线程</span><br><span class="line">     */</span><br><span class="line">    fun &lt;T&gt; flowableToMain(): FlowableTransformer&lt;T, T&gt; &#123;</span><br><span class="line">        return FlowableTransformer &#123; upstream -&gt;</span><br><span class="line">            upstream.subscribeOn(Schedulers.io())</span><br><span class="line">                    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Maybe 切换到主线程</span><br><span class="line">     */</span><br><span class="line">    fun &lt;T&gt; maybeToMain(): MaybeTransformer&lt;T, T&gt; &#123;</span><br><span class="line">        return MaybeTransformer &#123; upstream -&gt;</span><br><span class="line">            upstream.subscribeOn(Schedulers.io())</span><br><span class="line">                    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用起来也比较简单，我们在网络请求的时候就可以这样调用（假设网络请求返回的是Flowable 对象）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.compose(RxThreadUtils.flowableToMain())</span><br></pre></td></tr></table></figure><h2 id="使用场景二"><a href="#使用场景二" class="headerlink" title="使用场景二"></a>使用场景二</h2><p>compose 操作符可以和 Transformer 结合使用，一方面可以让代码看起来更加简洁，另一方面能够提高代码的复用性，因为 RxJava 提倡链式调用，我们可以合理的使用 compose 操作符来防止链式调用被打破。</p><p>RxLifecycle 是 trello 开源的一个配置 RxJava 使用的开源库，我们知道 RxJava 有个缺点就是会导致内存泄露，此时，RxLifecycle 横空出世了，它可以配合 RxJava 一起使用，可以有效防止内存泄漏发生，使用起来也是非常方便，举个简单的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myObservable</span><br><span class="line">    .compose(RxLifecycle.bind(lifecycle))</span><br><span class="line">    .subscribe();</span><br></pre></td></tr></table></figure><p>RxLifecycle 不在文本的讲解范围内，更多详细使用可看 GitHub 介绍：</p><p><a href="https://github.com/trello/RxLifecycle" target="_blank" rel="noopener">https://github.com/trello/RxLifecycle</a></p><p>另外，知乎也开源了一个 RxLifecycle 库，使用起来也是比较方便的，感兴趣的可以看看：</p><p><a href="https://github.com/zhihu/RxLifecycle" target="_blank" rel="noopener">https://github.com/zhihu/RxLifecycle</a></p><p>好了，今天的分享就到这里了。</p><p>飞哥带你去装逼，一直装逼到天黑！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xinpengfei520/my-cloud-picture@master/IMG_2022/202210061613868.png&quot; alt&gt;&lt;br&gt;题图：来自飞哥的图片工厂&lt;/p&gt;
&lt;p&gt;音乐推荐：后来&lt;br&gt;文丨IT大飞说&lt;br&gt;预计阅读时间：2.3 分钟&lt;/p&gt;
&lt;p&gt;哈喽，朋友们，之前我们学习了一些 RxJava2.x 的常用操作符，今天我们来继续学习一下 RxJava 的 compose 操作符。&lt;/p&gt;
&lt;p&gt;compose 操作符能够从数据流中得到原始的被观察者，当创建被观察者时，compose 操作符会立即执行，而不像其他的操作符需要在 onNext() 调用后才能执行。&lt;/p&gt;
&lt;h2 id=&quot;使用场景一&quot;&gt;&lt;a href=&quot;#使用场景一&quot; class=&quot;headerlink&quot; title=&quot;使用场景一&quot;&gt;&lt;/a&gt;使用场景一&lt;/h2&gt;&lt;p&gt;我们可以用 compose 操作符来进行线程的切换，一般用在网络请求的地方。&lt;/p&gt;
&lt;p&gt;原始的写法为：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;.subscribeOn(Schedulers.io())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.observeOn(AndroidSchedulers.mainThread())&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们可以将上面的操作封装成一个简单的工具类来使用，我这里提供了 Java 版和 Kotlin 版本：&lt;/p&gt;
&lt;p&gt;Java 版本：&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://www.vance.xin/categories/Android/"/>
    
    
      <category term="RxJava" scheme="https://www.vance.xin/tags/RxJava/"/>
    
      <category term="RxJava2.x" scheme="https://www.vance.xin/tags/RxJava2-x/"/>
    
      <category term="操作符" scheme="https://www.vance.xin/tags/%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    
      <category term="compose" scheme="https://www.vance.xin/tags/compose/"/>
    
  </entry>
  
  <entry>
    <title>RxJava2.x 常用操作符列表</title>
    <link href="https://www.vance.xin/2019/06/10/RxJava2.x%20%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%88%97%E8%A1%A8/"/>
    <id>https://www.vance.xin/2019/06/10/RxJava2.x 常用操作符列表/</id>
    <published>2019-06-10T21:48:00.000Z</published>
    <updated>2024-05-12T05:02:43.596Z</updated>
    
    <content type="html"><![CDATA[<ul><li>All：判断 Observable 发射的所有的数据项是否都满足某个条件；</li><li>Amb：给定多个 Observable，只让第一个发射数据的 Observable 发射全部数据；</li><li>And/Then/When：通过模式（And条件）和计划（Then次序）组合两个或多个 Observable 发射的数据集；</li><li>Average：计算 Observable发射的数据序列的平均值，然后发射这个结果；</li><li>Buffer：缓存，可以简单理解为缓存，它定期从 Observable 收集数据到一个集合，然后把这些数据集合打包发射，而不是一次发射一个；</li><li>Catch：捕获，继续序列操作，将错误替换为正常的数据，从 onError 通知中恢复；</li><li>CombineLatest：当两个 Observables 中的任何一个发射了一个数据时，通过一个指定的函数组合每个 Observable 发射的最新数据（一共两个数据），然后发射这个函数的结果；</li><li>Concat：不交错地连接多个 Observable 的数据；</li><li>Connect：指示一个可连接的 Observable 开始发射数据给订阅者；</li><li>Contains：判断 Observable 是否会发射一个指定的数据项；</li><li>Count：计算 Observable 发射的数据个数，然后发射这个结果；</li><li>Create：通过调用观察者的方法从头创建一个 Observable；</li><li>Debounce：只有在空闲了一段时间后才发射数据，简单来说，就是如果一段时间没有操作，就执行一次操作；</li><li>DefaultIfEmpty：发射来自原始 Observable 的数据，如果原始 Observable 没有发射数据，就发射一个默认数据；</li><li>Defer：在观察者订阅之前不创建这个 Observable，为每一个观察者创建一个新的 Observable；</li><li>Delay：延迟一段时间发射结果数据；</li><li>Distinct：去重，过滤掉重复数据项；</li><li>Do：注册一个动作占用一些 Observable 的生命周期事件，相当于 Mock 某个操作；</li><li>Materialize/Dematerialize：将发射的数据和通知都当作数据发射，或者反过来；</li><li>ElementAt：取值，取特定位置的数据项；</li><li>Empty/Never/Throw：创建行为受限的特殊 Observable；</li><li>Filter：过滤，过滤掉没有通过谓词测试的数据项，只发射通过测试的</li><li>First：首项，只发射满足条件的第一条数据；</li><li>flatMap：扁平映射，将 Observable 发射的数据转换为 Observables 集合，然后将这些 Observable 发射的数据平坦化地放进一个单独的 Observable，可以认为是一个将嵌套的数据结构展开的过程；</li><li>From：将其他对象或数据结构转换为 Observable；</li><li>GroupBy：分组，将原来的 Observable 拆分为 Observable 集合，将原始 Observable 发射的数据按 Key 分组，每一个 Observable 发射一组不同的数据；</li><li>IgnoreElements：忽略所有的数据，只保留终止通知(onError 或 onCompleted)；</li><li>Interval：创建一个定时发射整数序列的 Observable；</li><li>Join：无论何时，如果一个 Observable 发射了一个数据项，只要在另一个 Observable 发射的数据项定义的时间窗口内，就将两个 Observable 发射的数据合并发射；</li><li>Just：将对象或者对象集合转换为一个会发射这些对象的 Observable；</li><li>Last：末项，只发射最后一条数据；</li><li>Map：映射，对序列的每一项都应用一个函数变换 Observable 发射的数据，实质是对序列中的每一项执行一个函数，函数的参数就是这个数据项；</li><li>Max：计算并发射数据序列的最大值；</li><li>Merge：将两个 Observable 发射的数据组合并成一个；</li><li>Min：计算并发射数据序列的最小值；</li><li>ObserveOn：指定观察者观察 Observable 的调度程序（工作线程）；</li><li>Publish：将一个普通的 Observable 转换为可连接的；</li><li>Range：创建发射指定范围的整数序列的 Observable；</li><li>Reduce：按顺序对数据序列的每一项数据应用某个函数，然后返回这个值；</li><li>RefCount：使一个可连接的 Observable 表现得像一个普通的 Observable；</li><li>Repeat：创建重复发射特定的数据或数据序列的 Observable；</li><li>Replay：确保所有的观察者收到同样的数据序列，即使他们在 Observable 开始发射数据之后才订阅；</li><li>Retry：重试，如果 Observable 发射了一个错误通知，重新订阅它，期待它正常终止辅助操作；</li><li>Sample：取样，定期发射最新的数据，等同于数据抽样，有的实现中叫作 ThrottleFirst；</li><li>Scan：扫描，对 Observable 发射的每一项数据应用一个函数，然后按顺序依次发射这些值；</li><li>SequenceEqual：判断两个 Observable 是否按相同的数据序列；</li><li>Serialize：强制 Observable 按次序发射数据并且功能是有效的；</li><li>Skip：跳过前面的若干项数据；</li><li>SkipLast：跳过后面的若干项数据；</li><li>SkipUntil：丢弃原始 Observable 发射的数据，直到第二个 Observable 发射了一个数据，然后发射原始 Observable 的剩余数据；</li><li>SkipWhile：丢弃原始Observable发射的数据，直到一个特定的条件为假，然后发射原始 Observable 剩余的数据；</li><li>Start：创建发射一个函数返回值的 Observable；</li><li>StartWith：在发射原来的 Observable 的数据序列之前，先发射一个指定的数据序列或数据项；</li><li>Subscribe：收到 Observable 发射的数据和通知后执行的操作；</li><li>SubscribeOn：指定 Observable 应该在哪个调度程序上执行；</li><li>Sum：计算并发射数据序列的和；</li><li>Switch：将一个发射 Observable 序列的 Observable 转换为这样一个 Observable，即它逐个发射那些 Observable 最近发射的数据；</li><li>Take：只保留前面的若干项数据；</li><li>TakeLast：只保留后面的若干项数据；</li><li>TakeUntil：发射来自原始 Observable 的数据，直到第二个 Observable 发射了一个数据或一个通知；</li><li>TakeWhile：发射原始 Observable 的数据，直到一个特定的条件为真，然后跳过剩余的数据；</li><li>TimeInterval：将一个 Observable 转换为发射两个数据之间所耗费时间的 Observable；</li><li>Timeout：添加超时机制，如果过了指定的一段时间没有发射数据，就发射一个错误通知；</li><li>Timer：创建在一个指定的延迟之后发射单个数据的 Observable；</li><li>Timestamp：给 Observable 发射的每个数据项添加一个时间戳；</li><li>To：将 Observable 转换为其他对象或数据结构；</li><li>Using：创建一个只在 Observable 生命周期内存在的一次性资源；</li><li>Window：窗口，定期将来自 Observable 的数据拆分成一些 Observable 窗口，然后发射这些窗口，而不是每次发射一项；类似于 Buffer，但 Buffer 发射的是数据，Window 发射的是 Observable，每一个 Observable 发射原始 Observable 数据的一个子集；</li><li>Zip：打包，使用一个指定的函数将多个 Observable 发射的数据组合在一起，然后将这个函数的结果作为单项数据发射；</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;All：判断 Observable 发射的所有的数据项是否都满足某个条件；&lt;/li&gt;
&lt;li&gt;Amb：给定多个 Observable，只让第一个发射数据的 Observable 发射全部数据；&lt;/li&gt;
&lt;li&gt;And/Then/When：通过模式（And条件）和计划（Then次序）组合两个或多个 Observable 发射的数据集；&lt;/li&gt;
&lt;li&gt;Average：计算 Observable发射的数据序列的平均值，然后发射这个结果；&lt;/li&gt;
&lt;li&gt;Buffer：缓存，可以简单理解为缓存，它定期从 Observable 收集数据到一个集合，然后把这些数据集合打包发射，而不是一次发射一个；&lt;/li&gt;
&lt;li&gt;Catch：捕获，继续序列操作，将错误替换为正常的数据，从 onError 通知中恢复；&lt;/li&gt;
&lt;li&gt;CombineLatest：当两个 Observables 中的任何一个发射了一个数据时，通过一个指定的函数组合每个 Observable 发射的最新数据（一共两个数据），然后发射这个函数的结果；&lt;/li&gt;
&lt;li&gt;Concat：不交错地连接多个 Observable 的数据；&lt;/li&gt;
&lt;li&gt;Connect：指示一个可连接的 Observable 开始发射数据给订阅者；&lt;/li&gt;
&lt;li&gt;Contains：判断 Observable 是否会发射一个指定的数据项；&lt;/li&gt;
&lt;li&gt;Count：计算 Observable 发射的数据个数，然后发射这个结果；&lt;/li&gt;
&lt;li&gt;Create：通过调用观察者的方法从头创建一个 Observable；&lt;/li&gt;
&lt;li&gt;Debounce：只有在空闲了一段时间后才发射数据，简单来说，就是如果一段时间没有操作，就执行一次操作；&lt;/li&gt;
&lt;li&gt;DefaultIfEmpty：发射来自原始 Observable 的数据，如果原始 Observable 没有发射数据，就发射一个默认数据；&lt;/li&gt;
&lt;li&gt;Defer：在观察者订阅之前不创建这个 Observable，为每一个观察者创建一个新的 Observable；&lt;/li&gt;
&lt;li&gt;Delay：延迟一段时间发射结果数据；&lt;/li&gt;
&lt;li&gt;Distinct：去重，过滤掉重复数据项；&lt;/li&gt;
&lt;li&gt;Do：注册一个动作占用一些 Observable 的生命周期事件，相当于 Mock 某个操作；&lt;/li&gt;
&lt;li&gt;Materialize/Dematerialize：将发射的数据和通知都当作数据发射，或者反过来；&lt;/li&gt;
&lt;li&gt;ElementAt：取值，取特定位置的数据项；&lt;/li&gt;
&lt;li&gt;Empty/Never/Throw：创建行为受限的特殊 Observable；&lt;/li&gt;
&lt;li&gt;Filter：过滤，过滤掉没有通过谓词测试的数据项，只发射通过测试的&lt;/li&gt;
&lt;li&gt;First：首项，只发射满足条件的第一条数据；&lt;/li&gt;
&lt;li&gt;flatMap：扁平映射，将 Observable 发射的数据转换为 Observables 集合，然后将这些 Observable 发射的数据平坦化地放进一个单独的 Observable，可以认为是一个将嵌套的数据结构展开的过程；&lt;/li&gt;
&lt;li&gt;From：将其他对象或数据结构转换为 Observable；&lt;/li&gt;
&lt;li&gt;GroupBy：分组，将原来的 Observable 拆分为 Observable 集合，将原始 Observable 发射的数据按 Key 分组，每一个 Observable 发射一组不同的数据；&lt;/li&gt;
&lt;li&gt;IgnoreElements：忽略所有的数据，只保留终止通知(onError 或 onCompleted)；&lt;/li&gt;
&lt;li&gt;Interval：创建一个定时发射整数序列的 Observable；&lt;/li&gt;
&lt;li&gt;Join：无论何时，如果一个 Observable 发射了一个数据项，只要在另一个 Observable 发射的数据项定义的时间窗口内，就将两个 Observable 发射的数据合并发射；&lt;/li&gt;
&lt;li&gt;Just：将对象或者对象集合转换为一个会发射这些对象的 Observable；&lt;/li&gt;
&lt;li&gt;Last：末项，只发射最后一条数据；&lt;/li&gt;
&lt;li&gt;Map：映射，对序列的每一项都应用一个函数变换 Observable 发射的数据，实质是对序列中的每一项执行一个函数，函数的参数就是这个数据项；&lt;/li&gt;
&lt;li&gt;Max：计算并发射数据序列的最大值；&lt;/li&gt;
&lt;li&gt;Merge：将两个 Observable 发射的数据组合并成一个；&lt;/li&gt;
&lt;li&gt;Min：计算并发射数据序列的最小值；&lt;/li&gt;
&lt;li&gt;ObserveOn：指定观察者观察 Observable 的调度程序（工作线程）；&lt;/li&gt;
&lt;li&gt;Publish：将一个普通的 Observable 转换为可连接的；&lt;/li&gt;
&lt;li&gt;Range：创建发射指定范围的整数序列的 Observable；&lt;/li&gt;
&lt;li&gt;Reduce：按顺序对数据序列的每一项数据应用某个函数，然后返回这个值；&lt;/li&gt;
&lt;li&gt;RefCount：使一个可连接的 Observable 表现得像一个普通的 Observable；&lt;/li&gt;
&lt;li&gt;Repeat：创建重复发射特定的数据或数据序列的 Observable；&lt;/li&gt;
&lt;li&gt;Replay：确保所有的观察者收到同样的数据序列，即使他们在 Observable 开始发射数据之后才订阅；&lt;/li&gt;
&lt;li&gt;Retry：重试，如果 Observable 发射了一个错误通知，重新订阅它，期待它正常终止辅助操作；&lt;/li&gt;
&lt;li&gt;Sample：取样，定期发射最新的数据，等同于数据抽样，有的实现中叫作 ThrottleFirst；&lt;/li&gt;
&lt;li&gt;Scan：扫描，对 Observable 发射的每一项数据应用一个函数，然后按顺序依次发射这些值；&lt;/li&gt;
&lt;li&gt;SequenceEqual：判断两个 Observable 是否按相同的数据序列；&lt;/li&gt;
&lt;li&gt;Serialize：强制 Observable 按次序发射数据并且功能是有效的；&lt;/li&gt;
&lt;li&gt;Skip：跳过前面的若干项数据；&lt;/li&gt;
&lt;li&gt;SkipLast：跳过后面的若干项数据；&lt;/li&gt;
&lt;li&gt;SkipUntil：丢弃原始 Observable 发射的数据，直到第二个 Observable 发射了一个数据，然后发射原始 Observable 的剩余数据；&lt;/li&gt;
&lt;li&gt;SkipWhile：丢弃原始Observable发射的数据，直到一个特定的条件为假，然后发射原始 Observable 剩余的数据；&lt;/li&gt;
&lt;li&gt;Start：创建发射一个函数返回值的 Observable；&lt;/li&gt;
&lt;li&gt;StartWith：在发射原来的 Observable 的数据序列之前，先发射一个指定的数据序列或数据项；&lt;/li&gt;
&lt;li&gt;Subscribe：收到 Observable 发射的数据和通知后执行的操作；&lt;/li&gt;
&lt;li&gt;SubscribeOn：指定 Observable 应该在哪个调度程序上执行；&lt;/li&gt;
&lt;li&gt;Sum：计算并发射数据序列的和；&lt;/li&gt;
&lt;li&gt;Switch：将一个发射 Observable 序列的 Observable 转换为这样一个 Observable，即它逐个发射那些 Observable 最近发射的数据；&lt;/li&gt;
&lt;li&gt;Take：只保留前面的若干项数据；&lt;/li&gt;
&lt;li&gt;TakeLast：只保留后面的若干项数据；&lt;/li&gt;
&lt;li&gt;TakeUntil：发射来自原始 Observable 的数据，直到第二个 Observable 发射了一个数据或一个通知；&lt;/li&gt;
&lt;li&gt;TakeWhile：发射原始 Observable 的数据，直到一个特定的条件为真，然后跳过剩余的数据；&lt;/li&gt;
&lt;li&gt;TimeInterval：将一个 Observable 转换为发射两个数据之间所耗费时间的 Observable；&lt;/li&gt;
&lt;li&gt;Timeout：添加超时机制，如果过了指定的一段时间没有发射数据，就发射一个错误通知；&lt;/li&gt;
&lt;li&gt;Timer：创建在一个指定的延迟之后发射单个数据的 Observable；&lt;/li&gt;
&lt;li&gt;Timestamp：给 Observable 发射的每个数据项添加一个时间戳；&lt;/li&gt;
&lt;li&gt;To：将 Observable 转换为其他对象或数据结构；&lt;/li&gt;
&lt;li&gt;Using：创建一个只在 Observable 生命周期内存在的一次性资源；&lt;/li&gt;
&lt;li&gt;Window：窗口，定期将来自 Observable 的数据拆分成一些 Observable 窗口，然后发射这些窗口，而不是每次发射一项；类似于 Buffer，但 Buffer 发射的是数据，Window 发射的是 Observable，每一个 Observable 发射原始 Observable 数据的一个子集；&lt;/li&gt;
&lt;li&gt;Zip：打包，使用一个指定的函数将多个 Observable 发射的数据组合在一起，然后将这个函数的结果作为单项数据发射；&lt;/li&gt;
&lt;/ul&gt;

    
    </summary>
    
      <category term="Android" scheme="https://www.vance.xin/categories/Android/"/>
    
    
      <category term="RxJava" scheme="https://www.vance.xin/tags/RxJava/"/>
    
      <category term="RxJava2.x" scheme="https://www.vance.xin/tags/RxJava2-x/"/>
    
      <category term="操作符" scheme="https://www.vance.xin/tags/%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>RxJava2.x 并行编程</title>
    <link href="https://www.vance.xin/2019/06/04/RxJava2.x%20%E7%9A%84%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/"/>
    <id>https://www.vance.xin/2019/06/04/RxJava2.x 的并行编程/</id>
    <published>2019-06-04T23:33:00.000Z</published>
    <updated>2024-05-12T05:02:43.596Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/xinpengfei520/my-cloud-picture@master/IMG_2022/202210061611796.png" alt=""><br>题图：来自飞哥的图片工厂</p><p>音乐推荐：你的姑娘<br>文丨IT大飞说<br>预计阅读时间：1.2 分钟</p><p>哈喽，朋友们，之前我们学习了一些 RxJava2.x 的常用操作符，今天我们来继续学习一下RxJava 的并行编程。</p><p>随着手机 CPU 的高速发展，性能越来越强劲，核心数越来越多，我们要充分、高效地利用这些 CPU 资源，来提高程序运行的效率，解决复杂的业务问题，这将变得越来越重要。</p><h2 id="1-什么是并行编程？"><a href="#1-什么是并行编程？" class="headerlink" title="1.什么是并行编程？"></a>1.什么是并行编程？</h2><p>对于并发我们可能比较清楚，那么并行是什么呢？它们的区别是什么？并发（concurrency）是指一个处理器同时处理多个任务，并行（parallelism）是多个处理器或者是多核处理器同时处理多个不同的任务，并行是同时发生的多个并发事件，具有并发的含义，而并发不一定是并行。</p><p>在 Java 8 中有个并行流（parallelStream），有的同学可能用过，我们想使用并行流的方式打印出 1-100 之间的整数，来看下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void parallelismWithJava8() &#123;</span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt;= 100; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        list.parallelStream()</span><br><span class="line">                .map(Object::toString)</span><br><span class="line">                .forEach(s -&gt; LogUtil.i(TAG, &quot;s=&quot; + s + &quot;,Current Thread Name=&quot; + Thread.currentThread().getName()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面的结果会交错输出 1-100 之间的整数，因为并行的缘故所以每个输出执行的时间可能不一样，所以会交错输出，其实上面的代码是 Java 8 借助了 JDK 的 fork/join 框架来实现并行编程的。</p><h2 id="2-使用-RxJava-的-flatMap-实现并行编程"><a href="#2-使用-RxJava-的-flatMap-实现并行编程" class="headerlink" title="2.使用 RxJava 的 flatMap 实现并行编程"></a>2.使用 RxJava 的 flatMap 实现并行编程</h2><p>我们前面学习过 flatMap 操作符，我们知道 flatMap 可以将一些数据转换成一些 Observables，然后我们可以指定它的调度器来实现并行编程的目的，还是打印 1-100 的数字，直接看代码吧：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void parallelismWithRxJavaFlatMap() &#123;</span><br><span class="line">    Observable.range(1, 100)</span><br><span class="line">            .flatMap((Function&lt;Integer, ObservableSource&lt;String&gt;&gt;) integer -&gt;</span><br><span class="line">                    Observable.just(integer)</span><br><span class="line">                            .subscribeOn(Schedulers.computation())</span><br><span class="line">                            .map(integer1 -&gt; integer1.toString()))</span><br><span class="line">            .subscribe(s -&gt; LogUtil.i(TAG, &quot;s===&quot; + s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式使用的是默认的调度器，当然我们也可以创建一个线程池，来自定义调度器，修改后的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private void parallelismWithRxJavaFlatMap() &#123;</span><br><span class="line">    int threadNum = Runtime.getRuntime().availableProcessors() + 1;</span><br><span class="line">    ExecutorService executorService = Executors.newFixedThreadPool(threadNum);</span><br><span class="line">    final Scheduler scheduler = Schedulers.from(executorService);</span><br><span class="line"></span><br><span class="line">    Observable.range(1, 100)</span><br><span class="line">            .flatMap((Function&lt;Integer, ObservableSource&lt;String&gt;&gt;) integer -&gt;</span><br><span class="line">                    Observable.just(integer)</span><br><span class="line">                            .subscribeOn(scheduler)</span><br><span class="line">                            .map(integer1 -&gt; integer1.toString()))</span><br><span class="line">            .doFinally(() -&gt; executorService.shutdown())</span><br><span class="line">            .subscribe(s -&gt; LogUtil.i(TAG, &quot;s===&quot; + s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这 2 种实现方式都差不多，性能方面也差别不大，根据喜好请自行选择，注意一点，如果使用自己创建的线程池，那么记得使用 doFinally 操作符将线程池关闭，或者由下游的消费者进行处理！</p><h2 id="3-使用-ParallelFlowable-实现并行编程"><a href="#3-使用-ParallelFlowable-实现并行编程" class="headerlink" title="3.使用 ParallelFlowable 实现并行编程"></a>3.使用 ParallelFlowable 实现并行编程</h2><p>Flowable 是 RxJava2.x 新增的被观察者，支持背压，因此它对应的并行被观察者为 ParallelFlowable，因为并行编程肯定涉及到异步，而异步又涉及到背压，所以是没有 ParallelObservable 的。</p><p>我们还是用 ParallelFlowable 来实现打印 1-100 这个需求吧，请看代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void parallelFlowable() &#123;</span><br><span class="line">    ParallelFlowable&lt;Integer&gt; parallelFlowable = Flowable.range(1, 100).parallel();</span><br><span class="line"></span><br><span class="line">    parallelFlowable</span><br><span class="line">            .runOn(Schedulers.io())</span><br><span class="line">            .map(integer -&gt; integer.toString())</span><br><span class="line">            .sequential()</span><br><span class="line">            .subscribe(s -&gt; LogUtil.i(TAG, &quot;s===&quot; + s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实代码是比较简单的，我们发现 runOn 和 sequential 操作符我们之前没见过，这里解释下，runOn 其实就是相当于我们上面使用 flatMap 实现中的 subscribeOn，我们可以用它来定义异步，它还有一个重载的方法，我们可以指定 prefetch 的数量。</p><p>sequential 操作符是将并行的操作结果返回到并行流中，这样，才能打印出所有的输出结果。</p><p>我们上面学会了好几种并行编程的方式，那么我们在实际的开发中应该选择哪种呢？</p><p>并非所有的顺序操作在并行中都是有意义的，目前 ParallelFlowable 只支持如下操作：<br>map、filter、flatMap、concatMap、reduce、collect、sorted、toSortedList、compose、fromArray、doOnCancel、doOnError、doOnComplete、doOnNext、doAfterNext、doOnSubscribe、doAfterTerminated、doOnRequest，优先推荐使用 ParallelFlowable 实现并行编程，对于无法使用 ParallelFlowable 的操作符，则使用 flatMap 来实现。</p><p>好了，今天的学习内容就算完成了，感觉是不是很简单？实践证明，学完后动手敲一遍的效果是最好的，赶紧去动手敲一遍吧！</p><p>最后，我这边有个技术交流群，平常我会分享一些学习资源到群里，还可以和大家一起交流学习，需要的朋友可以加我微信 <strong>vancexin</strong> 并备注「加群」，拉你进入技术交流群！</p><p>飞哥带你去装逼，一直装逼到天黑！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xinpengfei520/my-cloud-picture@master/IMG_2022/202210061611796.png&quot; alt&gt;&lt;br&gt;题图：来自飞哥的图片工厂&lt;/p&gt;
&lt;p&gt;音乐推荐：你的姑娘&lt;br&gt;文丨IT大飞说&lt;br&gt;预计阅读时间：1.2 分钟&lt;/p&gt;
&lt;p&gt;哈喽，朋友们，之前我们学习了一些 RxJava2.x 的常用操作符，今天我们来继续学习一下RxJava 的并行编程。&lt;/p&gt;
&lt;p&gt;随着手机 CPU 的高速发展，性能越来越强劲，核心数越来越多，我们要充分、高效地利用这些 CPU 资源，来提高程序运行的效率，解决复杂的业务问题，这将变得越来越重要。&lt;/p&gt;
&lt;h2 id=&quot;1-什么是并行编程？&quot;&gt;&lt;a href=&quot;#1-什么是并行编程？&quot; class=&quot;headerlink&quot; title=&quot;1.什么是并行编程？&quot;&gt;&lt;/a&gt;1.什么是并行编程？&lt;/h2&gt;&lt;p&gt;对于并发我们可能比较清楚，那么并行是什么呢？它们的区别是什么？并发（concurrency）是指一个处理器同时处理多个任务，并行（parallelism）是多个处理器或者是多核处理器同时处理多个不同的任务，并行是同时发生的多个并发事件，具有并发的含义，而并发不一定是并行。&lt;/p&gt;
&lt;p&gt;在 Java 8 中有个并行流（parallelStream），有的同学可能用过，我们想使用并行流的方式打印出 1-100 之间的整数，来看下面的代码：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;private void parallelismWithJava8() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        List&amp;lt;Integer&amp;gt; list = new ArrayList&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for (int i = 1; i &amp;lt;= 100; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            list.add(i);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        list.parallelStream()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .map(Object::toString)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .forEach(s -&amp;gt; LogUtil.i(TAG, &amp;quot;s=&amp;quot; + s + &amp;quot;,Current Thread Name=&amp;quot; + Thread.currentThread().getName()));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的结果会交错输出 1-100 之间的整数，因为并行的缘故所以每个输出执行的时间可能不一样，所以会交错输出，其实上面的代码是 Java 8 借助了 JDK 的 fork/join 框架来实现并行编程的。&lt;/p&gt;
&lt;h2 id=&quot;2-使用-RxJava-的-flatMap-实现并行编程&quot;&gt;&lt;a href=&quot;#2-使用-RxJava-的-flatMap-实现并行编程&quot; class=&quot;headerlink&quot; title=&quot;2.使用 RxJava 的 flatMap 实现并行编程&quot;&gt;&lt;/a&gt;2.使用 RxJava 的 flatMap 实现并行编程&lt;/h2&gt;
    
    </summary>
    
      <category term="Android" scheme="https://www.vance.xin/categories/Android/"/>
    
    
      <category term="RxJava" scheme="https://www.vance.xin/tags/RxJava/"/>
    
      <category term="RxJava2.x" scheme="https://www.vance.xin/tags/RxJava2-x/"/>
    
      <category term="操作符" scheme="https://www.vance.xin/tags/%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    
      <category term="并行编程" scheme="https://www.vance.xin/tags/%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/"/>
    
      <category term="parallelism" scheme="https://www.vance.xin/tags/parallelism/"/>
    
  </entry>
  
  <entry>
    <title>Android library 依赖 aar 包的两种方式</title>
    <link href="https://www.vance.xin/2019/05/30/Android%20library%20%E4%BE%9D%E8%B5%96%20aar%20%E5%8C%85%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>https://www.vance.xin/2019/05/30/Android library 依赖 aar 包的两种方式/</id>
    <published>2019-05-30T17:12:05.000Z</published>
    <updated>2024-05-12T05:02:43.592Z</updated>
    
    <content type="html"><![CDATA[<h2 id="方式1"><a href="#方式1" class="headerlink" title="方式1"></a>方式1</h2><p>将 aar 包放入 library module 的 libs 目录下，然后在工程的 build.gradle 文件中加入如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flatDir &#123; dirs &apos;libs&apos;, &apos;../moduleName/libs&apos; &#125;</span><br></pre></td></tr></table></figure><p>注：将 moduleName 替换为你自己的 library module 的 name.</p><p>然后在 module 的 build.gradle 文件中添加依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation(name: &apos;aar包名&apos;, ext: &apos;aar&apos;)</span><br></pre></td></tr></table></figure><h2 id="方式2"><a href="#方式2" class="headerlink" title="方式2"></a>方式2</h2><p>这种方式的思路是，先把 aar 包放入一个单独的文件夹中，然后我们再依赖这个文件夹就可以了，这个文件夹你也可以理解成一个特殊的 module。</p><p>先在工程目录下新建一个文件夹（和app同级），然后将你的 aar 包放入 这个文件夹，然后再新建一个 build.gradle 文件，在这个文件中添加下面两句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">configurations.maybeCreate(&quot;default&quot;)</span><br><span class="line">artifacts.add(&quot;default&quot;, file(&apos;aar包名.aar&apos;))</span><br></pre></td></tr></table></figure><p>然后在你需要依赖的 library module 的 build.gradle 文件中添加依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation project(&apos;:存放aar包的文件夹&apos;)</span><br></pre></td></tr></table></figure><p>最后，同步下工程就 OK 了~</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;方式1&quot;&gt;&lt;a href=&quot;#方式1&quot; class=&quot;headerlink&quot; title=&quot;方式1&quot;&gt;&lt;/a&gt;方式1&lt;/h2&gt;&lt;p&gt;将 aar 包放入 library module 的 libs 目录下，然后在工程的 build.gradle 文件中加入如下代码：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;flatDir &amp;#123; dirs &amp;apos;libs&amp;apos;, &amp;apos;../moduleName/libs&amp;apos; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;注：将 moduleName 替换为你自己的 library module 的 name.&lt;/p&gt;
&lt;p&gt;然后在 module 的 build.gradle 文件中添加依赖：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;implementation(name: &amp;apos;aar包名&amp;apos;, ext: &amp;apos;aar&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;方式2&quot;&gt;&lt;a href=&quot;#方式2&quot; class=&quot;headerlink&quot; title=&quot;方式2&quot;&gt;&lt;/a&gt;方式2&lt;/h2&gt;&lt;p&gt;这种方式的思路是，先把 aar 包放入一个单独的文件夹中，然后我们再依赖这个文件夹就可以了，这个文件夹你也可以理解成一个特殊的 module。&lt;/p&gt;
&lt;p&gt;先在工程目录下新建一个文件夹（和app同级），然后将你的 aar 包放入 这个文件夹，然后再新建一个 build.gradle 文件，在这个文件中添加下面两句：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;configurations.maybeCreate(&amp;quot;default&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;artifacts.add(&amp;quot;default&amp;quot;, file(&amp;apos;aar包名.aar&amp;apos;))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="https://www.vance.xin/categories/Android/"/>
    
    
      <category term="aar" scheme="https://www.vance.xin/tags/aar/"/>
    
      <category term="module" scheme="https://www.vance.xin/tags/module/"/>
    
      <category term="依赖" scheme="https://www.vance.xin/tags/%E4%BE%9D%E8%B5%96/"/>
    
      <category term="library" scheme="https://www.vance.xin/tags/library/"/>
    
  </entry>
  
  <entry>
    <title>RxJava2.x 变换操作符之 flatMap 和 concatMap</title>
    <link href="https://www.vance.xin/2019/05/27/RxJava2.x%20%E5%8F%98%E6%8D%A2%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B9%8B%20flatMap%E5%92%8CconcatMap/"/>
    <id>https://www.vance.xin/2019/05/27/RxJava2.x 变换操作符之 flatMap和concatMap/</id>
    <published>2019-05-27T23:17:00.000Z</published>
    <updated>2024-05-12T05:02:43.596Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/xinpengfei520/my-cloud-picture@master/IMG_2022/202210061610911.png" alt=""><br>题图：Pixabay License</p><p>哈喽，朋友们，<a href="https://mp.weixin.qq.com/s?__biz=MzU4MTIzNjg0Ng==&amp;mid=2247484144&amp;idx=1&amp;sn=28e8940cc3a692057a7a3634f04d52f7&amp;chksm=fd4be3f1ca3c6ae765a83e4d6b7d9668f2c212ea3258e7e3cf6cb5ab22c3973720ef5cc7d0a8&amp;token=759890379&amp;lang=zh_CN#rd" target="_blank" rel="noopener">上一篇文章</a>我们学习了 filter 操作符，今天我们来学习 RxJava 中比较重要的两个操作符 flatMap 和 concatMap。</p><h2 id="1-flatMap"><a href="#1-flatMap" class="headerlink" title="1.flatMap"></a>1.flatMap</h2><p>我们知道 flat 是平的意思，这个翻译还是有点生硬和抽象，我们还是不太理解，你就可以先理解成平铺的意思吧。</p><p>flatMap 是变换操作符的一种，它将一个发射数据的 Observable 变换为多个 Observable，然后将他们发射的数据合并后放入一个单独的 Observable。</p><p>举个简单的例子吧，假设上游有个数据源，数据源是学生对象的集合，学生有姓名和课程的属性，每个学生的课程可以有多个，需求是打印出所有学生的课程名称。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Student student1 = new Student();</span><br><span class="line"></span><br><span class="line">List&lt;Student.Course&gt; list1 = new ArrayList&lt;&gt;();</span><br><span class="line">list1.add(new Student.Course(&quot;语文1&quot;));</span><br><span class="line">list1.add(new Student.Course(&quot;数学1&quot;));</span><br><span class="line">list1.add(new Student.Course(&quot;英语1&quot;));</span><br><span class="line">list1.add(new Student.Course(&quot;物理1&quot;));</span><br><span class="line">list1.add(new Student.Course(&quot;化学1&quot;));</span><br><span class="line"></span><br><span class="line">student1.setName(&quot;张三&quot;);</span><br><span class="line">student1.setCourses(list1);</span><br><span class="line"></span><br><span class="line">Student student2 = new Student();</span><br><span class="line"></span><br><span class="line">List&lt;Student.Course&gt; list2 = new ArrayList&lt;&gt;();</span><br><span class="line">list2.add(new Student.Course(&quot;语文2&quot;));</span><br><span class="line">list2.add(new Student.Course(&quot;数学2&quot;));</span><br><span class="line">list2.add(new Student.Course(&quot;英语2&quot;));</span><br><span class="line"></span><br><span class="line">student2.setName(&quot;李四&quot;);</span><br><span class="line">student2.setCourses(list2);</span><br><span class="line"></span><br><span class="line">List&lt;Student&gt; studentList = new ArrayList&lt;&gt;();</span><br><span class="line">studentList.add(student1);</span><br><span class="line">studentList.add(student2);</span><br><span class="line"></span><br><span class="line">Observable.just(studentList)</span><br><span class="line">        .flatMap((Function&lt;List&lt;Student&gt;, ObservableSource&lt;Student&gt;&gt;) students -&gt; Observable.fromIterable(students))</span><br><span class="line">        .flatMap((Function&lt;Student, ObservableSource&lt;Student.Course&gt;&gt;) student -&gt; &#123;</span><br><span class="line">            LogUtil.i(TAG, &quot;student name===&quot; + student.getName());</span><br><span class="line">            return Observable.fromIterable(student.getCourses());</span><br><span class="line">        &#125;)</span><br><span class="line">        .subscribe(course -&gt; LogUtil.i(TAG, &quot;course===&quot; + course.getCourseName()));</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">I/RxJavaOperatorActivity: student name===张三</span><br><span class="line">I/RxJavaOperatorActivity: course===语文1</span><br><span class="line">I/RxJavaOperatorActivity: course===数学1</span><br><span class="line">I/RxJavaOperatorActivity: course===英语1</span><br><span class="line">I/RxJavaOperatorActivity: course===物理1</span><br><span class="line">I/RxJavaOperatorActivity: course===化学1</span><br><span class="line">I/RxJavaOperatorActivity: student name===李四</span><br><span class="line">I/RxJavaOperatorActivity: course===语文2</span><br><span class="line">I/RxJavaOperatorActivity: course===数学2</span><br><span class="line">I/RxJavaOperatorActivity: course===英语2</span><br></pre></td></tr></table></figure><p>我们看到上面的代码没有 for 循环，却遍历打印了集合中的数据，RxJava 就是为了简化或者是取消 for 循环种方式，使用操作符来解决遍历循环的问题，从而是代码更加扁平化，使代码更加清晰和便于理解。</p><p>注意：flatMap 对这些 Observables 发射的数据做的是合并(merge)操作，因此它们可能是交错的，即不能保证数据的发射顺序。</p><h2 id="2-concatMap"><a href="#2-concatMap" class="headerlink" title="2.concatMap"></a>2.concatMap</h2><p>我们将上面的 flatMap 操作符换成 concatMap 操作符再看看打印的结果，修改代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(studentList)</span><br><span class="line">            .concatMap((Function&lt;List&lt;Student&gt;, ObservableSource&lt;Student&gt;&gt;) students -&gt; Observable.fromIterable(students))</span><br><span class="line">            .concatMap((Function&lt;Student, ObservableSource&lt;Student.Course&gt;&gt;) student -&gt; &#123;</span><br><span class="line">                LogUtil.i(TAG, &quot;student name===&quot; + student.getName());</span><br><span class="line">                return Observable.fromIterable(student.getCourses());</span><br><span class="line">            &#125;)</span><br><span class="line">            .subscribe(course -&gt; LogUtil.i(TAG, &quot;course===&quot; + course.getCourseName()));</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">I/RxJavaOperatorActivity: student name===张三</span><br><span class="line">I/RxJavaOperatorActivity: course===语文1</span><br><span class="line">I/RxJavaOperatorActivity: course===数学1</span><br><span class="line">I/RxJavaOperatorActivity: course===英语1</span><br><span class="line">I/RxJavaOperatorActivity: course===物理1</span><br><span class="line">I/RxJavaOperatorActivity: course===化学1</span><br><span class="line">I/RxJavaOperatorActivity: student name===李四</span><br><span class="line">I/RxJavaOperatorActivity: course===语文2</span><br><span class="line">I/RxJavaOperatorActivity: course===数学2</span><br><span class="line">I/RxJavaOperatorActivity: course===英语2</span><br></pre></td></tr></table></figure><p>我们看到和 flatMap 的执行结果是一样的，我们发现打印的结果也是按照添加数据的顺序打印出来了，理论上 flatMap 执行的结果可能会有交错，原因是我们添加的数据过少，因此它们执行的时间也是差不多的，所以提现不出交错的情况。</p><p>好了，今天的学习内容就算完成了，感觉是不是非常简单？其实有时候你光看，理解起来是很慢的，但是你动手敲一遍立马就明白了，所以代码这个东西还是得多敲！</p><p>最后，我这边建了一个技术交流群，需要的朋友可以扫描下面的二维码加我微信并备注「加群」，拉你进入技术交流群！</p><p><img src="https://cdn.jsdelivr.net/gh/xinpengfei520/my-cloud-picture@master/IMG_2022/202210061611376.png" alt=""></p><p>飞哥带你去装逼，一直装逼到天黑！</p><p>另外，我还建了一个免费的知识星球用于学习交流，感兴趣的可以使用微信扫码加入哦！</p><p><img src="https://cdn.jsdelivr.net/gh/xinpengfei520/my-cloud-picture@master/IMG_2022/202210061610428.jpeg" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xinpengfei520/my-cloud-picture@master/IMG_2022/202210061610911.png&quot; alt&gt;&lt;br&gt;题图：Pixabay License&lt;/p&gt;
&lt;p&gt;哈喽，朋友们，&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU4MTIzNjg0Ng==&amp;amp;mid=2247484144&amp;amp;idx=1&amp;amp;sn=28e8940cc3a692057a7a3634f04d52f7&amp;amp;chksm=fd4be3f1ca3c6ae765a83e4d6b7d9668f2c212ea3258e7e3cf6cb5ab22c3973720ef5cc7d0a8&amp;amp;token=759890379&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;上一篇文章&lt;/a&gt;我们学习了 filter 操作符，今天我们来学习 RxJava 中比较重要的两个操作符 flatMap 和 concatMap。&lt;/p&gt;
&lt;h2 id=&quot;1-flatMap&quot;&gt;&lt;a href=&quot;#1-flatMap&quot; class=&quot;headerlink&quot; title=&quot;1.flatMap&quot;&gt;&lt;/a&gt;1.flatMap&lt;/h2&gt;&lt;p&gt;我们知道 flat 是平的意思，这个翻译还是有点生硬和抽象，我们还是不太理解，你就可以先理解成平铺的意思吧。&lt;/p&gt;
&lt;p&gt;flatMap 是变换操作符的一种，它将一个发射数据的 Observable 变换为多个 Observable，然后将他们发射的数据合并后放入一个单独的 Observable。&lt;/p&gt;
&lt;p&gt;举个简单的例子吧，假设上游有个数据源，数据源是学生对象的集合，学生有姓名和课程的属性，每个学生的课程可以有多个，需求是打印出所有学生的课程名称。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Student student1 = new Student();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;List&amp;lt;Student.Course&amp;gt; list1 = new ArrayList&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;list1.add(new Student.Course(&amp;quot;语文1&amp;quot;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;list1.add(new Student.Course(&amp;quot;数学1&amp;quot;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;list1.add(new Student.Course(&amp;quot;英语1&amp;quot;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;list1.add(new Student.Course(&amp;quot;物理1&amp;quot;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;list1.add(new Student.Course(&amp;quot;化学1&amp;quot;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;student1.setName(&amp;quot;张三&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;student1.setCourses(list1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Student student2 = new Student();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;List&amp;lt;Student.Course&amp;gt; list2 = new ArrayList&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;list2.add(new Student.Course(&amp;quot;语文2&amp;quot;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;list2.add(new Student.Course(&amp;quot;数学2&amp;quot;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;list2.add(new Student.Course(&amp;quot;英语2&amp;quot;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;student2.setName(&amp;quot;李四&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;student2.setCourses(list2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;List&amp;lt;Student&amp;gt; studentList = new ArrayList&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;studentList.add(student1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;studentList.add(student2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Observable.just(studentList)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .flatMap((Function&amp;lt;List&amp;lt;Student&amp;gt;, ObservableSource&amp;lt;Student&amp;gt;&amp;gt;) students -&amp;gt; Observable.fromIterable(students))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .flatMap((Function&amp;lt;Student, ObservableSource&amp;lt;Student.Course&amp;gt;&amp;gt;) student -&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            LogUtil.i(TAG, &amp;quot;student name===&amp;quot; + student.getName());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            return Observable.fromIterable(student.getCourses());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .subscribe(course -&amp;gt; LogUtil.i(TAG, &amp;quot;course===&amp;quot; + course.getCourseName()));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;执行结果如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;I/RxJavaOperatorActivity: student name===张三&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;I/RxJavaOperatorActivity: course===语文1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;I/RxJavaOperatorActivity: course===数学1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;I/RxJavaOperatorActivity: course===英语1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;I/RxJavaOperatorActivity: course===物理1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;I/RxJavaOperatorActivity: course===化学1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;I/RxJavaOperatorActivity: student name===李四&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;I/RxJavaOperatorActivity: course===语文2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;I/RxJavaOperatorActivity: course===数学2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;I/RxJavaOperatorActivity: course===英语2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们看到上面的代码没有 for 循环，却遍历打印了集合中的数据，RxJava 就是为了简化或者是取消 for 循环种方式，使用操作符来解决遍历循环的问题，从而是代码更加扁平化，使代码更加清晰和便于理解。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://www.vance.xin/categories/Android/"/>
    
    
      <category term="RxJava" scheme="https://www.vance.xin/tags/RxJava/"/>
    
      <category term="RxJava2.x" scheme="https://www.vance.xin/tags/RxJava2-x/"/>
    
      <category term="操作符" scheme="https://www.vance.xin/tags/%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>RxJava2.x 操作符之 filter</title>
    <link href="https://www.vance.xin/2019/05/23/RxJava2.x%20%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B9%8B%20filter/"/>
    <id>https://www.vance.xin/2019/05/23/RxJava2.x 操作符之 filter/</id>
    <published>2019-05-23T17:20:00.000Z</published>
    <updated>2024-05-12T05:02:43.596Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/xinpengfei520/my-cloud-picture@master/IMG_2022/202210061609399.png" alt=""><br>题图：Pixabay License</p><p>哈喽，朋友们，<a href="https://mp.weixin.qq.com/s/EV4afZ27lQZ8xLxnZjLZow" target="_blank" rel="noopener">上一篇文章</a>我们学习了 repeate 操作符，今天我们继续来学习 filter 操作符。</p><p>我们都知道 filter 是过滤的意思，也就是说这个操作符就是帮助我们来过滤掉一些我们不需要的数据。</p><p>举个简单的例子吧，假设上游有个数据源，顺序向下游发送 0-9 十个数字，我们只想打印大于 5 的数字，我们就可以这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Observable.interval(1, TimeUnit.SECONDS)</span><br><span class="line">   .take(10)</span><br><span class="line">   .filter(new Func1&lt;Long, Boolean&gt;() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public Boolean call(Long aLong) &#123;</span><br><span class="line">               return aLong &gt; 5;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;)</span><br><span class="line">   .subscribe(new Action1&lt;Long&gt;() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void call(Long aLong) &#123;</span><br><span class="line">               LogUtil.i(&quot;aLong===&quot; + aLong);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I/RxJavaOperatorActivity: aLong===6</span><br><span class="line">I/RxJavaOperatorActivity: aLong===7</span><br><span class="line">I/RxJavaOperatorActivity: aLong===8</span><br><span class="line">I/RxJavaOperatorActivity: aLong===9</span><br></pre></td></tr></table></figure><p>结果打印出来的都是大于 5 的数字，当然你还可以设置其他的过滤条件，例如空值等！</p><p>好了，今天的学习内容就算完成了，感觉是不是非常简单？如果你学会了就赶紧动手去实践一下吧，说不定你会有新的发现哦！</p><p>最后，我和大家分享一下我学习的一些经验或者是见解吧。我们再学习的过程中，可能学的很多东西都是点状的，我们要把学习到的东西学会融会贯通，将他们连接成线即学会相互联系，再将线形成面，再形成体，这样我们学到的知识才能形成一个完整的知识体系，不要只见树叶，不见森林，希望大家在学习的过程中，多思考，多总结！</p><p>Ps:扫描下面的二维码，关注「IT大飞说」，回复「加群」，拉你进入兄弟战斗群，最后告诉你们一个小秘密，公号对话框回复「装备01」 送你一件珍藏版的打怪装备，战斗力瞬间可增加 80！！！我使用过，效果杠杠滴！从此，我们就可以一起愉快的装逼了！</p><p>飞哥带你去装逼，一直装逼到天黑！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xinpengfei520/my-cloud-picture@master/IMG_2022/202210061609399.png&quot; alt&gt;&lt;br&gt;题图：Pixabay License&lt;/p&gt;
&lt;p&gt;哈喽，朋友们，&lt;a href=&quot;https://mp.weixin.qq.com/s/EV4afZ27lQZ8xLxnZjLZow&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;上一篇文章&lt;/a&gt;我们学习了 repeate 操作符，今天我们继续来学习 filter 操作符。&lt;/p&gt;
&lt;p&gt;我们都知道 filter 是过滤的意思，也就是说这个操作符就是帮助我们来过滤掉一些我们不需要的数据。&lt;/p&gt;
&lt;p&gt;举个简单的例子吧，假设上游有个数据源，顺序向下游发送 0-9 十个数字，我们只想打印大于 5 的数字，我们就可以这么写：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Observable.interval(1, TimeUnit.SECONDS)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   .take(10)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   .filter(new Func1&amp;lt;Long, Boolean&amp;gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           @Override&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           public Boolean call(Long aLong) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               return aLong &amp;gt; 5;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   .subscribe(new Action1&amp;lt;Long&amp;gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           @Override&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           public void call(Long aLong) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               LogUtil.i(&amp;quot;aLong===&amp;quot; + aLong);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;           &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;执行结果如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;I/RxJavaOperatorActivity: aLong===6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;I/RxJavaOperatorActivity: aLong===7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;I/RxJavaOperatorActivity: aLong===8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;I/RxJavaOperatorActivity: aLong===9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;结果打印出来的都是大于 5 的数字，当然你还可以设置其他的过滤条件，例如空值等！&lt;/p&gt;
&lt;p&gt;好了，今天的学习内容就算完成了，感觉是不是非常简单？如果你学会了就赶紧动手去实践一下吧，说不定你会有新的发现哦！&lt;/p&gt;
&lt;p&gt;最后，我和大家分享一下我学习的一些经验或者是见解吧。我们再学习的过程中，可能学的很多东西都是点状的，我们要把学习到的东西学会融会贯通，将他们连接成线即学会相互联系，再将线形成面，再形成体，这样我们学到的知识才能形成一个完整的知识体系，不要只见树叶，不见森林，希望大家在学习的过程中，多思考，多总结！&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://www.vance.xin/categories/Android/"/>
    
    
      <category term="RxJava" scheme="https://www.vance.xin/tags/RxJava/"/>
    
      <category term="RxJava2.x" scheme="https://www.vance.xin/tags/RxJava2-x/"/>
    
      <category term="操作符" scheme="https://www.vance.xin/tags/%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>RxJava2.x 操作符之 repeat</title>
    <link href="https://www.vance.xin/2019/05/21/RxJava2.x%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B9%8Brepeat/"/>
    <id>https://www.vance.xin/2019/05/21/RxJava2.x操作符之repeat/</id>
    <published>2019-05-21T23:51:56.000Z</published>
    <updated>2024-05-12T05:02:43.596Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/xinpengfei520/my-cloud-picture@master/IMG_2022/202210061609749.png" alt=""><br>题图：Pixabay License</p><p>哈喽，朋友们，<a href="https://mp.weixin.qq.com/s?__biz=MzU4MTIzNjg0Ng==&amp;mid=2247484126&amp;idx=1&amp;sn=e94a44088c9697aa36ff1ddf91e35ced&amp;chksm=fd4be3dfca3c6ac969c0ccfb39d364bbca18b651f8cd36ed1e07af174775acebcd0426a6745a&amp;token=887755948&amp;lang=zh_CN#rd" target="_blank" rel="noopener">上一篇文章</a>我们学习了 from 操作符，今天我们继续来学习 repeat 操作符。</p><p>我们都知道 repeat 是重复的意思，也就是说这个操作符就是帮助我们来操作处理一些重复的数据或者操作，repeat 有三个相关的操作符：repeat、repeatWhen、repeatUntil，从字面也很好理解，repeat 就是简单的重复操作，repeatWhen 当达到什么条件的时候重复，repeatUntil 是直到某个条件不在重复。</p><h2 id="1-repeat"><a href="#1-repeat" class="headerlink" title="1.repeat"></a>1.repeat</h2><p>举个简单的例子吧，例如我们想重复打印一下 “Hello World!”，我们就可以这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private void repeat() &#123;</span><br><span class="line">    Observable.just(&quot;Hello World!&quot;)</span><br><span class="line">            .repeat(3)</span><br><span class="line">            .subscribe(s -&gt; LogUtil.i(TAG, s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单吧，这个就不用我多说了吧。需要注意的是，如果不指定重复的次数，则会无限地重复下去！</p><h2 id="2-repeatWhen"><a href="#2-repeatWhen" class="headerlink" title="2.repeatWhen"></a>2.repeatWhen</h2><p>例如，我们想按顺序打印 0-3 的数字，当 2 秒后我们再重复打印一次，我们就可以这么写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.range(0, 4)</span><br><span class="line">            .repeatWhen(objectObservable -&gt; Observable.timer(2, TimeUnit.SECONDS))</span><br><span class="line">            .subscribe(integer -&gt; LogUtil.i(TAG, &quot;integer===&quot; + integer));</span><br></pre></td></tr></table></figure><p>上面的代码也比较简单，首先我们使用了一个新的操作符 range，也就是范围的意思，我们可以用它来指定一个数字的范围，并按顺序发射出去，repeatWhen 中使用了一个新的操作符 timer，我们用他创建了一个定时器的被观察者对象，并指定了两秒的时长，当到达 2 秒时就会重复原始的 Observable 并重新订阅和发射。</p><h2 id="3-repeatUntil"><a href="#3-repeatUntil" class="headerlink" title="3.repeatUntil"></a>3.repeatUntil</h2><p>例如，我想间隔 1 秒顺序打印数字 0-2，当从开始打印到第 5 秒的时候就停止打印，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Observable.interval(1000, TimeUnit.MILLISECONDS)</span><br><span class="line">            .take(3)</span><br><span class="line">            .repeatUntil(() -&gt; System.currentTimeMillis() - currentTimeMillis &gt; 5000)</span><br><span class="line">            .subscribe(aLong -&gt; LogUtil.i(TAG, &quot;aLong===&quot; + aLong));</span><br></pre></td></tr></table></figure><p>这里我们使用了一个新的操作符 interval，它可以指定时间单位的时长发送数字序列，还有一个操作符是 take，它表示只取前 3 个，注意：从 0 开始，不包含它自己，接下来我们在 repeatUntil 里加了个判断，当大于 5 秒就停止重复打印。</p><p>执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">I/RxJavaOperatorActivity: aLong===0</span><br><span class="line">I/RxJavaOperatorActivity: aLong===1</span><br><span class="line">I/RxJavaOperatorActivity: aLong===2</span><br><span class="line">I/RxJavaOperatorActivity: aLong===0</span><br><span class="line">I/RxJavaOperatorActivity: aLong===1</span><br><span class="line">I/RxJavaOperatorActivity: aLong===2</span><br></pre></td></tr></table></figure><p>怎么样？是不是立马就明白了。</p><p>好了，今天的学习内容就算完成了，感觉是不是非常简单？如果你学会了就赶紧动手去实践一下吧，说不定你会有新的发现哦！</p><p>最后，我和大家分享一下我学习的一些经验或者是见解吧。我们再学习的过程中，可能学的很多东西都是点状的，我们要把学习到的东西学会融会贯通，将他们连接成线即学会相互联系，再将线形成面，再形成体，这样我们学到的知识才能形成一个完整的知识体系，不要只见树叶，不见森林，希望大家在学习的过程中，多思考，多总结！</p><p>Ps:扫描下面的二维码，关注「IT大飞说」，回复「加群」，拉你进入兄弟战斗群，最后告诉你们一个小秘密，公号对话框回复「装备01」 送你一件珍藏版的打怪装备，战斗力瞬间可增加 80！！！我使用过，效果杠杠滴！从此，我们就可以一起愉快的装逼了！</p><p>飞哥带你去装逼，一直装逼到天黑！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/xinpengfei520/my-cloud-picture@master/IMG_2022/202210061609749.png&quot; alt&gt;&lt;br&gt;题图：Pixabay License&lt;/p&gt;
&lt;p&gt;哈喽，朋友们，&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzU4MTIzNjg0Ng==&amp;amp;mid=2247484126&amp;amp;idx=1&amp;amp;sn=e94a44088c9697aa36ff1ddf91e35ced&amp;amp;chksm=fd4be3dfca3c6ac969c0ccfb39d364bbca18b651f8cd36ed1e07af174775acebcd0426a6745a&amp;amp;token=887755948&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;上一篇文章&lt;/a&gt;我们学习了 from 操作符，今天我们继续来学习 repeat 操作符。&lt;/p&gt;
&lt;p&gt;我们都知道 repeat 是重复的意思，也就是说这个操作符就是帮助我们来操作处理一些重复的数据或者操作，repeat 有三个相关的操作符：repeat、repeatWhen、repeatUntil，从字面也很好理解，repeat 就是简单的重复操作，repeatWhen 当达到什么条件的时候重复，repeatUntil 是直到某个条件不在重复。&lt;/p&gt;
&lt;h2 id=&quot;1-repeat&quot;&gt;&lt;a href=&quot;#1-repeat&quot; class=&quot;headerlink&quot; title=&quot;1.repeat&quot;&gt;&lt;/a&gt;1.repeat&lt;/h2&gt;&lt;p&gt;举个简单的例子吧，例如我们想重复打印一下 “Hello World!”，我们就可以这么写：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;private void repeat() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Observable.just(&amp;quot;Hello World!&amp;quot;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            .repeat(3)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            .subscribe(s -&amp;gt; LogUtil.i(TAG, s));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;很简单吧，这个就不用我多说了吧。需要注意的是，如果不指定重复的次数，则会无限地重复下去！&lt;/p&gt;
&lt;h2 id=&quot;2-repeatWhen&quot;&gt;&lt;a href=&quot;#2-repeatWhen&quot; class=&quot;headerlink&quot; title=&quot;2.repeatWhen&quot;&gt;&lt;/a&gt;2.repeatWhen&lt;/h2&gt;&lt;p&gt;例如，我们想按顺序打印 0-3 的数字，当 2 秒后我们再重复打印一次，我们就可以这么写。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Observable.range(0, 4)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            .repeatWhen(objectObservable -&amp;gt; Observable.timer(2, TimeUnit.SECONDS))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            .subscribe(integer -&amp;gt; LogUtil.i(TAG, &amp;quot;integer===&amp;quot; + integer));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="https://www.vance.xin/categories/Android/"/>
    
    
      <category term="RxJava" scheme="https://www.vance.xin/tags/RxJava/"/>
    
      <category term="RxJava2.x" scheme="https://www.vance.xin/tags/RxJava2-x/"/>
    
      <category term="操作符" scheme="https://www.vance.xin/tags/%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    
  </entry>
  
</feed>
