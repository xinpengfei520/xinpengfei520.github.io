<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>程序员飞飞</title>
  
  <subtitle>码农，产品思维实践者，终身学习者，微信公众号：「程序员飞飞」。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.x-sir.com/"/>
  <updated>2020-04-08T09:23:06.392Z</updated>
  <id>https://www.x-sir.com/</id>
  
  <author>
    <name>程序员飞飞</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Virtual和Vagrant 安装 CentOS7 虚拟机</title>
    <link href="https://www.x-sir.com/2020/04/06/Virtual%20%E5%92%8C%20Vagrant%20%E5%AE%89%E8%A3%85%20CentOS7%20%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>https://www.x-sir.com/2020/04/06/Virtual 和 Vagrant 安装 CentOS7 虚拟机/</id>
    <published>2020-04-06T09:18:57.000Z</published>
    <updated>2020-04-08T09:23:06.392Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-下载安装-VirtualBox"><a href="#1-下载安装-VirtualBox" class="headerlink" title="1.下载安装 VirtualBox"></a>1.下载安装 VirtualBox</h2><p><a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="noopener">https://www.virtualbox.org/wiki/Downloads</a></p><p>根据自己的操作系统类型下载安装即可！</p><p>支持的操作系统类型有：</p><ul><li>Windows hosts</li><li>OS X hosts</li><li>Linux distributions</li><li>Solaris hosts</li></ul><p>温馨提示：如果是 Windows 系统用户，需要再 BIOS 中设置开启 CPU 虚拟化！！！</p><h2 id="2-下载安装-Vagrant"><a href="#2-下载安装-Vagrant" class="headerlink" title="2.下载安装 Vagrant"></a>2.下载安装 Vagrant</h2><p><a href="https://www.vagrantup.com/downloads.html" target="_blank" rel="noopener">https://www.vagrantup.com/downloads.html</a></p><p>根据自己的操作系统类型下载安装即可！</p><p>支持的操作系统类型有：</p><p><img src="https://img-blog.csdnimg.cn/2020040617022531.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbnBlbmdmZWk1MjE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="3-安装虚拟机"><a href="#3-安装虚拟机" class="headerlink" title="3.安装虚拟机"></a>3.安装虚拟机</h3><p>先打开 VirtualBox；</p><p>打开 Windows 的 cmd 或者 mac 的 Terminal 工具，输入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant</span><br></pre></td></tr></table></figure><p>如果有反应，说明我们的 <strong>vagrant</strong> 安装没有问题，可以进行下一步了。</p><p>输入命令初始化一个 centos7 虚拟机文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant init centos/7</span><br></pre></td></tr></table></figure><p>执行完上面的命令后会在用户目录下（Windows 在Users下面，mac 在用户姓名的目录下）生成一个 <strong>Vagrantfile</strong> 文件。</p><p>上面命令中的 <strong>centos/7</strong> 代表我们需要安装 CentOS7 的虚拟机，如果你要安装其他虚拟机就替换它就可以了。注意 <strong>/</strong> 不能省略掉！！！</p><p>支持的虚拟机类型在下面的网站可以查找到：</p><p><a href="https://app.vagrantup.com/boxes/search" target="_blank" rel="noopener">https://app.vagrantup.com/boxes/search</a></p><p>部分截图如下：</p><p><img src="https://img-blog.csdnimg.cn/20200406171236954.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbnBlbmdmZWk1MjE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>途中标红的就是安装的虚拟机的名称，如果要安装 Ubuntu 就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant init ubuntu/trusty64</span><br></pre></td></tr></table></figure><p>继续执行下面的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant up</span><br></pre></td></tr></table></figure><p>这个是安装启动虚拟机，如果是第一次，它会下载对应的虚拟机镜像文件，下载完成了之后就会自动启动虚拟机，以后再执行这个命令就是启动已经安装的虚拟机了。</p><p>实际情况在执行这个命令的时候，速度会特别慢，我这边显示剩余需要 30 多个小时，太漫长了，而且中间断了之后又要重新开始。</p><h3 id="3-设置第三方镜像"><a href="#3-设置第三方镜像" class="headerlink" title="3.设置第三方镜像"></a>3.设置第三方镜像</h3><p>下面的地址中下载你想要的镜像：</p><p><a href="http://www.vagrantbox.es/" target="_blank" rel="noopener">http://www.vagrantbox.es/</a></p><p>然后执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ vagrant box add &#123;title&#125; &#123;url&#125;</span><br><span class="line">$ vagrant init &#123;title&#125;</span><br><span class="line">$ vagrant up</span><br></pre></td></tr></table></figure><p>实际测试要比源下载地址快一些。</p><h3 id="4-本地安装"><a href="#4-本地安装" class="headerlink" title="4.本地安装"></a>4.本地安装</h3><p>本地安装，就是先通过网盘等下载别人分享的虚拟机 box 到本地，然后通过命令进行安装。</p><p>以 CentOS7 为例：</p><p>先下载 box，链接: <a href="https://pan.baidu.com/s/1HYnVmvgOnxuhWef6bRglRw" target="_blank" rel="noopener">https://pan.baidu.com/s/1HYnVmvgOnxuhWef6bRglRw</a> 提取码: tfn3</p><p>然后执行如下命令：</p><p>1.添加 vagrant box 到 box list</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant box add centos7 &lt;path&gt;</span><br></pre></td></tr></table></figure><p>path 为你下载的 box 镜像路径。</p><p>2.初始化一个虚拟机使用刚才添加的 vagrant box</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant init centos7</span><br></pre></td></tr></table></figure><p>温馨提示：如果你之前执行过初始化的命令，那个在执行这个命令的时候它会从去网上下载镜像，因此你需要找到 <strong>Vagrantfile</strong> 文件删除掉，然后再执行上面的命令就没问题了，安装完成后，下载的镜像文件也可以删掉了。</p><p>3.启动 vagrant box 虚拟机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant up</span><br></pre></td></tr></table></figure><h2 id="5-常用命令"><a href="#5-常用命令" class="headerlink" title="5.常用命令"></a>5.常用命令</h2><p>连接到 ssh:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant ssh</span><br></pre></td></tr></table></figure><p>这样就可以操作虚拟机了，当然也可以用其他第三方的连接工具。</p><p>默认登录进去的是 vagrant 用户。</p><p>所以执行有些命令的时候需要加 sudo，或者切换到 root 用户:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su root</span><br></pre></td></tr></table></figure><p>默认 root 用户的密码为：vagrant</p><h2 id="6-设置网络"><a href="#6-设置网络" class="headerlink" title="6.设置网络"></a>6.设置网络</h2><p>默认情况下，VirtualBox 使用的是网络地址转换和端口转发的方式实现了本地系统和虚拟机地址的问题，如下图所示。</p><p><img src="https://img-blog.csdnimg.cn/202004061746446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbnBlbmdmZWk1MjE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>在实际使用过程中，对我们可能不太方便。</p><p>举个例子，比如我们的虚拟机中装了很多东西，比如 MySQL 数据库，Redis 等等，在虚拟机内部是没有问题的，MySQL 数据库的端口默认是 3306，虚拟机可能给我们映射出来的端口就可能不是 3306 了，这对于我们再本机器的进行测试是及其不方便的。</p><p>因此，我们不使用这种默认的方式，我们可以设置一个私有的 ip 实现本地系统和虚拟机系统之间的互通。</p><p>打开 cmd 输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig -a</span><br></pre></td></tr></table></figure><p>找到 VirtualBox 的虚拟网卡地址：</p><p>我的是：192.168.56.2</p><p>编辑 <strong>Vagrantfile</strong> 文件，找到如下一行，去掉注释并修改 ip 为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">config.vm.network &quot;private_network&quot;, ip: &quot;192.168.56.10&quot;</span><br></pre></td></tr></table></figure><p>其中 192.168.56 是固定的，10 也可以换成其他的，最大不要超过 255 就可以了！</p><p>重新加载配置文件，并重启 vagrant:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vagrant reload</span><br></pre></td></tr></table></figure><p>启动完成后，本地系统和虚拟机之间相互 Ping ，如果没有问题，说明网络配置就好了！</p><p>例如，在虚拟机中 ping 本地的地址为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping 192.168.1.103</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/2020040618555381.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbnBlbmdmZWk1MjE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>在本地 Ping 虚拟机的 ip (刚才配置文件中配置的那个 IP)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping 192.168.56.10</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200406185705163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbnBlbmdmZWk1MjE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>OK，这样算就是配置完成了！</p><p>今天的分享就到这里，如果对你有帮助，请给我点个赞，或者有任何问题都可以在评论区与我交流哦！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-下载安装-VirtualBox&quot;&gt;&lt;a href=&quot;#1-下载安装-VirtualBox&quot; class=&quot;headerlink&quot; title=&quot;1.下载安装 VirtualBox&quot;&gt;&lt;/a&gt;1.下载安装 VirtualBox&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;h
      
    
    </summary>
    
      <category term="JavaEE" scheme="https://www.x-sir.com/categories/JavaEE/"/>
    
    
      <category term="CentOS7" scheme="https://www.x-sir.com/tags/CentOS7/"/>
    
      <category term="vm" scheme="https://www.x-sir.com/tags/vm/"/>
    
      <category term="Vagrant" scheme="https://www.x-sir.com/tags/Vagrant/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7 安装 Docker（小白精简版）！！！</title>
    <link href="https://www.x-sir.com/2020/04/06/CentOS7%20%E5%AE%89%E8%A3%85%20Docker%EF%BC%88%E5%B0%8F%E7%99%BD%E7%B2%BE%E7%AE%80%E7%89%88%EF%BC%89%EF%BC%81%EF%BC%81%EF%BC%81/"/>
    <id>https://www.x-sir.com/2020/04/06/CentOS7 安装 Docker（小白精简版）！！！/</id>
    <published>2020-04-06T09:17:57.000Z</published>
    <updated>2020-04-08T09:18:09.259Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要参考 Docker 官方文档的安装为主，官方文档比较繁琐，而且是英文的，因此，我简化了安装的步骤，更适合小白安装。</p><p>官网：<a href="https://www.docker.com/" target="_blank" rel="noopener">https://www.docker.com/</a></p><h2 id="1-卸载旧版本"><a href="#1-卸载旧版本" class="headerlink" title="1.卸载旧版本"></a>1.卸载旧版本</h2><p>较旧的Docker版本称为docker或docker-engine。如果已安装这些程序，请卸载它们以及相关的依赖项。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure><h2 id="2-使用存储库安装"><a href="#2-使用存储库安装" class="headerlink" title="2.使用存储库安装"></a>2.使用存储库安装</h2><p>在新主机上首次安装Docker Engine-Community之前，需要设置Docker存储库。之后，您可以从存储库安装和更新Docker。</p><h3 id="设置存储库"><a href="#设置存储库" class="headerlink" title="设置存储库"></a>设置存储库</h3><p>1.安装所需的软件包。yum-utils提供了yum-config-manager 效用，并device-mapper-persistent-data和lvm2由需要 devicemapper存储驱动程序。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install -y yum-utils \</span><br><span class="line">  device-mapper-persistent-data \</span><br><span class="line">  lvm2</span><br></pre></td></tr></table></figure><p>2.使用以下命令来设置稳定的存储库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><h3 id="3-安装DOCKER-ENGINE-社区"><a href="#3-安装DOCKER-ENGINE-社区" class="headerlink" title="3.安装DOCKER ENGINE-社区"></a>3.安装DOCKER ENGINE-社区</h3><p>安装最新版本的Docker Engine-Community和containerd，或者转到下一步安装特定版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure><p>中间一路输入 y 确认回车即可！</p><p>安装完成后，启动Docker。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure><p>设置 Docker 开机自启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure><p>其他常用命令：</p><p>查看 docker 版本:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -v</span><br></pre></td></tr></table></figure></p><p>查看 docker 镜像：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p>今天的分享就到这里，如果对你有帮助，请给我点个赞，或者有任何问题都可以在评论区与我交流哦！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文主要参考 Docker 官方文档的安装为主，官方文档比较繁琐，而且是英文的，因此，我简化了安装的步骤，更适合小白安装。&lt;/p&gt;
&lt;p&gt;官网：&lt;a href=&quot;https://www.docker.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;
      
    
    </summary>
    
      <category term="JavaEE" scheme="https://www.x-sir.com/categories/JavaEE/"/>
    
    
      <category term="Docker" scheme="https://www.x-sir.com/tags/Docker/"/>
    
      <category term="CentOS7" scheme="https://www.x-sir.com/tags/CentOS7/"/>
    
  </entry>
  
  <entry>
    <title>如何评价 iOS 微信深色模式丨第一视角体验分享</title>
    <link href="https://www.x-sir.com/2020/03/28/%E5%A6%82%E4%BD%95%E8%AF%84%E4%BB%B7%20iOS%20%E5%BE%AE%E4%BF%A1%E6%B7%B1%E8%89%B2%E6%A8%A1%E5%BC%8F%E4%B8%A8%E7%AC%AC%E4%B8%80%E8%A7%86%E8%A7%92%E4%BD%93%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    <id>https://www.x-sir.com/2020/03/28/如何评价 iOS 微信深色模式丨第一视角体验分享/</id>
    <published>2020-03-28T03:34:57.000Z</published>
    <updated>2020-03-28T03:37:19.035Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间，苹果要求微信支持 iOS13 的暗黑模式，否则会面临下架风险。</p><p>广大网友纷纷评论说，如果我要是微信我就和苹果硬刚，哈哈哈哈。。。</p><p>其实也不是谁强谁弱的问题，现在都是合作共赢的时代，相互都有利益上的关系，没办法，还是要妥协，只能根据苹果爸爸的要求改咯！</p><p>这不今天 iOS 版本的微信就更新了，支持了暗黑主题，还有一些小的优化和改进，我也都体验了下，很多地方还是适配的不是很好，有点影响用户体验。</p><p><img src="http://image.x-sir.com/1585365035.JPG" alt="1585365035" style="zoom:67%;"></p><p>如果不是程序员，可能会觉得支持暗黑模式不就换个字体颜色么？哪有那么复杂，其实我想说的是，还真比较复杂和麻烦。</p><p>要支持各种情况下的适配和用户体验问题，所以是比较麻烦的一件事。</p><p>另外，还更新了两个小功能：语音发送功能优化，和朋友圈跳到没看的位置。</p><p>先说第一个功能，用了下还是比较方便的，想发语音就发语音，想语音转文字就语音转文字。</p><p><img src="http://image.x-sir.com/1585365040.JPG" alt="1585365040"></p><p>对于不喜欢打字的人来说还是很方便的，可能有些人不知道，微信自己一直在做语音识别的技术，我感觉识别的正确率还是很高的。</p><p>再说下朋友圈跳转到上次没看的位置这个功能，现在的人大部分应该是朋友圈的重度用户，基本每一天都要刷的。</p><p><img src="http://image.x-sir.com/1585365045.JPG" alt="1585365045"></p><p>拿我来说，每天都必须要刷完，刷完的标志是，直到看到重复的内容为止。</p><p>有时候太忙，可能还没刷完就去干别的事了，过了一段时间后，再回来继续刷朋友圈。</p><p>当然你去干别的事的这段时间肯定是有好友发了新的朋友圈，你就这样一直往下刷，直到看到你刷过的内容。</p><p>因为还有你之前没有没有刷过的内容，通常的做法是快速向上滑，直到你刷到你没有看过的内容后继续刷。</p><p>不知道你们是不是也是这样的？</p><p>当有了这个功能之后就特别方便了，就相当于是微信给你在你看过的地方和没看过的地方打了一个标记。</p><p>点击标记就可以自动跳到你没有看的地方，一定程度上节约了时间，尤其是微信好友比较多的朋友。</p><p>我觉得这个功能真的很赞！</p><p>暗黑模式下，有的微信表情本来就是黑的，这就会导致发送的表情看不清楚，影响体验。</p><p>因为表情包大多都是网友或者第三方制作和提供的，微信也控制不了，所以表情包也要针对暗黑模式去做适配。</p><p>比如同一套表情包，应该有两种版本一种是正常模式下的，一种是暗黑模式下的，当你是暗黑模式下，就发送暗黑模式的表情包。</p><p>但是这个地方有个问题，比如你的微信是暗黑模式的，对方的微信是正常模式的，结果你发了一个暗黑模式下的表情包，结果对方看不清楚，这个问题是需要考虑的。</p><p>站在产品的角度，是不可能有两套表情包的，作为用户，每次发送之前还要根据是否是暗黑模式，去考虑应该用哪个表情包，这样太麻烦了，也不符合用户的使用习惯！</p><p>最好的办法是根据是否是暗黑模式去自动转换，或者是这种表情包不管是否是暗黑模式都能正常显示，这样是最好的。</p><p>这只是我自己的一些想法和猜测，微信肯定也会意识到这个问题的，相信后面也会去想办法解决的，毕竟是影响用户体验的问题。</p><p>如果你针对此次微信的更新有自己不同的想法，欢迎在评论区一起讨论！</p><p>科普一个小知识：</p><p>图四是微信钱包里面的账单页面，有的人可能会说，为什么不是黑色的页面？</p><p><img src="http://image.x-sir.com/1585365050.PNG" alt="1585365050"></p><p>这个问题问的好，它这个页面是 H5 页面，你可以理解成是网页，所以它是没办法做适配的，微信中加载的第三方网页链接也是一样的道理！</p><p>区别它是网页还是原生页面，之前没有暗黑模式的时候可以通过进度条来判断，大部分H5 页面在加载的时候都是可以通过是否有进度条就可以判断。</p><p>如果是安卓手机，可以打开手机的开发者选项 &gt; 显示布局边界，打开这个开关就可以了。</p><p>如果找不到开发者选项，因为默认情况下，这个功能是隐藏的，找到手机的的版本号，连续点击 5 次就可以开启，开启之后会有提示的。</p><p>打开微信的账单页面(看下图)，你会看到最顶部的 title 有红色的线条（专业的词叫布局边界），证明这个 title 是用原生写的，然后再看 title 下面的账单部分是没有红线的，说明它是网页。</p><p><img src="http://image.x-sir.com/1585365054.JPG" alt="1585365054"></p><p>这样就可以区分它是原生页面还是 H5 页面了，这种方法适用于安卓手机里的所有 App。</p><blockquote><p>另外，我还建了一个免费的知识星球，感兴趣的微信扫码即可加入！</p><p><img src="http://image.x-sir.com/image_454812848448_8.JPG" alt="image_454812848448_8"></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前段时间，苹果要求微信支持 iOS13 的暗黑模式，否则会面临下架风险。&lt;/p&gt;
&lt;p&gt;广大网友纷纷评论说，如果我要是微信我就和苹果硬刚，哈哈哈哈。。。&lt;/p&gt;
&lt;p&gt;其实也不是谁强谁弱的问题，现在都是合作共赢的时代，相互都有利益上的关系，没办法，还是要妥协，只能根据苹果爸
      
    
    </summary>
    
      <category term="测评" scheme="https://www.x-sir.com/categories/%E6%B5%8B%E8%AF%84/"/>
    
    
      <category term="微信" scheme="https://www.x-sir.com/tags/%E5%BE%AE%E4%BF%A1/"/>
    
      <category term="深色模式" scheme="https://www.x-sir.com/tags/%E6%B7%B1%E8%89%B2%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>程序员篇：不要把自己变成写代码的机器！</title>
    <link href="https://www.x-sir.com/2020/03/22/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%AF%87%EF%BC%9A%E4%B8%8D%E8%A6%81%E6%8A%8A%E8%87%AA%E5%B7%B1%E5%8F%98%E6%88%90%E5%86%99%E4%BB%A3%E7%A0%81%E7%9A%84%E6%9C%BA%E5%99%A8%EF%BC%81/"/>
    <id>https://www.x-sir.com/2020/03/22/程序员篇：不要把自己变成写代码的机器！/</id>
    <published>2020-03-22T06:20:58.000Z</published>
    <updated>2020-03-22T14:49:51.275Z</updated>
    
    <content type="html"><![CDATA[<p>看到这个标题你可能会想，程序员本来不就是写代码的么？</p><p>没错，程序员的主要工作就是写代码，或者说为了实现特定功能或者业务逻辑去写代码。</p><p>作为程序员，代码写得好，功能实现不就行了么？</p><p>这句话看似对，也不对。你品，你细细品！同样是写代码，但是写和写之间差多了。</p><p>初级程序员为了实现功能，更多的是复制粘贴，或者去找一些现成的轮子，这里并不是说复制粘贴不好，不要全部代码都复制粘贴，如果后面需求变了，你可能就束手无策了，要知其然知其所以然。</p><p>中级程序员会考虑如果把代码写的更好，会如何更好的封装代码，比如提高代码的复用性等，会去了解框架的一些原理，也可以根据需求去修改轮子。</p><p>高级程序员会去设计代码，写轮子。另外，还懂一些产品知识，会去了解和讨论需求，会思考这个需求解决了用户的什么问题？有没有解决用户的痛点？有没有更好的实现方式？用户体验怎么样？等等。</p><p>再往上，到了专家的级别，不仅要会架构，而且还要会写 PPT，各种软实力也是必须的，还要有全局观，要能站到更高的维度去思考问题，要有统筹全局的能力。</p><p>你看看，写代码之间的差别大了吧。</p><p>每次产品经理扔给你一个需求，你二话不说，一顿操作猛如虎，就干起来了，等你干完了，等到交付的时候，产品经理告诉你做的不对，应该是怎样怎样的，顿时你心里一万只草泥马奔腾而过。。。</p><p>这也不怪谁，因为每个人的理解能力不同，所以对于同一件事就会产生不同的理解，进而产生偏差。</p><p>当然这种情况是可以避免的，在拿到需求后，首先根据需求的描述，和产品经理一起确认下需求，具体怎么做呢？</p><p>按照自己对需求的理解，复述讲给产品经理听，然后产品经理边听边确认你的理解是否正确，如果有偏差，沟通讨论直到没有异议，经过这个过程后肯定是没有问题的。</p><p>然后再去根据需求去实现代码就 OK 了，如果开发过程中又有问题，那继续去找产品经理讨论沟通就行了。</p><p>最后，经过自己不懈努力地 coding，终于实现了功能，测试也通过了，高高兴兴的交付了，产品也上线了。</p><p>没过几天，产品经理找你说，前几天开发的这个功能要进行修改（需求变更），卧槽！心里又有一万只草泥马奔腾而过。。。</p><p>然后看了看自己的代码，发现前几天写的不能重用，还要大改，顿时感觉自己欲哭无泪，你说作为一个程序员咋就这么苦逼呢？</p><p>说实话，这种感觉我是深有体会的，不是被产品经理折磨，就是被产品经理折磨的路上，不是和产品经理撕逼，就是和产品经理撕逼的路上。</p><p>说实话，需求的变更是很正常的一件事，一个功能不可能永远不变，只要产品在更新迭代，需求就会一直有变更的可能。</p><p>所以，作为程序员不要去埋怨产品经理给你提的需求和需求变更，理论上讲，这种事情是会不间断一直发生的。</p><p>你要做的是，要想方设法去应对各种需求的变更，不管需求怎么变，我的代码都能够灵活应对，或者是尽可能少的改动就能实现了需求的变更。</p><p>这就要你从开始写代码之前就需要去考虑的问题，比如，怎么去设计自己的代码？提前假设下，如果后面需求有变化的时候该怎么办？等类似的问题。</p><p>这样做可以将问题进行前置，由被动应对改为提前主动预防应对，大大提升了代码应对需求变化的适应性。</p><p>虽然这样做前期可能花的时间稍微多一些，但是后面你会省去很多麻烦，节约很多时间，不要想着去返工，那样的效率真的很低，还增加了开发成本！</p><p>有时候，你也会碰见一些比较傻逼的产品经理（不懂产品），给你提的各种奇葩的需求，如果你也不是很懂产品的话，你很可能会被带到沟里去。</p><p>所以，在开发之前一定要先确认需求，去了解这个需求解决了用户的什么问题？这个需求是强需求还是弱需求？这些都要问清楚，不然到后面做完了才发现，费了九牛二虎之力开发的东西没有用，那就尴尬了！</p><p>遇到这种情况就要勇敢的怼回去，不要怕，这样可以避免很多不必要工作量，不是不想做，而是提的需求不合理，给你做毛线！</p><p>都知道我们程序员大多都比较憨厚老实，善良耿直，每天和机器打交道，培养了自己标准的线性思维模式，在程序员的的世界里，不是 true 就是 false。</p><p>有时候在遇到事情的时候，不会太变通，容易钻牛角尖，容易把自己绕进去出不来，所以，平时要和别人多交流，多打交道，变通去思考和解决问题。</p><p>大家都知道去年在网上流传的很火的一个视频，某个公司的产品经理要求程序员实现一个需求，要根据手机壳的颜色来实现 App 主题的变化，这个程序员听完之后就和产品经理打起来了。</p><p>假设当你们遇到这个需求的时候，你会怎么做？后来网上也出现了各种奇葩的解决方案，比如，手机壳的颜色会反射到眼睛里，然后手机再通过摄像头去进行眼睛虹膜识别出颜色，然后再设置主题色。等等还有很多比较新奇的答案。</p><p>我想说的是，大家的脑洞是真的大，真的是感觉眼界大开，眼前一亮的感觉。</p><p>这个问题说到底，其实还是思维方式的差异，程序员的思维方式是偏向于解决问题，怎样做才能实现这个功能？而产品经理更加关心的是这个功能的效果，不管你怎样去实现。</p><p>因此，换位思考是特别重要的，程序员冲动打人是不对的，不管什么需求，先去沟通，去了解，相信很多问题都是可以通过沟通去解决的。</p><p>就拿刚才那个需求来说（先不讨论这个需求解决了什么问题），你可能稍微变通一下就可以解决，用户肯定是知道自己手机壳的颜色的，当用户打开 App 的时候，可以让用户选择设置一下不就可以了吗？非要搞得那么复杂干嘛。</p><p>冲动是魔鬼！</p><p>对于程序员来说，敲代码重要，但是沟通技巧，产品思维，也同样重要，程序是为产品服务的，产品是为用户服务的。</p><p>作为程序员，要学会聪明地去敲代码，而不是把自己变成一个敲代码的机器！</p><p>希望能引起大家的思考，当然也欢迎大家在评论区一起学习讨论。</p><p>如果我上面写的文章中，有一到两点对你来说有帮助或者启发，我觉得就已经很开心了，如果你觉得我的文章写的不错，可以给我点个在看，如果你有什么问题，也可以在评论区给我留言。</p><p>如果您觉得我的文章对你有帮助，可不可以给我打赏一下，一块就好，对你来说可能一块钱没什么，但对于写作者来说，这个意义重大，它是坚持写作下去的动力，这样也能为读者持续不断的创造价值！</p><p>再次感谢我亲爱的读者朋友们！</p><p>另外，我还建了一个免费的知识星球，感兴趣的微信扫码即可加入！</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLngtc2lyLmNvbS96c3hxX3FyY29kZXpzeHFfcXJjb2RlLmpwZw?x-oss-process=image/format,png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看到这个标题你可能会想，程序员本来不就是写代码的么？&lt;/p&gt;
&lt;p&gt;没错，程序员的主要工作就是写代码，或者说为了实现特定功能或者业务逻辑去写代码。&lt;/p&gt;
&lt;p&gt;作为程序员，代码写得好，功能实现不就行了么？&lt;/p&gt;
&lt;p&gt;这句话看似对，也不对。你品，你细细品！同样是写代码，
      
    
    </summary>
    
      <category term="程序员" scheme="https://www.x-sir.com/categories/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
    
      <category term="编程" scheme="https://www.x-sir.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="经验分享" scheme="https://www.x-sir.com/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    
      <category term="程序员" scheme="https://www.x-sir.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="个人提升" scheme="https://www.x-sir.com/tags/%E4%B8%AA%E4%BA%BA%E6%8F%90%E5%8D%87/"/>
    
  </entry>
  
  <entry>
    <title>迟到的 2019 年个人总结</title>
    <link href="https://www.x-sir.com/2020/01/22/%E8%BF%9F%E5%88%B0%E7%9A%84%202019%20%E5%B9%B4%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    <id>https://www.x-sir.com/2020/01/22/迟到的 2019 年个人总结/</id>
    <published>2020-01-22T15:47:57.000Z</published>
    <updated>2020-03-22T14:49:27.938Z</updated>
    
    <content type="html"><![CDATA[<p>2019 年已经过去十多天了，前段时间真的是太忙了，公司的各种事情，工作述职，年会节目等等，忙的手忙脚乱，一直计划着的个人年终总结一直推迟到现在才写，我觉得还是有必要记录一下的。</p><p>对去年的工作、生活和学习做一个简单的复盘，总结下自己有哪些成长，哪些方面做的还不是很好，不好的地方要多去反思和改进，好的地方要继续保持和优化，这样才能不断成长和提升。</p><p>2019 年也是我心态转变最大的一年，经历和遇到了许多事情，经过这些事情，感觉自己越来越沉稳了，想明白了自己最想要什么，什么才是对自己最重要的东西，并且要朝着自己想要的方向去努力，下面就通过几个方面来说说吧。</p><h2 id="1-工作"><a href="#1-工作" class="headerlink" title="1. 工作"></a>1. 工作</h2><p>站在现在来看，我算是比较幸运的，18 年找工作的时候，当时经历了创业公司的坑，所以一心想找一个大一点稳定的公司，现在看来我当时的选择是挺正确的，从 18 年底到现在，整个大环境和各个行业都不是景气，而我们的公司去年的效益也不是很好，但是没有裁员，比较稳定，工作上也比较顺心，相比那些被裁的朋友们，我算是比较幸运的！</p><p>去年伊始，首先被曝出的是几个大公司的裁员和一些小公司的倒闭，就我知道的身边的有好几个同学他们的公司就被裁员和解散了，还有的小公司工资也发不起了，这就直接损害到的直接利益了，这就太坑了，后来大家也都知道某东、渣易等一些头部公司的裁员事件。</p><p>相比公司来说，员工是弱势群体，尤其是我们的程序员群体，大多都比较老实憨厚，容易被公司损害自己的合法利益，我们要做得是当我们的利益被损害的时候我们要保护好自己，保留好证据，通过法律程序来帮助我们，遇到侵害时，要及时止损！</p><p>虽说有法律来保护我们，但是我们也不能完全依靠法律，一般走法律途径也是需要时间和精力的，一般处理时间比较长，我们也要考虑自己的时间成本，因此我们要不断提升自我保护的意识，这样才能最大程度保护自己的合法权益不被侵害。</p><p>公司是商业机构，是要赚钱的，职场上不要讲什么人情，当你的利益受到损害时，老板还给你讲什么人情或者画大饼，如果你还去相信，我只能说你 too young, too naive 了！</p><p>关于裁员说几点，被裁了也没关系，如果你能力很强，不管在什么时候都是不怕找不到工作的，就怕是那些没能力，整天上班划水的人，我只能说不裁你裁谁呀？</p><h2 id="2-学习"><a href="#2-学习" class="headerlink" title="2. 学习"></a>2. 学习</h2><p>专业技能方面，更多地是在偏向于大前端的学习，大前端的概念这两年也是特别火的一个话题，也是未来移动开发的一个趋势吧，利用闲余时间学习了公众号的开发和微信小程序开发试水，Android 方向主要是学习 Google 的组件化架构和 jetpack 的相关东西。</p><p>另外也坚持在开源社区贡献自己的代码，GitHub 上显示 350 contributions，主要是维护和更新自己的开源项目，star 也相比之前多了几十个。</p><p>另外，在业余时间学习了后台的一些东西，比如SpringMVC、nginx、MySQL 数据库，Maven、Swagger 等相关的知识，更新和迭代了自己的 Java 后台项目。</p><p>还利用闲余时间坚持学习英语，主要是提升自己的口语能力，先是报了一个 100 天的水滴阅读课程，坚持打卡了 100 天，累计阅读字数 88895 字，阅读了三本英语原著，分别是《小王子》、《爱丽丝梦游仙境》、《彼得潘》三本书，并成功领取了三本实体的书，此处给自己的坚持打 call。</p><p>另外，在去年 7 月份的时候买了一个英语课程，共花费了 11660 元，主要是偏向于生活交流和口语的提升，说实话，这个课程打破了我以前对英语学习的一些错误的认知，对我来说帮助还是挺大的。</p><p>当然不止是英语，还有其他方面的提升，这里也不建议所有人都花钱去学习英语，把钱花在当下你最需要提升的技能上，如果你工作了，有经济能力，那么另说，一次性花这么多钱买课程是比较贵的，但是，如果你把眼光放长远，平均下来也还好，我现在我也有经济能力去支付课程的费用，现在对我来说最重要的是时间，时间一旦错过了就再也没有了。记住，学习是对自己的投资，不是消费，花多少钱都是值得的。</p><h2 id="3-写作"><a href="#3-写作" class="headerlink" title="3. 写作"></a>3. 写作</h2><p>主要还是偏向于技术方面的文章比较多，CSND 上发表原创文章 19 篇，总访问量将近 45w，总排名挤进了 1w 名内，也新增了两个新的专栏「RxJava2.x教程」和「Android 自定义View」,2020 年计划计划再写 10 篇左右的高质量原创技术文章，进一步提升自己的影响力，目标是拿到「技术专家」的勋章！总阅读量到年底的时候冲击 80w 访问量，加油吧！！！</p><p>另外，公众号上也发表了 16 篇原创文章，公众号没有好好运营，更新周期也不固定，粉丝数量也不太多，分析原因主要是写作缺少动力，每次写文章至少要花费好几个小时，而且阅读量也不高，导致很难坚持下去。</p><p>我的公众号还有一个问题，就是方向不确定，各种类型的文章都有，有技术的，有产品的，有自己思考的，还有思维方面的，所以比较杂乱，刚开始是想着做一个垂直的细分领域的技术号（Android方向），后来发现市面上已经有很多大佬已经做起来了，我不管怎么做也是竞争不过他们的。</p><p>还有一个考量是，微信公众号不适合写技术文章，我指的是某一个具体的代码实现等，因为这不符合用户的使用场景，大多数人都是利用闲鱼时间、或者公交地铁上看文章，我问下你自己，你会完整的看一篇贴了代码的文章吗？</p><p>大多数人其实都是快速浏览一下，然后点个收藏就完事了，然后你上班的时候遇到问题，还不是去度娘或者 Google 搜索吗，你说是不是？你收藏的文章基本上也是就死躺在那里了，所以技术文更适合于像 CSDN 这种博客平台好一些，所以，我现在大部分的文章首先会发布到 CSDN 等平台上。</p><p>大家可能都对写作有一些误解，说自己没文采，没写作的技巧等等，如果你去问一些头部的大 V 们，他们会说：写作哪有那么多的技巧，谁还不是吭哧吭哧坚持写了好多年，到最后才会看到效果，当然也不排除一些天生的写作奇才，但是哪些人能有几个呢？</p><p>我们都是普通人，还是踏踏实实的一步一个脚印坚持下去吧。2020 年计划，确定好公众号的方向，有几个问题是需要我考虑的，你的目标用户是谁？在哪里？你能提供什么价值给他们？确定好了之后，好好写几篇精品文章，不要注重文章的数量，要提升文章的质量，输出更多高质量的原创文章，降低推送的频率，然后去引流、获客！</p><p>年中的时候和几个公众号号主进行了一个互推的活动，效果不是很好，现在很多公号都在商业互吹，说白了就是共享自己的读者，相互关注，导致最后关注来关注去，到最后关注的公众号特别多，我记得我最多的时候关注了有 500 多个公众号。</p><p>说实话，你经常看的公众号其实也就那么几个，关注的大多数公众号的文章质量不高，大量的文章推送，抬高了读者筛选信息的门槛，打扰了读者，这不是一件好事情，所以，还是要想办法去给读者创造价值，只有你的文章有价值了，你的读者也会对你有价值！</p><p>如果你的文章写的真心不错，读者早晚会知道的，写作的时候少点功利心，踏实认真写字，把你的能量附着在你的字里行间，帮助读者解决问题，传递价值，你的文字早晚会发光的。</p><p>如果你是做自媒体的，现在公众号已经过了红利期，如果放到几年前，还是有机会的，现在做起来真的是比较困难的，你也许会说，不是也有一些新的公众号主不是也做起来了吗？是的，有啊，我说的是对于大部分普通人来说，想做起来是很不容易的。</p><p>现在做起来的也是凤毛麟角，而且有的人之前本身在其他平台写了很多年，已经有一些影响力的，积累了一些忠实读者，并且已经有很深的文字功底在那放着，人家是有那个实力做起来的，比如「半佛仙人」，当然像半佛仙人这种能有几个呢？</p><p>像写作这种技能，短期是看不到什么效果的，如果长期坚持下去，是有复利效果的，这也是我为什么推荐大家坚持写作的原因，对于刚开始写作的人来说，你只要能把一件事情用通俗易懂的话讲明白、说清楚就行了，其实大多数人缺的不是写作的技巧，缺的是行动力！</p><p>另外，再说一点，为什么说公众号是自媒体创作的首选呢？虽说公众号已经过了红利期，但是微信的生态对于创作者来说是非常友好的，比如对于原创文章的保护机制，还有读者和创作者的订阅关系，也就是说只要用户关注了你的公众号，他就可以收到你推送的文章，还有后期的变现等，最近微信又邀请公测了公众号付费阅读功能，这对创作者来说是一大利好啊！</p><p>而有的平台是推荐机制，比如微博、头条系等，你写的文章是通过推荐算法推荐给读者的，文章的阅读量都是不稳定的，阅读量都是可以靠一些手段刷上去的，有时候你在某个平台上看到有的文章的阅读量是 10w+，甚至上百万+，其实这并不代表什么，光看这个数字是很虚的！</p><p>像头条系这种，做的是下沉的用户，各种用户群体都有，文章的总体质量是不高的，但是它的流量是巨大的，所以，你可以用各种方法将流量导流到你的公众号上，这样的用户才是你的真正的用户，这样后期也比较好运营和变现。</p><p>再说下知乎，现在知乎也没以前那么火了，主要是内容的质量参差不齐，鱼龙混杂，好多带节奏的文章和回答，广大网民的辨别能力又比较差，很容易被带节奏，有时候也还会碰见一些喷子，有一句怎么说来着，不是煞笔变多了，而是煞笔学会上网了，在全民互联网时代，你会碰见各种奇葩的人和事，见多了也就不足为怪了。</p><p>如果是做自媒体的，知乎还是占很大一部分流量的，知乎也是推荐算法规则的玩法，一个知乎账号的综合等级主要看三个方面：权重、盐值和各类的百分比构成。权重就是你在某个垂直领域内回答问题，发表文章，点赞，评论和喜欢等行为，你的账号的权重越高，你的回答更容易被推荐而获得流量，点赞排名越靠前，你的影响程度也越高。</p><p>另外再说一下回答问题，多回答知乎邀请你让你回答的问题，最好是一些高质量的回答，在回答中也可以带一些勾子，你也可以在文章中放一些勾子，将其引流到你的公众号中，别看这小小的勾子，如果运用好的话，长期下来也会给你带来不少关注的。</p><p>再来看下我运营的知识星球，官方数据如下：共有 262 条主题，获得赞同 503 次，球友近 200，这个数据不是去年的数据，而是自星球创建一来总的数据，相比来说，这样的数据还是比较惨的。</p><p>主要是没有好好运营，人数也比较少，大多都在潜水，没有一些机制让球友主动分享和交流，后面要多思考，激发球友的分享热情，另外也可以设置一些奖励的机制等等，比如被加精的好文给赞赏，或者设置类似于「生财有术」星球的龙珠的玩法等。</p><p>另外还更新了自己的个人网站，重新使用 HEXO 搭建了下，现在 UI 界面更加美观和简洁了，另外还做了 SEO，网站主要是同步更新自己写过的一些文章，访问量也不是很高，另外还对网站做了公安备案！</p><p>感兴趣的可以去看：<a href="https://www.x-sir.com，搭建教程：[点击此处查看](https://mp.weixin.qq.com/s/V28ehCI6ep8t0zVR4R5uJg)" target="_blank" rel="noopener">https://www.x-sir.com，搭建教程：[点击此处查看](https://mp.weixin.qq.com/s/V28ehCI6ep8t0zVR4R5uJg)</a></p><p>如果在搭建过程中有什么问题，也欢迎大家在评论区留言，或者在我的知识星球「IT大本营（限免）」中进行提问。</p><h2 id="4-理财"><a href="#4-理财" class="headerlink" title="4. 理财"></a>4. 理财</h2><p>18 年的时候接触了“屁兔屁“，当时都还是没问题的，国内相关的公司特别多，当时也投了一部分，都是投的几个月短期的，没有问题，后来又一部分投的是 1 年期的，自从 18 年底开始，各大“屁兔屁“公司开始暴雷，我当时就有点慌了，干着急没办法，没到期又取不出来，只能祈祷在到期之前希望公司不要被清查，眼看着一家一家公司倒下去，我投资的那个平台不知道能撑多久。</p><p>故事的结尾都是悲伤的，就在资金还有两个月到期的时候，我投资的这个公司也被清查了，清查的好突然，在行业中这个公司也是比较有影响力的上市公司，也被清查了，后来也报案了，警方也在处理，不过这个过程处理的时间很长，通常是需要 2-3 年时间的，不知道到时候能拿回多少，我也就不报太大的希望了。</p><p>通过这件事，也算是给自己买了一个教训吧，总结下来就是当时对“屁兔屁“的认知不足，导致了自己的经济损失，也算是一次自我成长吧，在生命的长河中，人总是要经历点什么，才会变成为一个皮实的人！</p><p>后来又学习了一些股票和基金的相关知识，学习是为了对这个事物有更加清醒的认识，这样才能适应这个社会，在社会上立足，我从来不会在公众场合推荐大家去炒股，对于大多数人来说，都是韭菜，股市中，10 个人炒股，8 个人亏，1 一个人平，1 一个人盈，你觉得你是哪个幸运的人吗？</p><p>对于大多数人来说，买指数基金就行了，或者定投，这样可以强制自己储蓄，基金定投比较灵活也不用考虑高点还是低点，长期的坚持会拉平你定投的高低点，也不用花时间去了解各种 K 线图，特别适合大部分的普通人，巴菲特也说过一句话：买一支指数基金，然后努力工作吧。</p><p>大多数人对理财是有误区的，理财的首要目的是保值，因为国内通货膨胀的缘故，我们要分配自己的资金，好多人都想着通过炒股来赚钱，这个观念是错误的，凡是都是想通过炒股去一夜暴富的人都是不想去努力，偷机的人，就算你凭运气暴富了，你也会凭实力亏掉的！因为你的思维认知是驾驭不了与你自身实力相匹配的金钱的！</p><p>可能有的人对“屁兔屁“和基金股票之间的区别不太清楚，我这里就给大家简单讲下吧，“屁兔屁“严格来说是不合法的，资金不受国家监管，其实做的是表面合法，暗地里非法的生意，基金和股票是国家专门监管的，有严格的管理，所以，你的资金是不会有风险的，当然也就不存在跑路的情况。</p><p>去年 2 月份的时候接触了且慢，跟着 E 大投了长赢计划，通过这个计划，期间经历了钻石坑，一直坚持到了现在，目前收益还可以，中间真的是特别煎熬的，因为中国的股市是一个熊长牛短的过程，大部分的情况下你都是出于熊市的，真的挺磨炼人的心态，我很佩服 E 大的投资理念，真的是太理性了，特别喜欢他说的一句话：踏踏实实的，多大点事儿！</p><p>且慢的产品还是特别适合大部分上班族的，不需要太多的时间，就能理财，也不需要学习复杂的投资技巧，定投或者跟投就可以了，我这里也不推荐大家，自己去权衡吧，不一定适合所有人。</p><h2 id="5-消费"><a href="#5-消费" class="headerlink" title="5. 消费"></a>5. 消费</h2><p>今年最大的一笔开销是买了一部 iPhone Xs，这也算是今年的最大一笔消费吧，我是从 16 年开始用的 iPhone 手机，当时买的是 iPhone 6s，一直用到 19 年，用了 3 年多，现在感觉回不去了。</p><p>买 iPhone 倒不如说是买 iOS 系统，说实话 iPhone 系统的产品体验是非常好的，还有在安全性方面也是让人很放心的，大家都吐槽说它太封闭了，我认为正是因为它的封闭，才能保证产品的质量和用户的体验！</p><p>我的消费理念是，每天高频使用的东西，就是要买好的贵的，比如手机、电脑、电动牙刷等，这些东西不仅能提升你的效率，给你更好的用户体验，还能提升生活的品质，而且它也不是易耗品，买了之后你可以至少用个几年都没问题的。</p><h2 id="6-健身"><a href="#6-健身" class="headerlink" title="6. 健身"></a>6. 健身</h2><p>去年 3 月份的时候报了一个健身房，开始健身之旅，这也是我第一次报健身房，现在这个年龄，感觉身体是越来越重要了，尤其是现在的年轻人都是办公室上班，平时的运动量都比较少，因此我觉得如果条件允许报一个还是很有必须要的，为了身体健康，花多少钱都是值得的。</p><p>刚开始进健身房的时候，真的是一脸雾水，各种器械都不会用，只能是看着别人然后模仿着训练，回来后，在网上找一些视频学习，但是还是没有一个人指导自己，很容易把动作做错，也体会不到发力点，所以后来报了私教课，让教练一对一的辅导。</p><p>刚开始学的时候的动作必须是要做到位，否则错误的动作可能会导致一些反作用，比如你想练胸，结果臂越来越粗，这种钱的话我也觉得是有很必要花的，一旦学会了各种锻炼的方式方法，还有器械的使用，你后面就可以自己练习了，或者你找一个认识的人带带你也是可以的。</p><p>教练的作用就是给你传授一些锻炼的方式方法和督促的作用，主要还是要靠你自己，在这健身的期间，也学习到了很多健身的知识，比如饮食方面、健身的补充剂，注意事项等等，还有一些健身的误区，拉伸的技巧等。</p><p>锻炼了几个月，明显感觉到了身体的变化，但是健身是一个长期坚持的事情，一旦停下来，身体就会回到原来的状态了，贵在坚持吧。</p><p>我一般会习惯性的把每次健身的数据记录到 Keep 上，到目前为止，keep 显示跑步的数据为 267 km，健身 816 min，行走 1032 km，累计 494 day，总运动时长 21670 分钟，等级升到了 KG.9，这个数据不是去年的数据，是总数据，总的来说相比之前健身的时间更多了，2020 年继续抽出更多的时间去健身。</p><p>健身不仅让你的身体的体型体态会变的更好，也能锻炼你的意志力，也能提升你的自信，让你变的更年轻有活力，皮肤也会变好的，只有你的身体变强壮了，才能更好的工作和生活！何乐而不为呢？</p><h2 id="7-社交"><a href="#7-社交" class="headerlink" title="7. 社交"></a>7. 社交</h2><p>去年参加的社交活动比较少，平时也比较宅，其实我不是宅，我是不喜欢没有意义的社交活动，如果是我喜欢的，我还是比较喜欢出去浪的。</p><p>2020 年努力提升自己，希望多认识一些行业大佬，多交流或者线下面基，参加更多的社交活动，认识更多的牛人，其实这也算是结识人脉的一种方式吧，随着你年龄的增长，你会发现人脉越来越重要，说不定以后会帮到你，如果你可以提供价值，也是可以帮到别人的。</p><p>在信息高速发展的今天，很多人都是在网上聊，但是网上和线下是不一样的，有些话只能在线下见面说，有一句话怎么说来着：网上聊千遍，不如线下见一面。</p><h2 id="8-跨界学习"><a href="#8-跨界学习" class="headerlink" title="8. 跨界学习"></a>8. 跨界学习</h2><p>去年利用闲余时间学习了销售、心理学、公众演讲、性格、两性关系、潜意识、执行力等相关内容的学习，说真的，学到了不少东西。</p><p>为什么要学销售？大家可能对销售这个词的理解比较狭隘，它不仅仅是我们通常理解的卖东西，其实生活中的好多东西都是可以看做是销售的，比如，你找工作去面试，也可以看成是销售，你自己就是产品，公司就是目标客户，面试说白了就是你要想方设法把自己销售出去。</p><p>如果你要卖一个东西，你要先了解顾客的需求，可以通过简单的提问去了解顾客的真实的需求，而不是一上来就介绍你们的产品多好多好，很多时候你说的其实不是顾客真正想要的，真正的销售是你要引导顾客多说，你自己少说。</p><p>你要先了解顾客的心理，其实这又涉及到了心理学的相关知识，更严格的词叫做销售心理学，当你把握住了很多点的时候，然后你再去进行推销你的产品，这样才能更容易的达成成交！</p><p>现在的顾客都不傻，防备心都比较重，如果你不停的说，会让顾客很烦的，顾客一旦烦了，你的东西基本上是卖不出的，销售不是本文的重点，如果你们对销售感兴趣的话，我后面给大家写一篇很详细的文章。</p><p>大家对销售可能还有一个误区就是，销售是针对某个产品和领域的，其实不是，销售的技巧是通用的，不管是销售什么产品，都是可以灵活运用和切换的，当你学会了销售的套路了，不管什么东西你都是可以卖的。</p><p>我们再来看下公众演讲，首先给大家抛一个问题：为什么要会公众演讲呢？举个栗子，假设有两个销售人员，一个会公众演讲，一个不会，同样销售能力下，你觉得哪个销售人员的成交量更高一些？</p><p>答案肯定是显而易见了，如果你在一个 100 人的场合进行公众演讲，然后销售你的产品，假设成交率是 10%，也就是说成交了 10 个人，如果不会公众演讲的销售人员，它的平均成交是每天 1 个人，那么，公众演讲销售带来的成交相当于是普通销售员 10 天的成交人数，假设公众演讲的人数是 1000 人呢？然后再按年计算，每年平均讲 100 场，结果不用算了，是很恐怖的，至少是普通销售员的上百倍了。</p><p>这里我把它总结为：公众演讲 + 销售，销售只是一个具体的技能，也可以换成其他的技能，万能公式是：公众演讲 + ？，因此我觉得公众演讲也是一个非常重要的技能，当然不是每一个人都适合公众演讲的。</p><p>如果感兴趣的话可以尝试着去学习下，但是肯定是需要大量反复去练习的，你还要有强大的控场能力，幽默，还有随机应变的能力，一般来说，活跃型的人比较适合做演讲。</p><p>再来说下性格吧，我学习的是四象限的性格模型，有活跃型、能力型、完善型和平稳型四种，其实每个人一出生，性格都已经定了。</p><p>你从小孩的哭声就基本能判断出他是什么性格了，比如有的小孩就是特别喜欢哭和闹，那么他基本就是属于活跃型性格了，有的小孩特别安静、哭几声哄一哄立马就不哭了，那么大概率这个小孩是平稳型或者完善型的性格。</p><p>活跃型的人外向、多言者、乐观，大声、引人注意，好动、数字不敏感、健忘、先张嘴后思考、热情、说话喜欢夸张，情感与身心表现：天真、善变、心宽体胖，不生气，不记仇、外向情感型，对别人无所谓，对自己也无所谓。</p><p>能力型的人天生自信、权威、控制、好争论，坚持己见、好斗、义气、正直，生活在目标中，注重方向轻细节，急性子，有主见，行动力强，对别人要求严格，对自己无所谓。</p><p>完善型的人天生内向、思考着，悲观，表象与社交关键词：严肃、得体、礼貌、矛盾、紧张，先思考后发言，敏感，交友慎重，生活上整洁有条理，作息比较规律。情感与身心：生活在自己的内心感受里，消极，忧虑，消瘦，习惯计划，但常常难以行动，认真、理性，情绪化，内向情感型，对别人要求严格，对自己也要求严格。</p><p>平稳型的性格是天生的内向旁观者，悲观，平和、缓慢不愿引人注意，善良、幽默，能不开头尽量不开口，难以决定、好领导。生活在平静中，健康、冷静、太弱自然，有耐心，知足常乐，情感丰富、不露声色。对别人不要求，对自己不苛求！</p><p>其实，每个人都不止一种性格，每种性格所占的比例是不一样的，占比最高的就是你的主导性格，比如你完善型的性格占 70%，活跃型和能力型各站 15%，那么你的主导性格就是完善型。</p><p>你可以对照着上面的一些关键词来判断自己属于哪种性格，你可以判断其他人，当你了解了性格之后，然后戴着性格的眼睛去了解他人，和他人打交道，这样沟通和交流起来就比较容易了，他的很多行为你也就很容易理解了。</p><p>再说说两性关系吧，因为男女思维方式的差异，导致男生和女生思考问题的方式和角度是不一样的，因此，同一件事情思考不同，所关注的点不同，就会产生矛盾或者不和，其实这个不是谁对谁错的问题，女生一般考虑问题都是比较感性的，而男生的话都是比较理性和直接的，偏向于解决问题，而女生更注重感受或者是体验，是非理性的。</p><p>在遇到问题的时候，要多站到对方的角度去思考，所以你要先了解男女的思维上的差异，这样也就更能理解对方的一些行为了，还要多沟通，多交流，当你们敞开心扉把问题都说出了，其实问题也就迎刃而解了，最怕的是两个人都不说，谁都不低头，相互猜忌，导致最后变得很糟糕，作为男生就要主动一点，承担起责任，一起去解决问题！</p><p>情商也是非常重要的，同样一件事，情商高的人会让人觉得很舒服，包括两性关系也是如此，每个人都有自己的生活方式，每个人都有选择自己想要的生活的权利，不要试图要求或者强加对方，把对方变成自己想要的样子，可能最终的结果就是，Ta 再也不是当初的那个 Ta 了！</p><p>其实，情商也是分等级的，低阶情商是照顾他人的情绪，高阶情商是，传递价值，照顾他人的利益，首先要要学会控制自己的情绪，然后去察觉和影响他人，不要眼里只有自己，多替他人想一步，情商比智商更重要！</p><h2 id="9-旅行"><a href="#9-旅行" class="headerlink" title="9. 旅行"></a>9. 旅行</h2><p>很遗憾去年基本没出去玩过，都是在上海周边溜达了下，其实心里想去的地方还是很多的，比如成都、云南、厦门、三亚等，国外的话想去泰国、新加坡。从来没有出过国，一想到出过旅行，还是比较期待和激动的。</p><p>去年也已经办好了护照，也在网上了解了一些游玩的攻略，现在就等一个美好的时机了，趁着年轻多出去走走，看看别国的风土人情，会让你有不一样的感受的，世界那么大，我想去看看，期待 2020 年有机会看到最美的风景！</p><h2 id="10-2020-计划"><a href="#10-2020-计划" class="headerlink" title="10. 2020 计划"></a>10. 2020 计划</h2><p>①.学着做几个可口美味的菜，作为一个新时代的男性，要十八般武艺都会，不然很难在这个社会上立足，也是为了以后成家立业后，能给喜欢的人做一顿丰盛美味的拿手好菜，有一句话是这么说的，要想抓住 Ta 的人，首先要抓住 Ta 的味蕾。</p><p>②.英语口语练习，继续加强自己的练习，多学习，多积累，持续行动，到年底的时候尽量能达到脱口而出的程度，能和老外进行最基本的日常交流。</p><p>③.多读书、多旅行，多提升自己的内在，做一个内心强大的男人，努力让自己发光，你若盛开，蝴蝶自来。</p><p>④.多赚钱！多赚钱！多赚钱！重要的事情说三遍！没有一份工作是可以干一辈子的，靠死工资也是不会暴富的！尤其是程序员这个职业，行业普遍都认为是 35 岁危机，因此要提前做职业规划，发展第二职业也是非常有必要的。</p><p>其实，我很早之前就关注这方面了，前期主要是学习和积累的阶段，计划在今年进行各种尝试，发展几个自己的副业，目前比较好的方向和趋势有：社交电商、短视频领域，短视频尤其是以抖音为首的平台，现在的流量是非常巨大的，财报显示，字节跳动公司 2019 年营收超 1400 亿元，其中抖音至少贡献了一半的营收。</p><p>由短视频衍生出来的有短视频相关的工具，还有短视频的剪辑和后期的处理，还有拍摄制作等等，都是需要专业的人才的，以后的机会还是比较多的，随着 5G 越来越普及，短视频会越来越普遍的，大家发朋友圈可能都是以图片为主，以后可能人人都能随手发一个制作精美的视频了。</p><p>这个市场是非常巨大的，说实话，现在做短视频的人很多，但是能做起来的不多，不要一股脑子，一头扎进去，瞎忙活，我觉得前期还是要多学习一些头部号，多模仿，多分析火的视频为什么会火？要多站到消费者的角度去理解，多尝试、多总结。</p><p>现在实体行业越来越不好做了，主要是太重了，前期都要投入好多的资金进去，投进去之后也不知道什么时候才能回本，存在很大的风险，还有各种运营的成本都是比较高的，所以特别不好做。</p><p>这两年流行轻资产创业，轻资产创业就是产品越轻越好，投入越少越好，你可能只需要一台电脑、一部手机就可以了，基本没有什么投入，唯一投入的就是你的时间成本，而这种时间成本都是有复利效应的，就看你能把你的时间卖出多少份了，卖的份数越多，赚的越多！</p><p>另外，选择也是非常重要的，要借助平台的势能将自己的技能放大，尤其是一些新出来的高速发展的平台，比如拼夕夕，小红书等等。</p><p>最近 B 站又火了，大家都比较看好，都说 B 站有可能成为未来中国的 youtube，我知道的几个小伙伴 B 站的粉丝量都已经一两万了，有的小伙伴做的就是搬运工，从 youtube 把一些视频搬过来，都已经做的很不错了！</p><p>拼夕夕今年的市值也已经超过了京东，从以前大家骂他卖假货到去年的百亿补贴活动，品牌形象不断升级，现在大家通过补贴优惠买到东西的都说：真香！</p><p>大家还吐槽它的售后差，说实话，我之前也买过一个东西，退货确实挺麻烦的，时间也长，我相信后面会越来越好的，毕竟它还年轻，给它点时间成长。</p><p>⑤.最后，感谢 2019 的那些经历，让我成长，2020 继续加油干！！！</p><p>好了，我的个人总结就写完了，断断续续写了好多天，终于写完了，文章比较长，能看到最后的都是忠实的读者，给你们点赞！</p><p>标题虽说是个人总结，你读完了会发现，也不仅仅是，中间也有我的一些思考，和未来一些趋势的判断，希望对你们有价值！</p><p>因为每个人的阅历和知识储备都不一样，文章中有一些比较专业的词汇，如果不理解或者不懂的，可以打开维基百科查阅和学习。</p><p>如果我上面写的文章中，有一到两点对你来说有帮助或者启发，我觉得就已经很开心了，如果你觉得我的文章写的不错，可以给我点个在看，如果你有什么问题，也可以在评论区给我留言。</p><p>如果您觉得我的文章对你有帮助，可不可以给我打赏一下，一块就好，对你来说可能一块钱没什么，但对于写作者来说，这个意义重大，它是坚持写作下去的动力，这样也能为读者持续不断的创造价值！</p><p>这可能是我年前的最后一次推送了，首先再这里祝大家新年快了，心想事成！为了感谢读者朋友们长期对我的支持，我在读者朋友中，抽取 66 个幸运儿，奖励红包作为福利，获取方式：公众号后台回复“新年快乐”，长按小程序码即可抽奖！</p><p>再次感谢我亲爱的读者朋友们！</p><p>另外，我还建了一个免费的知识星球，感兴趣的微信扫码即可加入！</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLngtc2lyLmNvbS96c3hxX3FyY29kZXpzeHFfcXJjb2RlLmpwZw?x-oss-process=image/format,png" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;2019 年已经过去十多天了，前段时间真的是太忙了，公司的各种事情，工作述职，年会节目等等，忙的手忙脚乱，一直计划着的个人年终总结一直推迟到现在才写，我觉得还是有必要记录一下的。&lt;/p&gt;
&lt;p&gt;对去年的工作、生活和学习做一个简单的复盘，总结下自己有哪些成长，哪些方面做的还不
      
    
    </summary>
    
      <category term="程序员" scheme="https://www.x-sir.com/categories/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
    
      <category term="程序员" scheme="https://www.x-sir.com/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
      <category term="个人提升" scheme="https://www.x-sir.com/tags/%E4%B8%AA%E4%BA%BA%E6%8F%90%E5%8D%87/"/>
    
      <category term="写作" scheme="https://www.x-sir.com/tags/%E5%86%99%E4%BD%9C/"/>
    
      <category term="个人总结" scheme="https://www.x-sir.com/tags/%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
    
      <category term="年终总结" scheme="https://www.x-sir.com/tags/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Android 自定义一个简单的刮奖 View</title>
    <link href="https://www.x-sir.com/2019/09/18/Android%20%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%88%AE%E5%A5%96%20View/"/>
    <id>https://www.x-sir.com/2019/09/18/Android 自定义一个简单的刮奖 View/</id>
    <published>2019-09-18T05:40:05.000Z</published>
    <updated>2019-09-18T05:41:09.758Z</updated>
    
    <content type="html"><![CDATA[<p>实现思路：</p><p>使用相对布局，先写一个 TextView，然后自定义一个 EraseView，写一个同样大小的 EraseView 覆盖在 TextView 上面即可。</p><p>先看下效果图:</p><p><img src="https://img-blog.csdnimg.cn/20190918133340585.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbnBlbmdmZWk1MjE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>代码也比较简单，我就直接贴上了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">public class EraseView extends View &#123;</span><br><span class="line"></span><br><span class="line">    private boolean isMove = false;</span><br><span class="line">    private Bitmap bitmap = null;</span><br><span class="line">    private Bitmap frontBitmap = null;</span><br><span class="line">    private Path path;</span><br><span class="line">    private Canvas mCanvas;</span><br><span class="line">    private Paint paint;</span><br><span class="line"></span><br><span class="line">    public EraseView(Context context) &#123;</span><br><span class="line">        this(context, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public EraseView(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        this(context, attrs, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public EraseView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">        super(context, attrs, defStyleAttr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">        super.onDraw(canvas);</span><br><span class="line">        if (mCanvas == null) &#123;</span><br><span class="line">            createEraseBitmap();</span><br><span class="line">        &#125;</span><br><span class="line">        canvas.drawBitmap(bitmap, 0, 0, null);</span><br><span class="line">        mCanvas.drawPath(path, paint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void createEraseBitmap() &#123;</span><br><span class="line">        bitmap = Bitmap.createBitmap(getWidth(), getHeight(), Config.ARGB_4444);</span><br><span class="line">        frontBitmap = createBitmap(Color.GRAY, getWidth(), getHeight());</span><br><span class="line"></span><br><span class="line">        paint = new Paint();</span><br><span class="line">        paint.setStyle(Paint.Style.STROKE);</span><br><span class="line">        paint.setXfermode(new PorterDuffXfermode(Mode.CLEAR));</span><br><span class="line">        paint.setAntiAlias(true);</span><br><span class="line">        paint.setDither(true);</span><br><span class="line">        paint.setStrokeJoin(Paint.Join.ROUND);</span><br><span class="line">        paint.setStrokeCap(Paint.Cap.ROUND);</span><br><span class="line">        paint.setStrokeWidth(60);</span><br><span class="line"></span><br><span class="line">        path = new Path();</span><br><span class="line"></span><br><span class="line">        mCanvas = new Canvas(bitmap);</span><br><span class="line">        mCanvas.drawBitmap(frontBitmap, 0, 0, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        float ax = event.getX();</span><br><span class="line">        float ay = event.getY();</span><br><span class="line"></span><br><span class="line">        if (event.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            isMove = false;</span><br><span class="line">            path.reset();</span><br><span class="line">            path.moveTo(ax, ay);</span><br><span class="line">            invalidate();</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else if (event.getAction() == MotionEvent.ACTION_MOVE) &#123;</span><br><span class="line">            isMove = true;</span><br><span class="line">            path.lineTo(ax, ay);</span><br><span class="line">            invalidate();</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return super.onTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Bitmap createBitmap(int color, int width, int height) &#123;</span><br><span class="line">        int[] rgb = new int[width * height];</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; rgb.length; i++) &#123;</span><br><span class="line">            rgb[i] = color;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return Bitmap.createBitmap(rgb, width, height, Config.ARGB_8888);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，今天的分享就到这里了。</p><p>最后，我这边有个技术交流群，平常我会分享一些学习资源到群里，还可以和大家一起交流学习，需要的朋友可以扫描下面的二维码加我微信并备注「加群」，拉你进入技术交流群！</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLngtc2lyLmNvbS9Gb2lFem5ZRjVlU1FTOFdNTjYyTnpVUTRnazQw?x-oss-process=image/format,png# =337x448" alt=""></p><p>飞哥带你去装逼，一直装逼到天黑！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;实现思路：&lt;/p&gt;
&lt;p&gt;使用相对布局，先写一个 TextView，然后自定义一个 EraseView，写一个同样大小的 EraseView 覆盖在 TextView 上面即可。&lt;/p&gt;
&lt;p&gt;先看下效果图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blo
      
    
    </summary>
    
      <category term="Android" scheme="https://www.x-sir.com/categories/Android/"/>
    
    
      <category term="自定义View" scheme="https://www.x-sir.com/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="CustomView" scheme="https://www.x-sir.com/tags/CustomView/"/>
    
      <category term="刮奖" scheme="https://www.x-sir.com/tags/%E5%88%AE%E5%A5%96/"/>
    
  </entry>
  
  <entry>
    <title>Maven 项目集成 Swagger2</title>
    <link href="https://www.x-sir.com/2019/07/13/Maven%20%E9%A1%B9%E7%9B%AE%E9%9B%86%E6%88%90%20Swagger2/"/>
    <id>https://www.x-sir.com/2019/07/13/Maven 项目集成 Swagger2/</id>
    <published>2019-07-13T08:12:00.000Z</published>
    <updated>2019-07-13T08:14:04.928Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLngtc2lyLmNvbS9GZ2Q3cXZzN3l6UjcxRTdobWdJc2xVc1lPdVQ5" alt=""><br>题图：来自飞哥的图片工厂</p><p>音乐推荐：背叛<br>文丨IT大飞说<br>预计阅读时间：3.2 分钟</p><p>哈喽，朋友们，今天我们来学习下如何使用 Swagger2。</p><h2 id="什么是-Swagger"><a href="#什么是-Swagger" class="headerlink" title="什么是 Swagger?"></a>什么是 Swagger?</h2><p>Swagger 是一款 RESTFUL 接口的、基于YAML、JSON语言的文档在线自动生成、代码自动生成的工具。</p><h2 id="如何集成？"><a href="#如何集成？" class="headerlink" title="如何集成？"></a>如何集成？</h2><p>打开 pom.xml 文件，添加如下依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>注：编写本文时使用的最新版本是 2.9.2，当你看到这篇文章的时候可能会有更新，最新的版本可到 <a href="https://mvnrepository.com" target="_blank" rel="noopener">https://mvnrepository.com</a> 查看。</p><p>新建一个 Swagger2 类，完整代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableSwagger2 // 启用 Swagger</span><br><span class="line">@EnableWebMvc</span><br><span class="line">public class Swagger2 &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Docket createRestApi() &#123;</span><br><span class="line">        return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                // 为当前包路径</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(&quot;com.xpf.imoney&quot;))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 构建 api 文档的详细信息函数，注意这里的注解引用的是哪个</span><br><span class="line">     */</span><br><span class="line">    private ApiInfo apiInfo() &#123;</span><br><span class="line">        return new ApiInfoBuilder()</span><br><span class="line">                // 页面标题</span><br><span class="line">                .title(&quot;SSM Application [iMoney] Swagger2 RESTFul API&quot;)</span><br><span class="line">                // 创建人</span><br><span class="line">                .contact(new Contact(&quot;x-sir&quot;, &quot;http://www.x-sir.com&quot;, &quot;542270559@qq.com&quot;))</span><br><span class="line">                // 版本号</span><br><span class="line">                .version(&quot;1.0&quot;)</span><br><span class="line">                // 描述</span><br><span class="line">                .description(&quot;This is [iMoney] API doc&quot;)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后编译并启动你本地的服务，打开浏览器，输入下面的访问地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/JavaWeb/swagger-ui.html</span><br></pre></td></tr></table></figure><p>注：上面链接中的 JavaWeb 为你的项目名称，替换为你自己的！</p><p>正常情况下你就会看到下面的页面了：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLngtc2lyLmNvbS9GbDQ2b2p3cHY4d1hETXV1a3gyRjdDY0xmNjAt" alt=""></p><h2 id="Swagger-的几个常用注解"><a href="#Swagger-的几个常用注解" class="headerlink" title="Swagger 的几个常用注解"></a>Swagger 的几个常用注解</h2><ul><li>@Api：表示这个类是 Swagger 的资源；</li><li>@ApiOperation：用在方法上，说明方法的作用；</li><li>@ApiParam：用来修饰参数，表示对参数添加元数据；</li><li>@ApiModel：用于类，对类进行说明；</li><li>@ApiIgnore：用于类，方法，表示这个类或方法被忽略；</li><li>@ApiImplicitParam：用于方法，表示单独的请求参数；</li></ul><p>举个例子，我们的 UserController 中的简单使用，完整代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Api(value = &quot;/user&quot;, description = &quot;关于用户的一些操做。&quot;)</span><br><span class="line">@Controller</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private UserService userService;</span><br><span class="line"></span><br><span class="line">    @ResponseBody</span><br><span class="line">    @RequestMapping(value = &quot;/index&quot;)</span><br><span class="line">    @ApiOperation(value = &quot;通过 ID 查询 USER 信息&quot;, httpMethod = &quot;GET&quot;, notes = &quot;暂无&quot;)</span><br><span class="line">    public User index(@RequestParam(&quot;id&quot;) int id) &#123;</span><br><span class="line">        return userService.getUserById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本的用法就这些，好了，今天的分享就到这里了。</p><p>最后，我这边有个技术交流群，平常我会分享一些学习资源到群里，还可以和大家一起交流学习，需要的朋友可以扫描下面的二维码加我微信并备注「加群」，拉你进入技术交流群！</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLngtc2lyLmNvbS9Gb2lFem5ZRjVlU1FTOFdNTjYyTnpVUTRnazQw# =337x448" alt=""></p><p>飞哥带你去装逼，一直装逼到天黑！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cDovL2ltYWdlLngtc2lyLmNvbS9GZ2Q3cXZzN3l6UjcxRTdobWdJc2xVc1lPdVQ5&quot; alt=&quot;&quot;&gt;&lt;br&gt;题图：来自飞哥的图片工厂&lt;/p&gt;
      
    
    </summary>
    
      <category term="JavaEE" scheme="https://www.x-sir.com/categories/JavaEE/"/>
    
    
      <category term="Maven" scheme="https://www.x-sir.com/tags/Maven/"/>
    
      <category term="Swagger" scheme="https://www.x-sir.com/tags/Swagger/"/>
    
      <category term="Swagger2" scheme="https://www.x-sir.com/tags/Swagger2/"/>
    
      <category term="Spring" scheme="https://www.x-sir.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>RxJava2.x 操作符之 compose</title>
    <link href="https://www.x-sir.com/2019/06/20/RxJava2.x%20%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B9%8B%20compose/"/>
    <id>https://www.x-sir.com/2019/06/20/RxJava2.x 操作符之 compose/</id>
    <published>2019-06-20T12:03:01.000Z</published>
    <updated>2019-06-20T12:04:19.622Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.x-sir.com/Fgd7qvs7yzR71E7hmgIslUsYOuT9" alt=""><br>题图：来自飞哥的图片工厂</p><p>音乐推荐：后来<br>文丨IT大飞说<br>预计阅读时间：2.3 分钟</p><p>哈喽，朋友们，之前我们学习了一些 RxJava2.x 的常用操作符，今天我们来继续学习一下 RxJava 的 compose 操作符。</p><p>compose 操作符能够从数据流中得到原始的被观察者，当创建被观察者时，compose 操作符会立即执行，而不像其他的操作符需要在 onNext() 调用后才能执行。</p><h2 id="使用场景一"><a href="#使用场景一" class="headerlink" title="使用场景一"></a>使用场景一</h2><p>我们可以用 compose 操作符来进行线程的切换，一般用在网络请求的地方。</p><p>原始的写法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.subscribeOn(Schedulers.io())</span><br><span class="line">.observeOn(AndroidSchedulers.mainThread())</span><br></pre></td></tr></table></figure><p>我们可以将上面的操作封装成一个简单的工具类来使用，我这里提供了 Java 版和 Kotlin 版本：</p><p>Java 版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import io.reactivex.FlowableTransformer;</span><br><span class="line">import io.reactivex.MaybeTransformer;</span><br><span class="line">import io.reactivex.ObservableTransformer;</span><br><span class="line">import io.reactivex.android.schedulers.AndroidSchedulers;</span><br><span class="line">import io.reactivex.schedulers.Schedulers;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by x-sir on 2019/4/19 :)</span><br><span class="line"> * Function:线程调度</span><br><span class="line"> */</span><br><span class="line">public class RxThreadUtils &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Flowable 切换到主线程</span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; FlowableTransformer&lt;T, T&gt; flowableToMain() &#123;</span><br><span class="line">        return upstream -&gt; upstream.subscribeOn(Schedulers.io())</span><br><span class="line">                .observeOn(AndroidSchedulers.mainThread());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Observable 切换到主线程</span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; ObservableTransformer&lt;T, T&gt; observableToMain() &#123;</span><br><span class="line">        return upstream -&gt; upstream.subscribeOn(Schedulers.io())</span><br><span class="line">                .observeOn(AndroidSchedulers.mainThread());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Maybe 切换到主线程</span><br><span class="line">     */</span><br><span class="line">    public static &lt;T&gt; MaybeTransformer&lt;T, T&gt; maybeToMain() &#123;</span><br><span class="line">        return upstream -&gt; upstream.subscribeOn(Schedulers.io())</span><br><span class="line">                .observeOn(AndroidSchedulers.mainThread());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Kotlin 版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">import io.reactivex.FlowableTransformer</span><br><span class="line">import io.reactivex.MaybeTransformer</span><br><span class="line">import io.reactivex.ObservableTransformer</span><br><span class="line">import io.reactivex.android.schedulers.AndroidSchedulers</span><br><span class="line">import io.reactivex.schedulers.Schedulers</span><br><span class="line">import java.util.concurrent.TimeUnit</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by x-sir on 2019-06-02 :)</span><br><span class="line"> * Function:RxJava2.x 线程切换工具类</span><br><span class="line"> */</span><br><span class="line">object RxThreadUtils &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Observable 切换到主线程</span><br><span class="line">     */</span><br><span class="line">    fun &lt;T&gt; observableToMain(): ObservableTransformer&lt;T, T&gt; &#123;</span><br><span class="line">        return ObservableTransformer &#123; upstream -&gt;</span><br><span class="line">            upstream.subscribeOn(Schedulers.io())</span><br><span class="line">                    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Flowable 切换到主线程</span><br><span class="line">     */</span><br><span class="line">    fun &lt;T&gt; flowableToMain(): FlowableTransformer&lt;T, T&gt; &#123;</span><br><span class="line">        return FlowableTransformer &#123; upstream -&gt;</span><br><span class="line">            upstream.subscribeOn(Schedulers.io())</span><br><span class="line">                    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Maybe 切换到主线程</span><br><span class="line">     */</span><br><span class="line">    fun &lt;T&gt; maybeToMain(): MaybeTransformer&lt;T, T&gt; &#123;</span><br><span class="line">        return MaybeTransformer &#123; upstream -&gt;</span><br><span class="line">            upstream.subscribeOn(Schedulers.io())</span><br><span class="line">                    .observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用起来也比较简单，我们在网络请求的时候就可以这样调用（假设网络请求返回的是Flowable 对象）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.compose(RxThreadUtils.flowableToMain())</span><br></pre></td></tr></table></figure><h2 id="使用场景二"><a href="#使用场景二" class="headerlink" title="使用场景二"></a>使用场景二</h2><p>compose 操作符可以和 Transformer 结合使用，一方面可以让代码看起来更加简洁，另一方面能够提高代码的复用性，因为 RxJava 提倡链式调用，我们可以合理的使用 compose 操作符来防止链式调用被打破。</p><p>RxLifecycle 是 trello 开源的一个配置 RxJava 使用的开源库，我们知道 RxJava 有个缺点就是会导致内存泄露，此时，RxLifecycle 横空出世了，它可以配合 RxJava 一起使用，可以有效防止内存泄漏发生，使用起来也是非常方便，举个简单的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myObservable</span><br><span class="line">    .compose(RxLifecycle.bind(lifecycle))</span><br><span class="line">    .subscribe();</span><br></pre></td></tr></table></figure><p>RxLifecycle 不在文本的讲解范围内，更多详细使用可看 GitHub 介绍：</p><p><a href="https://github.com/trello/RxLifecycle" target="_blank" rel="noopener">https://github.com/trello/RxLifecycle</a></p><p>另外，知乎也开源了一个 RxLifecycle 库，使用起来也是比较方便的，感兴趣的可以看看：</p><p><a href="https://github.com/zhihu/RxLifecycle" target="_blank" rel="noopener">https://github.com/zhihu/RxLifecycle</a></p><p>好了，今天的分享就到这里了。</p><p>最后，我这边有个技术交流群，平常我会分享一些学习资源到群里，还可以和大家一起交流学习，需要的朋友可以扫描下面的二维码加我微信并备注「加群」，拉你进入技术交流群！</p><p><img src="http://image.x-sir.com/FoiEznYF5eSQS8WMN62NzUQ4gk40 =337x448" alt=""></p><p>飞哥带你去装逼，一直装逼到天黑！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://image.x-sir.com/Fgd7qvs7yzR71E7hmgIslUsYOuT9&quot; alt=&quot;&quot;&gt;&lt;br&gt;题图：来自飞哥的图片工厂&lt;/p&gt;
&lt;p&gt;音乐推荐：后来&lt;br&gt;文丨IT大飞说&lt;br&gt;预计阅读时间：2.3 分钟&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="Android" scheme="https://www.x-sir.com/categories/Android/"/>
    
    
      <category term="RxJava" scheme="https://www.x-sir.com/tags/RxJava/"/>
    
      <category term="RxJava2.x" scheme="https://www.x-sir.com/tags/RxJava2-x/"/>
    
      <category term="操作符" scheme="https://www.x-sir.com/tags/%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    
      <category term="compose" scheme="https://www.x-sir.com/tags/compose/"/>
    
  </entry>
  
  <entry>
    <title>RxJava2.x 常用操作符列表</title>
    <link href="https://www.x-sir.com/2019/06/10/RxJava2.x%20%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%88%97%E8%A1%A8/"/>
    <id>https://www.x-sir.com/2019/06/10/RxJava2.x 常用操作符列表/</id>
    <published>2019-06-10T13:48:00.000Z</published>
    <updated>2019-06-10T13:48:39.072Z</updated>
    
    <content type="html"><![CDATA[<ul><li>All：判断 Observable 发射的所有的数据项是否都满足某个条件；</li><li>Amb：给定多个 Observable，只让第一个发射数据的 Observable 发射全部数据；</li><li>And/Then/When：通过模式（And条件）和计划（Then次序）组合两个或多个 Observable 发射的数据集；</li><li>Average：计算 Observable发射的数据序列的平均值，然后发射这个结果；</li><li>Buffer：缓存，可以简单理解为缓存，它定期从 Observable 收集数据到一个集合，然后把这些数据集合打包发射，而不是一次发射一个；</li><li>Catch：捕获，继续序列操作，将错误替换为正常的数据，从 onError 通知中恢复；</li><li>CombineLatest：当两个 Observables 中的任何一个发射了一个数据时，通过一个指定的函数组合每个 Observable 发射的最新数据（一共两个数据），然后发射这个函数的结果；</li><li>Concat：不交错地连接多个 Observable 的数据；</li><li>Connect：指示一个可连接的 Observable 开始发射数据给订阅者；</li><li>Contains：判断 Observable 是否会发射一个指定的数据项；</li><li>Count：计算 Observable 发射的数据个数，然后发射这个结果；</li><li>Create：通过调用观察者的方法从头创建一个 Observable；</li><li>Debounce：只有在空闲了一段时间后才发射数据，简单来说，就是如果一段时间没有操作，就执行一次操作；</li><li>DefaultIfEmpty：发射来自原始 Observable 的数据，如果原始 Observable 没有发射数据，就发射一个默认数据；</li><li>Defer：在观察者订阅之前不创建这个 Observable，为每一个观察者创建一个新的 Observable；</li><li>Delay：延迟一段时间发射结果数据；</li><li>Distinct：去重，过滤掉重复数据项；</li><li>Do：注册一个动作占用一些 Observable 的生命周期事件，相当于 Mock 某个操作；</li><li>Materialize/Dematerialize：将发射的数据和通知都当作数据发射，或者反过来；</li><li>ElementAt：取值，取特定位置的数据项；</li><li>Empty/Never/Throw：创建行为受限的特殊 Observable；</li><li>Filter：过滤，过滤掉没有通过谓词测试的数据项，只发射通过测试的</li><li>First：首项，只发射满足条件的第一条数据；</li><li>flatMap：扁平映射，将 Observable 发射的数据转换为 Observables 集合，然后将这些 Observable 发射的数据平坦化地放进一个单独的 Observable，可以认为是一个将嵌套的数据结构展开的过程；</li><li>From：将其他对象或数据结构转换为 Observable；</li><li>GroupBy：分组，将原来的 Observable 拆分为 Observable 集合，将原始 Observable 发射的数据按 Key 分组，每一个 Observable 发射一组不同的数据；</li><li>IgnoreElements：忽略所有的数据，只保留终止通知(onError 或 onCompleted)；</li><li>Interval：创建一个定时发射整数序列的 Observable；</li><li>Join：无论何时，如果一个 Observable 发射了一个数据项，只要在另一个 Observable 发射的数据项定义的时间窗口内，就将两个 Observable 发射的数据合并发射；</li><li>Just：将对象或者对象集合转换为一个会发射这些对象的 Observable；</li><li>Last：末项，只发射最后一条数据；</li><li>Map：映射，对序列的每一项都应用一个函数变换 Observable 发射的数据，实质是对序列中的每一项执行一个函数，函数的参数就是这个数据项；</li><li>Max：计算并发射数据序列的最大值；</li><li>Merge：将两个 Observable 发射的数据组合并成一个；</li><li>Min：计算并发射数据序列的最小值；</li><li>ObserveOn：指定观察者观察 Observable 的调度程序（工作线程）；</li><li>Publish：将一个普通的 Observable 转换为可连接的；</li><li>Range：创建发射指定范围的整数序列的 Observable；</li><li>Reduce：按顺序对数据序列的每一项数据应用某个函数，然后返回这个值；</li><li>RefCount：使一个可连接的 Observable 表现得像一个普通的 Observable；</li><li>Repeat：创建重复发射特定的数据或数据序列的 Observable；</li><li>Replay：确保所有的观察者收到同样的数据序列，即使他们在 Observable 开始发射数据之后才订阅；</li><li>Retry：重试，如果 Observable 发射了一个错误通知，重新订阅它，期待它正常终止辅助操作；</li><li>Sample：取样，定期发射最新的数据，等同于数据抽样，有的实现中叫作 ThrottleFirst；</li><li>Scan：扫描，对 Observable 发射的每一项数据应用一个函数，然后按顺序依次发射这些值；</li><li>SequenceEqual：判断两个 Observable 是否按相同的数据序列；</li><li>Serialize：强制 Observable 按次序发射数据并且功能是有效的；</li><li>Skip：跳过前面的若干项数据；</li><li>SkipLast：跳过后面的若干项数据；</li><li>SkipUntil：丢弃原始 Observable 发射的数据，直到第二个 Observable 发射了一个数据，然后发射原始 Observable 的剩余数据；</li><li>SkipWhile：丢弃原始Observable发射的数据，直到一个特定的条件为假，然后发射原始 Observable 剩余的数据；</li><li>Start：创建发射一个函数返回值的 Observable；</li><li>StartWith：在发射原来的 Observable 的数据序列之前，先发射一个指定的数据序列或数据项；</li><li>Subscribe：收到 Observable 发射的数据和通知后执行的操作；</li><li>SubscribeOn：指定 Observable 应该在哪个调度程序上执行；</li><li>Sum：计算并发射数据序列的和；</li><li>Switch：将一个发射 Observable 序列的 Observable 转换为这样一个 Observable，即它逐个发射那些 Observable 最近发射的数据；</li><li>Take：只保留前面的若干项数据；</li><li>TakeLast：只保留后面的若干项数据；</li><li>TakeUntil：发射来自原始 Observable 的数据，直到第二个 Observable 发射了一个数据或一个通知；</li><li>TakeWhile：发射原始 Observable 的数据，直到一个特定的条件为真，然后跳过剩余的数据；</li><li>TimeInterval：将一个 Observable 转换为发射两个数据之间所耗费时间的 Observable；</li><li>Timeout：添加超时机制，如果过了指定的一段时间没有发射数据，就发射一个错误通知；</li><li>Timer：创建在一个指定的延迟之后发射单个数据的 Observable；</li><li>Timestamp：给 Observable 发射的每个数据项添加一个时间戳；</li><li>To：将 Observable 转换为其他对象或数据结构；</li><li>Using：创建一个只在 Observable 生命周期内存在的一次性资源；</li><li>Window：窗口，定期将来自 Observable 的数据拆分成一些 Observable 窗口，然后发射这些窗口，而不是每次发射一项；类似于 Buffer，但 Buffer 发射的是数据，Window 发射的是 Observable，每一个 Observable 发射原始 Observable 数据的一个子集；</li><li>Zip：打包，使用一个指定的函数将多个 Observable 发射的数据组合在一起，然后将这个函数的结果作为单项数据发射；</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;All：判断 Observable 发射的所有的数据项是否都满足某个条件；&lt;/li&gt;
&lt;li&gt;Amb：给定多个 Observable，只让第一个发射数据的 Observable 发射全部数据；&lt;/li&gt;
&lt;li&gt;And/Then/When：通过模式（And条件）
      
    
    </summary>
    
      <category term="Android" scheme="https://www.x-sir.com/categories/Android/"/>
    
    
      <category term="RxJava" scheme="https://www.x-sir.com/tags/RxJava/"/>
    
      <category term="RxJava2.x" scheme="https://www.x-sir.com/tags/RxJava2-x/"/>
    
      <category term="操作符" scheme="https://www.x-sir.com/tags/%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>RxJava2.x 并行编程</title>
    <link href="https://www.x-sir.com/2019/06/04/RxJava2.x%20%E7%9A%84%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/"/>
    <id>https://www.x-sir.com/2019/06/04/RxJava2.x 的并行编程/</id>
    <published>2019-06-04T15:33:00.000Z</published>
    <updated>2019-06-04T15:34:46.976Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.x-sir.com/FvMS1D4sOwIivgw3ayDP1bqfX4rI" alt=""><br>题图：来自飞哥的图片工厂</p><p>音乐推荐：你的姑娘<br>文丨IT大飞说<br>预计阅读时间：1.2 分钟</p><p>哈喽，朋友们，之前我们学习了一些 RxJava2.x 的常用操作符，今天我们来继续学习一下RxJava 的并行编程。</p><p>随着手机 CPU 的高速发展，性能越来越强劲，核心数越来越多，我们要充分、高效地利用这些 CPU 资源，来提高程序运行的效率，解决复杂的业务问题，这将变得越来越重要。</p><h2 id="1-什么是并行编程？"><a href="#1-什么是并行编程？" class="headerlink" title="1.什么是并行编程？"></a>1.什么是并行编程？</h2><p>对于并发我们可能比较清楚，那么并行是什么呢？它们的区别是什么？并发（concurrency）是指一个处理器同时处理多个任务，并行（parallelism）是多个处理器或者是多核处理器同时处理多个不同的任务，并行是同时发生的多个并发事件，具有并发的含义，而并发不一定是并行。</p><p>在 Java 8 中有个并行流（parallelStream），有的同学可能用过，我们想使用并行流的方式打印出 1-100 之间的整数，来看下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private void parallelismWithJava8() &#123;</span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt;= 100; i++) &#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        list.parallelStream()</span><br><span class="line">                .map(Object::toString)</span><br><span class="line">                .forEach(s -&gt; LogUtil.i(TAG, &quot;s=&quot; + s + &quot;,Current Thread Name=&quot; + Thread.currentThread().getName()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面的结果会交错输出 1-100 之间的整数，因为并行的缘故所以每个输出执行的时间可能不一样，所以会交错输出，其实上面的代码是 Java 8 借助了 JDK 的 fork/join 框架来实现并行编程的。</p><h2 id="2-使用-RxJava-的-flatMap-实现并行编程"><a href="#2-使用-RxJava-的-flatMap-实现并行编程" class="headerlink" title="2.使用 RxJava 的 flatMap 实现并行编程"></a>2.使用 RxJava 的 flatMap 实现并行编程</h2><p>我们前面学习过 flatMap 操作符，我们知道 flatMap 可以将一些数据转换成一些 Observables，然后我们可以指定它的调度器来实现并行编程的目的，还是打印 1-100 的数字，直接看代码吧：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private void parallelismWithRxJavaFlatMap() &#123;</span><br><span class="line">    Observable.range(1, 100)</span><br><span class="line">            .flatMap((Function&lt;Integer, ObservableSource&lt;String&gt;&gt;) integer -&gt;</span><br><span class="line">                    Observable.just(integer)</span><br><span class="line">                            .subscribeOn(Schedulers.computation())</span><br><span class="line">                            .map(integer1 -&gt; integer1.toString()))</span><br><span class="line">            .subscribe(s -&gt; LogUtil.i(TAG, &quot;s===&quot; + s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式使用的是默认的调度器，当然我们也可以创建一个线程池，来自定义调度器，修改后的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private void parallelismWithRxJavaFlatMap() &#123;</span><br><span class="line">    int threadNum = Runtime.getRuntime().availableProcessors() + 1;</span><br><span class="line">    ExecutorService executorService = Executors.newFixedThreadPool(threadNum);</span><br><span class="line">    final Scheduler scheduler = Schedulers.from(executorService);</span><br><span class="line"></span><br><span class="line">    Observable.range(1, 100)</span><br><span class="line">            .flatMap((Function&lt;Integer, ObservableSource&lt;String&gt;&gt;) integer -&gt;</span><br><span class="line">                    Observable.just(integer)</span><br><span class="line">                            .subscribeOn(scheduler)</span><br><span class="line">                            .map(integer1 -&gt; integer1.toString()))</span><br><span class="line">            .doFinally(() -&gt; executorService.shutdown())</span><br><span class="line">            .subscribe(s -&gt; LogUtil.i(TAG, &quot;s===&quot; + s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这 2 种实现方式都差不多，性能方面也差别不大，根据喜好请自行选择，注意一点，如果使用自己创建的线程池，那么记得使用 doFinally 操作符将线程池关闭，或者由下游的消费者进行处理！</p><h2 id="3-使用-ParallelFlowable-实现并行编程"><a href="#3-使用-ParallelFlowable-实现并行编程" class="headerlink" title="3.使用 ParallelFlowable 实现并行编程"></a>3.使用 ParallelFlowable 实现并行编程</h2><p>Flowable 是 RxJava2.x 新增的被观察者，支持背压，因此它对应的并行被观察者为 ParallelFlowable，因为并行编程肯定涉及到异步，而异步又涉及到背压，所以是没有 ParallelObservable 的。</p><p>我们还是用 ParallelFlowable 来实现打印 1-100 这个需求吧，请看代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void parallelFlowable() &#123;</span><br><span class="line">    ParallelFlowable&lt;Integer&gt; parallelFlowable = Flowable.range(1, 100).parallel();</span><br><span class="line"></span><br><span class="line">    parallelFlowable</span><br><span class="line">            .runOn(Schedulers.io())</span><br><span class="line">            .map(integer -&gt; integer.toString())</span><br><span class="line">            .sequential()</span><br><span class="line">            .subscribe(s -&gt; LogUtil.i(TAG, &quot;s===&quot; + s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实代码是比较简单的，我们发现 runOn 和 sequential 操作符我们之前没见过，这里解释下，runOn 其实就是相当于我们上面使用 flatMap 实现中的 subscribeOn，我们可以用它来定义异步，它还有一个重载的方法，我们可以指定 prefetch 的数量。</p><p>sequential 操作符是将并行的操作结果返回到并行流中，这样，才能打印出所有的输出结果。</p><p>我们上面学会了好几种并行编程的方式，那么我们在实际的开发中应该选择哪种呢？</p><p>并非所有的顺序操作在并行中都是有意义的，目前 ParallelFlowable 只支持如下操作：<br>map、filter、flatMap、concatMap、reduce、collect、sorted、toSortedList、compose、fromArray、doOnCancel、doOnError、doOnComplete、doOnNext、doAfterNext、doOnSubscribe、doAfterTerminated、doOnRequest，优先推荐使用 ParallelFlowable 实现并行编程，对于无法使用 ParallelFlowable 的操作符，则使用 flatMap 来实现。</p><p>好了，今天的学习内容就算完成了，感觉是不是很简单？实践证明，学完后动手敲一遍的效果是最好的，赶紧去动手敲一遍吧！</p><p>最后，我这边有个技术交流群，平常我会分享一些学习资源到群里，还可以和大家一起交流学习，需要的朋友可以扫描下面的二维码加我微信并备注「加群」，拉你进入技术交流群！</p><p><img src="http://image.x-sir.com/FoiEznYF5eSQS8WMN62NzUQ4gk40 =337x448" alt=""></p><p>飞哥带你去装逼，一直装逼到天黑！</p><p>另外，我还建了一个免费的知识星球用于学习交流，感兴趣的可以使用微信扫码加入哦！</p><p><img src="https://img-blog.csdnimg.cn/2019052722451347.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbnBlbmdmZWk1MjE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://image.x-sir.com/FvMS1D4sOwIivgw3ayDP1bqfX4rI&quot; alt=&quot;&quot;&gt;&lt;br&gt;题图：来自飞哥的图片工厂&lt;/p&gt;
&lt;p&gt;音乐推荐：你的姑娘&lt;br&gt;文丨IT大飞说&lt;br&gt;预计阅读时间：1.2 分钟&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="Android" scheme="https://www.x-sir.com/categories/Android/"/>
    
    
      <category term="RxJava" scheme="https://www.x-sir.com/tags/RxJava/"/>
    
      <category term="RxJava2.x" scheme="https://www.x-sir.com/tags/RxJava2-x/"/>
    
      <category term="操作符" scheme="https://www.x-sir.com/tags/%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    
      <category term="并行编程" scheme="https://www.x-sir.com/tags/%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/"/>
    
      <category term="parallelism" scheme="https://www.x-sir.com/tags/parallelism/"/>
    
  </entry>
  
  <entry>
    <title>Android library 依赖 aar 包的两种方式</title>
    <link href="https://www.x-sir.com/2019/05/30/Android%20library%20%E4%BE%9D%E8%B5%96%20aar%20%E5%8C%85%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>https://www.x-sir.com/2019/05/30/Android library 依赖 aar 包的两种方式/</id>
    <published>2019-05-30T09:12:05.000Z</published>
    <updated>2019-05-30T09:13:36.454Z</updated>
    
    <content type="html"><![CDATA[<h2 id="方式1"><a href="#方式1" class="headerlink" title="方式1"></a>方式1</h2><p>将 aar 包放入 library module 的 libs 目录下，然后在工程的 build.gradle 文件中加入如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flatDir &#123; dirs &apos;libs&apos;, &apos;../moduleName/libs&apos; &#125;</span><br></pre></td></tr></table></figure><p>注：将 moduleName 替换为你自己的 library module 的 name.</p><p>然后在 module 的 build.gradle 文件中添加依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation(name: &apos;aar包名&apos;, ext: &apos;aar&apos;)</span><br></pre></td></tr></table></figure><h2 id="方式2"><a href="#方式2" class="headerlink" title="方式2"></a>方式2</h2><p>这种方式的思路是，先把 aar 包放入一个单独的文件夹中，然后我们再依赖这个文件夹就可以了，这个文件夹你也可以理解成一个特殊的 module。</p><p>先在工程目录下新建一个文件夹（和app同级），然后将你的 aar 包放入 这个文件夹，然后再新建一个 build.gradle 文件，在这个文件中添加下面两句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">configurations.maybeCreate(&quot;default&quot;)</span><br><span class="line">artifacts.add(&quot;default&quot;, file(&apos;aar包名.aar&apos;))</span><br></pre></td></tr></table></figure><p>然后在你需要依赖的 library module 的 build.gradle 文件中添加依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation project(&apos;:存放aar包的文件夹&apos;)</span><br></pre></td></tr></table></figure><p>最后，同步下工程就 OK 了~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;方式1&quot;&gt;&lt;a href=&quot;#方式1&quot; class=&quot;headerlink&quot; title=&quot;方式1&quot;&gt;&lt;/a&gt;方式1&lt;/h2&gt;&lt;p&gt;将 aar 包放入 library module 的 libs 目录下，然后在工程的 build.gradle 文件中加入如下代码：
      
    
    </summary>
    
      <category term="Android" scheme="https://www.x-sir.com/categories/Android/"/>
    
    
      <category term="aar" scheme="https://www.x-sir.com/tags/aar/"/>
    
      <category term="module" scheme="https://www.x-sir.com/tags/module/"/>
    
      <category term="依赖" scheme="https://www.x-sir.com/tags/%E4%BE%9D%E8%B5%96/"/>
    
      <category term="library" scheme="https://www.x-sir.com/tags/library/"/>
    
  </entry>
  
  <entry>
    <title>RxJava2.x 变换操作符之 flatMap 和 concatMap</title>
    <link href="https://www.x-sir.com/2019/05/27/RxJava2.x%20%E5%8F%98%E6%8D%A2%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B9%8B%20flatMap%E5%92%8CconcatMap/"/>
    <id>https://www.x-sir.com/2019/05/27/RxJava2.x 变换操作符之 flatMap和concatMap/</id>
    <published>2019-05-27T15:17:00.000Z</published>
    <updated>2019-05-27T15:17:26.506Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.x-sir.com/Fu8NaLmujOyoQjtSrpLnPsxWWp3a" alt=""><br>题图：Pixabay License</p><p>哈喽，朋友们，<a href="https://mp.weixin.qq.com/s?__biz=MzU4MTIzNjg0Ng==&amp;mid=2247484144&amp;idx=1&amp;sn=28e8940cc3a692057a7a3634f04d52f7&amp;chksm=fd4be3f1ca3c6ae765a83e4d6b7d9668f2c212ea3258e7e3cf6cb5ab22c3973720ef5cc7d0a8&amp;token=759890379&amp;lang=zh_CN#rd" target="_blank" rel="noopener">上一篇文章</a>我们学习了 filter 操作符，今天我们来学习 RxJava 中比较重要的两个操作符 flatMap 和 concatMap。</p><h2 id="1-flatMap"><a href="#1-flatMap" class="headerlink" title="1.flatMap"></a>1.flatMap</h2><p>我们知道 flat 是平的意思，这个翻译还是有点生硬和抽象，我们还是不太理解，你就可以先理解成平铺的意思吧。</p><p>flatMap 是变换操作符的一种，它将一个发射数据的 Observable 变换为多个 Observable，然后将他们发射的数据合并后放入一个单独的 Observable。</p><p>举个简单的例子吧，假设上游有个数据源，数据源是学生对象的集合，学生有姓名和课程的属性，每个学生的课程可以有多个，需求是打印出所有学生的课程名称。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Student student1 = new Student();</span><br><span class="line"></span><br><span class="line">List&lt;Student.Course&gt; list1 = new ArrayList&lt;&gt;();</span><br><span class="line">list1.add(new Student.Course(&quot;语文1&quot;));</span><br><span class="line">list1.add(new Student.Course(&quot;数学1&quot;));</span><br><span class="line">list1.add(new Student.Course(&quot;英语1&quot;));</span><br><span class="line">list1.add(new Student.Course(&quot;物理1&quot;));</span><br><span class="line">list1.add(new Student.Course(&quot;化学1&quot;));</span><br><span class="line"></span><br><span class="line">student1.setName(&quot;张三&quot;);</span><br><span class="line">student1.setCourses(list1);</span><br><span class="line"></span><br><span class="line">Student student2 = new Student();</span><br><span class="line"></span><br><span class="line">List&lt;Student.Course&gt; list2 = new ArrayList&lt;&gt;();</span><br><span class="line">list2.add(new Student.Course(&quot;语文2&quot;));</span><br><span class="line">list2.add(new Student.Course(&quot;数学2&quot;));</span><br><span class="line">list2.add(new Student.Course(&quot;英语2&quot;));</span><br><span class="line"></span><br><span class="line">student2.setName(&quot;李四&quot;);</span><br><span class="line">student2.setCourses(list2);</span><br><span class="line"></span><br><span class="line">List&lt;Student&gt; studentList = new ArrayList&lt;&gt;();</span><br><span class="line">studentList.add(student1);</span><br><span class="line">studentList.add(student2);</span><br><span class="line"></span><br><span class="line">Observable.just(studentList)</span><br><span class="line">        .flatMap((Function&lt;List&lt;Student&gt;, ObservableSource&lt;Student&gt;&gt;) students -&gt; Observable.fromIterable(students))</span><br><span class="line">        .flatMap((Function&lt;Student, ObservableSource&lt;Student.Course&gt;&gt;) student -&gt; &#123;</span><br><span class="line">            LogUtil.i(TAG, &quot;student name===&quot; + student.getName());</span><br><span class="line">            return Observable.fromIterable(student.getCourses());</span><br><span class="line">        &#125;)</span><br><span class="line">        .subscribe(course -&gt; LogUtil.i(TAG, &quot;course===&quot; + course.getCourseName()));</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">I/RxJavaOperatorActivity: student name===张三</span><br><span class="line">I/RxJavaOperatorActivity: course===语文1</span><br><span class="line">I/RxJavaOperatorActivity: course===数学1</span><br><span class="line">I/RxJavaOperatorActivity: course===英语1</span><br><span class="line">I/RxJavaOperatorActivity: course===物理1</span><br><span class="line">I/RxJavaOperatorActivity: course===化学1</span><br><span class="line">I/RxJavaOperatorActivity: student name===李四</span><br><span class="line">I/RxJavaOperatorActivity: course===语文2</span><br><span class="line">I/RxJavaOperatorActivity: course===数学2</span><br><span class="line">I/RxJavaOperatorActivity: course===英语2</span><br></pre></td></tr></table></figure><p>我们看到上面的代码没有 for 循环，却遍历打印了集合中的数据，RxJava 就是为了简化或者是取消 for 循环种方式，使用操作符来解决遍历循环的问题，从而是代码更加扁平化，使代码更加清晰和便于理解。</p><p>注意：flatMap 对这些 Observables 发射的数据做的是合并(merge)操作，因此它们可能是交错的，即不能保证数据的发射顺序。</p><h2 id="2-concatMap"><a href="#2-concatMap" class="headerlink" title="2.concatMap"></a>2.concatMap</h2><p>我们将上面的 flatMap 操作符换成 concatMap 操作符再看看打印的结果，修改代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(studentList)</span><br><span class="line">            .concatMap((Function&lt;List&lt;Student&gt;, ObservableSource&lt;Student&gt;&gt;) students -&gt; Observable.fromIterable(students))</span><br><span class="line">            .concatMap((Function&lt;Student, ObservableSource&lt;Student.Course&gt;&gt;) student -&gt; &#123;</span><br><span class="line">                LogUtil.i(TAG, &quot;student name===&quot; + student.getName());</span><br><span class="line">                return Observable.fromIterable(student.getCourses());</span><br><span class="line">            &#125;)</span><br><span class="line">            .subscribe(course -&gt; LogUtil.i(TAG, &quot;course===&quot; + course.getCourseName()));</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">I/RxJavaOperatorActivity: student name===张三</span><br><span class="line">I/RxJavaOperatorActivity: course===语文1</span><br><span class="line">I/RxJavaOperatorActivity: course===数学1</span><br><span class="line">I/RxJavaOperatorActivity: course===英语1</span><br><span class="line">I/RxJavaOperatorActivity: course===物理1</span><br><span class="line">I/RxJavaOperatorActivity: course===化学1</span><br><span class="line">I/RxJavaOperatorActivity: student name===李四</span><br><span class="line">I/RxJavaOperatorActivity: course===语文2</span><br><span class="line">I/RxJavaOperatorActivity: course===数学2</span><br><span class="line">I/RxJavaOperatorActivity: course===英语2</span><br></pre></td></tr></table></figure><p>我们看到和 flatMap 的执行结果是一样的，我们发现打印的结果也是按照添加数据的顺序打印出来了，理论上 flatMap 执行的结果可能会有交错，原因是我们添加的数据过少，因此它们执行的时间也是差不多的，所以提现不出交错的情况。</p><p>好了，今天的学习内容就算完成了，感觉是不是非常简单？其实有时候你光看，理解起来是很慢的，但是你动手敲一遍立马就明白了，所以代码这个东西还是得多敲！</p><p>最后，我这边建了一个技术交流群，需要的朋友可以扫描下面的二维码加我微信并备注「加群」，拉你进入技术交流群！</p><p><img src="http://image.x-sir.com/FoiEznYF5eSQS8WMN62NzUQ4gk40 =337x448" alt=""></p><p>飞哥带你去装逼，一直装逼到天黑！</p><p>另外，我还建了一个免费的知识星球用于学习交流，感兴趣的可以使用微信扫码加入哦！</p><p><img src="https://img-blog.csdnimg.cn/2019052722451347.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbnBlbmdmZWk1MjE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://image.x-sir.com/Fu8NaLmujOyoQjtSrpLnPsxWWp3a&quot; alt=&quot;&quot;&gt;&lt;br&gt;题图：Pixabay License&lt;/p&gt;
&lt;p&gt;哈喽，朋友们，&lt;a href=&quot;https://mp.weixin.qq.
      
    
    </summary>
    
      <category term="Android" scheme="https://www.x-sir.com/categories/Android/"/>
    
    
      <category term="RxJava" scheme="https://www.x-sir.com/tags/RxJava/"/>
    
      <category term="RxJava2.x" scheme="https://www.x-sir.com/tags/RxJava2-x/"/>
    
      <category term="操作符" scheme="https://www.x-sir.com/tags/%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>RxJava2.x 操作符之 filter</title>
    <link href="https://www.x-sir.com/2019/05/23/RxJava2.x%20%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B9%8B%20filter/"/>
    <id>https://www.x-sir.com/2019/05/23/RxJava2.x 操作符之 filter/</id>
    <published>2019-05-23T09:20:00.000Z</published>
    <updated>2019-05-23T09:19:19.353Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.x-sir.com/FgcNl-lC_eHGqFwCEaAENRaAGT5r" alt=""><br>题图：Pixabay License</p><p>哈喽，朋友们，<a href="https://mp.weixin.qq.com/s/EV4afZ27lQZ8xLxnZjLZow" target="_blank" rel="noopener">上一篇文章</a>我们学习了 repeate 操作符，今天我们继续来学习 filter 操作符。</p><p>我们都知道 filter 是过滤的意思，也就是说这个操作符就是帮助我们来过滤掉一些我们不需要的数据。</p><p>举个简单的例子吧，假设上游有个数据源，顺序向下游发送 0-9 十个数字，我们只想打印大于 5 的数字，我们就可以这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Observable.interval(1, TimeUnit.SECONDS)</span><br><span class="line">   .take(10)</span><br><span class="line">   .filter(new Func1&lt;Long, Boolean&gt;() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public Boolean call(Long aLong) &#123;</span><br><span class="line">               return aLong &gt; 5;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;)</span><br><span class="line">   .subscribe(new Action1&lt;Long&gt;() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void call(Long aLong) &#123;</span><br><span class="line">               LogUtil.i(&quot;aLong===&quot; + aLong);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I/RxJavaOperatorActivity: aLong===6</span><br><span class="line">I/RxJavaOperatorActivity: aLong===7</span><br><span class="line">I/RxJavaOperatorActivity: aLong===8</span><br><span class="line">I/RxJavaOperatorActivity: aLong===9</span><br></pre></td></tr></table></figure><p>结果打印出来的都是大于 5 的数字，当然你还可以设置其他的过滤条件，例如空值等！</p><p>好了，今天的学习内容就算完成了，感觉是不是非常简单？如果你学会了就赶紧动手去实践一下吧，说不定你会有新的发现哦！</p><p>最后，我和大家分享一下我学习的一些经验或者是见解吧。我们再学习的过程中，可能学的很多东西都是点状的，我们要把学习到的东西学会融会贯通，将他们连接成线即学会相互联系，再将线形成面，再形成体，这样我们学到的知识才能形成一个完整的知识体系，不要只见树叶，不见森林，希望大家在学习的过程中，多思考，多总结！</p><p>Ps:扫描下面的二维码，关注「IT大飞说」，回复「加群」，拉你进入兄弟战斗群，最后告诉你们一个小秘密，公号对话框回复「装备01」 送你一件珍藏版的打怪装备，战斗力瞬间可增加 80！！！我使用过，效果杠杠滴！从此，我们就可以一起愉快的装逼了！</p><p>飞哥带你去装逼，一直装逼到天黑！</p><p>更多干货文章请关注我的微信公众号：<br><img src="https://img-blog.csdn.net/20180626144909992?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbnBlbmdmZWk1MjE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="扫一扫关注"></p><p>另外，我还建了一个免费的知识星球，感兴趣的微信扫码即可加入！</p><p><img src="http://image.x-sir.com/zsxq_qrcodezsxq_qrcode.jpg" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://image.x-sir.com/FgcNl-lC_eHGqFwCEaAENRaAGT5r&quot; alt=&quot;&quot;&gt;&lt;br&gt;题图：Pixabay License&lt;/p&gt;
&lt;p&gt;哈喽，朋友们，&lt;a href=&quot;https://mp.weixin.qq.
      
    
    </summary>
    
      <category term="Android" scheme="https://www.x-sir.com/categories/Android/"/>
    
    
      <category term="RxJava" scheme="https://www.x-sir.com/tags/RxJava/"/>
    
      <category term="RxJava2.x" scheme="https://www.x-sir.com/tags/RxJava2-x/"/>
    
      <category term="操作符" scheme="https://www.x-sir.com/tags/%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>RxJava2.x 操作符之 repeat</title>
    <link href="https://www.x-sir.com/2019/05/21/RxJava2.x%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B9%8Brepeat/"/>
    <id>https://www.x-sir.com/2019/05/21/RxJava2.x操作符之repeat/</id>
    <published>2019-05-21T15:51:56.000Z</published>
    <updated>2019-05-21T16:10:15.758Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.x-sir.com/FqDMiECeHHogPYMQOD61PzhARXlC" alt=""><br>题图：Pixabay License</p><p>哈喽，朋友们，<a href="https://mp.weixin.qq.com/s?__biz=MzU4MTIzNjg0Ng==&amp;mid=2247484126&amp;idx=1&amp;sn=e94a44088c9697aa36ff1ddf91e35ced&amp;chksm=fd4be3dfca3c6ac969c0ccfb39d364bbca18b651f8cd36ed1e07af174775acebcd0426a6745a&amp;token=887755948&amp;lang=zh_CN#rd" target="_blank" rel="noopener">上一篇文章</a>我们学习了 from 操作符，今天我们继续来学习 repeat 操作符。</p><p>我们都知道 repeat 是重复的意思，也就是说这个操作符就是帮助我们来操作处理一些重复的数据或者操作，repeat 有三个相关的操作符：repeat、repeatWhen、repeatUntil，从字面也很好理解，repeat 就是简单的重复操作，repeatWhen 当达到什么条件的时候重复，repeatUntil 是直到某个条件不在重复。</p><h2 id="1-repeat"><a href="#1-repeat" class="headerlink" title="1.repeat"></a>1.repeat</h2><p>举个简单的例子吧，例如我们想重复打印一下 “Hello World!”，我们就可以这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private void repeat() &#123;</span><br><span class="line">    Observable.just(&quot;Hello World!&quot;)</span><br><span class="line">            .repeat(3)</span><br><span class="line">            .subscribe(s -&gt; LogUtil.i(TAG, s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单吧，这个就不用我多说了吧。需要注意的是，如果不指定重复的次数，则会无限地重复下去！</p><h2 id="2-repeatWhen"><a href="#2-repeatWhen" class="headerlink" title="2.repeatWhen"></a>2.repeatWhen</h2><p>例如，我们想按顺序打印 0-3 的数字，当 2 秒后我们再重复打印一次，我们就可以这么写。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.range(0, 4)</span><br><span class="line">            .repeatWhen(objectObservable -&gt; Observable.timer(2, TimeUnit.SECONDS))</span><br><span class="line">            .subscribe(integer -&gt; LogUtil.i(TAG, &quot;integer===&quot; + integer));</span><br></pre></td></tr></table></figure><p>上面的代码也比较简单，首先我们使用了一个新的操作符 range，也就是范围的意思，我们可以用它来指定一个数字的范围，并按顺序发射出去，repeatWhen 中使用了一个新的操作符 timer，我们用他创建了一个定时器的被观察者对象，并指定了两秒的时长，当到达 2 秒时就会重复原始的 Observable 并重新订阅和发射。</p><h2 id="3-repeatUntil"><a href="#3-repeatUntil" class="headerlink" title="3.repeatUntil"></a>3.repeatUntil</h2><p>例如，我想间隔 1 秒顺序打印数字 0-2，当从开始打印到第 5 秒的时候就停止打印，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Observable.interval(1000, TimeUnit.MILLISECONDS)</span><br><span class="line">            .take(3)</span><br><span class="line">            .repeatUntil(() -&gt; System.currentTimeMillis() - currentTimeMillis &gt; 5000)</span><br><span class="line">            .subscribe(aLong -&gt; LogUtil.i(TAG, &quot;aLong===&quot; + aLong));</span><br></pre></td></tr></table></figure><p>这里我们使用了一个新的操作符 interval，它可以指定时间单位的时长发送数字序列，还有一个操作符是 take，它表示只取前 3 个，注意：从 0 开始，不包含它自己，接下来我们在 repeatUntil 里加了个判断，当大于 5 秒就停止重复打印。</p><p>执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">I/RxJavaOperatorActivity: aLong===0</span><br><span class="line">I/RxJavaOperatorActivity: aLong===1</span><br><span class="line">I/RxJavaOperatorActivity: aLong===2</span><br><span class="line">I/RxJavaOperatorActivity: aLong===0</span><br><span class="line">I/RxJavaOperatorActivity: aLong===1</span><br><span class="line">I/RxJavaOperatorActivity: aLong===2</span><br></pre></td></tr></table></figure><p>怎么样？是不是立马就明白了。</p><p>好了，今天的学习内容就算完成了，感觉是不是非常简单？如果你学会了就赶紧动手去实践一下吧，说不定你会有新的发现哦！</p><p>最后，我和大家分享一下我学习的一些经验或者是见解吧。我们再学习的过程中，可能学的很多东西都是点状的，我们要把学习到的东西学会融会贯通，将他们连接成线即学会相互联系，再将线形成面，再形成体，这样我们学到的知识才能形成一个完整的知识体系，不要只见树叶，不见森林，希望大家在学习的过程中，多思考，多总结！</p><p>Ps:扫描下面的二维码，关注「IT大飞说」，回复「加群」，拉你进入兄弟战斗群，最后告诉你们一个小秘密，公号对话框回复「装备01」 送你一件珍藏版的打怪装备，战斗力瞬间可增加 80！！！我使用过，效果杠杠滴！从此，我们就可以一起愉快的装逼了！</p><p>飞哥带你去装逼，一直装逼到天黑！</p><p>更多干货文章请关注我的微信公众号：<br><img src="https://img-blog.csdn.net/20180626144909992?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbnBlbmdmZWk1MjE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="扫一扫关注"></p><p>另外，我还建了一个免费的知识星球，感兴趣的微信扫码即可加入！</p><p><img src="http://image.x-sir.com/zsxq_qrcodezsxq_qrcode.jpg" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://image.x-sir.com/FqDMiECeHHogPYMQOD61PzhARXlC&quot; alt=&quot;&quot;&gt;&lt;br&gt;题图：Pixabay License&lt;/p&gt;
&lt;p&gt;哈喽，朋友们，&lt;a href=&quot;https://mp.weixin.qq.
      
    
    </summary>
    
      <category term="Android" scheme="https://www.x-sir.com/categories/Android/"/>
    
    
      <category term="RxJava" scheme="https://www.x-sir.com/tags/RxJava/"/>
    
      <category term="RxJava2.x" scheme="https://www.x-sir.com/tags/RxJava2-x/"/>
    
      <category term="操作符" scheme="https://www.x-sir.com/tags/%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>RxJava2.x 创建操作符之 from</title>
    <link href="https://www.x-sir.com/2019/05/19/RxJava2.x%E5%88%9B%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B9%8Bfrom/"/>
    <id>https://www.x-sir.com/2019/05/19/RxJava2.x创建操作符之from/</id>
    <published>2019-05-19T10:34:56.000Z</published>
    <updated>2020-04-08T09:22:24.289Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.x-sir.com/FstPHz-8U7d4k5MmkgEMSV2u4jZI" alt=""><br>题图：Pixabay License</p><p>哈喽，朋友们，<a href="https://mp.weixin.qq.com/s?__biz=MzU4MTIzNjg0Ng==&amp;mid=2247484120&amp;idx=1&amp;sn=92c23454794cd38b6b10f3584446a4ef&amp;chksm=fd4be3d9ca3c6acfd6154829fc2c4a0dd8ce778301d861a834e906d37500a8e9c69e78c0671f&amp;token=109718556&amp;lang=zh_CN#rd" target="_blank" rel="noopener">上一篇文章</a>我们学习了 create &amp; just 操作符，今天我们继续来学习 from 操作符。</p><p>from 操作符和 just 操作符一样，也属于创建操作符的一种，from 可将其他种类的对象和数据类型转换为 Observable。</p><p>从概念看，just 和 from 是比较相似的，那么，他们两者有什么区别呢？</p><p>just 只是简单的原样发射，它会将数组或 Iterable 当做单个数据发射出去，而 from 会将数组或 Iterable 的数据按顺序取出来，然后逐个发射出去，举个例子你就明白了。</p><p>举例，我们初始化了一个 list，分别用 just 和 fromIterable 操作符进行处理，并打印了数据的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">for (int i = 0; i &lt; 6; i++) &#123;</span><br><span class="line">    list.add(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Observable.just(list).subscribe((Consumer&lt;List&gt;) list1 -&gt; LogUtil.i(TAG, &quot;just():&quot; + Arrays.toString(list1.toArray())));</span><br><span class="line"></span><br><span class="line">Observable.fromIterable(list).subscribe(integer -&gt; LogUtil.i(TAG, &quot;fromIterable():&quot; + integer));</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">I/RxJavaOperatorActivity: just():[0, 1, 2, 3, 4, 5]</span><br><span class="line">I/RxJavaOperatorActivity: fromIterable():0</span><br><span class="line">I/RxJavaOperatorActivity: fromIterable():1</span><br><span class="line">I/RxJavaOperatorActivity: fromIterable():2</span><br><span class="line">I/RxJavaOperatorActivity: fromIterable():3</span><br><span class="line">I/RxJavaOperatorActivity: fromIterable():4</span><br><span class="line">I/RxJavaOperatorActivity: fromIterable():5</span><br></pre></td></tr></table></figure><p>从上面打印的日志我们可以看到，just 是将整个 list 数据传递下来了，而 fromIterable 是将 list 中的数据遍历并一个一个发射出去，数组也是一样的道理，数组使用 fromArray 操作符。</p><p>这里需要注意一个点，just 是可以接收 1-10 参数的，如果传入 1-5 的数字作为参数，那么它也会按顺序去打印的，而不是作为一个数组发射出去。</p><p>举个例子你就明白了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(1, 2, 3, 4, 5).subscribe(integer -&gt; LogUtil.i(TAG, &quot;just():&quot; + integer));</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">I/RxJavaOperatorActivity: just():1</span><br><span class="line">I/RxJavaOperatorActivity: just():2</span><br><span class="line">I/RxJavaOperatorActivity: just():3</span><br><span class="line">I/RxJavaOperatorActivity: just():4</span><br><span class="line">I/RxJavaOperatorActivity: just():5</span><br></pre></td></tr></table></figure><p>怎么样？是不是瞬间就懂了。</p><p>另外，from 还有一个 fromFuture 操作符，Future 是什么东西？fromFuture 又是如何使用的呢？这个问题问的好，大飞这就给你细细道来。</p><p>Future 是 java.util.concurrent 包下的一个接口，我们都知道，创建线程的 2 种方式，一种是直接继承 Thread，另外一种就是实现 Runnable接口，但是这 2 种方式都有一个缺点就是在执行完任务之后无法获取执行的结果。</p><p>如果需要获取执行结果，就必须通过共享变量或者使用线程通信的方式来达到效果，这样使用起来就比较麻烦。而自从 JDK 1.5 开始，给我们提供了 Callable 和 Future 接口，通过这两个接口我们可以在任务执行完毕之后得到线程执行的结果。</p><p>一般来说，Callable 需要和 ExecutorService 配合来使用的，举个非常简单的例子吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">static class MyCallable implements Callable&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Integer call() throws Exception &#123;</span><br><span class="line">        LogUtil.i(TAG, &quot;call():在这里模拟一些耗时操作...&quot;);</span><br><span class="line">        Thread.sleep(3000);</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int i = 0; i &lt;= 100; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void calculate() &#123;</span><br><span class="line">    ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    Future&lt;Integer&gt; future = executorService.submit(new MyCallable());</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        LogUtil.i(TAG, &quot;任务运行的结果：&quot; + future.get());</span><br><span class="line">    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; catch (ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码也比较简单，我相信大家都能看得懂，我们的 MyCallable 类实现了 Callable 接口，在 call 方法中进行了一些耗时的操作，然后将结果返回出去，紧接着我们创建了一个线程池，创建了一个 MyCallable 的对象并将其提交到线程池中，最后将执行的结果打印出来。</p><p>执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2019-05-19 16:22:36.932 I/RxJavaOperatorActivity: call():在这里模拟一些耗时操作...</span><br><span class="line">2019-05-19 16:22:40.933 I/RxJavaOperatorActivity: 任务运行的结果：5050</span><br></pre></td></tr></table></figure><p>我们再来看看如何配合 RxJava 来使用，这里使用到了 fromFuture 操作符，其实使用起来非常简单，简单修改一下上面的代码，相信你立刻就秒懂了！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Observable.fromFuture(future).subscribe(s -&gt; LogUtil.i(TAG, &quot;任务运行的结果：&quot; + s));</span><br></pre></td></tr></table></figure><p>这里我们就不调用 future 的 get 方法来获取执行的结果了，而是将 future 对象使用 fromFuture 操作符将其作为参数传递进去，当任务执行完成后，我们的观察者就会收到执行完后的结果，说白了就是 RxJava 内部帮你执行了 get 的方法并把结果回调给你了。</p><p>总结一下，对于 Future，它会发射 Future.get() 方法返回的单个数据。</p><p>细心的你可能已经发现了，fromFuture 还有一个重载方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fromFuture(Future&lt;? extends T&gt; future, long timeout, TimeUnit unit)；</span><br></pre></td></tr></table></figure><p>那第二个参数和第三个参数是什么意思呢？先别急，我们先看下 Future 接口的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface Future&lt;V&gt; &#123;</span><br><span class="line">    boolean cancel(boolean mayInterruptIfRunning);</span><br><span class="line">    boolean isCancelled();</span><br><span class="line">    boolean isDone();</span><br><span class="line">    V get() throws InterruptedException, ExecutionException;</span><br><span class="line">    V get(long timeout, TimeUnit unit)</span><br><span class="line">        throws InterruptedException, ExecutionException, TimeoutException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到没有，我们发现原来 get 方法也有一个重载方法，也就是说 fromFuture 3 个参数的方法中后两个参数对应的就是 get 重载方法中的这两个参数。</p><p>那么问题来了，这两个参数有什么作用呢？这两参数的意思是，我们可以指定执行任务的时长和时间单位，如果过了指定的时长，Future 还没有返回一个结果，那么这个 Observable 就会发射异常通知并终止。</p><p>我们可以测试一下是不是这样的。我们现在指定一个执行任务的时长，我在执行任务的方法中睡了 3 秒，那么这里我就给它设置成 2 秒，这样设置，任务肯定是没有执行完成的，我们看看这个时候会不会和我们猜测的一样会抛异常。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Observable.fromFuture(future, 2, TimeUnit.SECONDS).subscribe(s -&gt; Observable.fromFuture(future, 2, TimeUnit.SECONDS)</span><br><span class="line">                .subscribe(s -&gt; LogUtil.i(TAG, &quot;任务运行的结果：&quot; + s)</span><br><span class="line">                        , throwable -&gt; LogUtil.e(TAG, &quot;onError:&quot; + throwable.getMessage()));</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I/RxJavaOperatorActivity: call():在这里模拟一些耗时操作...</span><br><span class="line">E/RxJavaOperatorActivity: onError:null</span><br></pre></td></tr></table></figure><p>看到没有，果不其然报错了，这样我们就可以在超时的时候做一些处理了。</p><p>好了，我们今天的学习目标就算达成了，感觉是不是很简单，很轻松？我们来回顾下今天所学的东西，首先我们学习了 fromIterable 操作符，它与 just 操作符有相似之处，因此我将其与 just 操作符举例说明了他们的区别。</p><p>紧接着我们回顾了 Java 中创建线程的相关知识，并学会了将其配合 fromFuture 操作符一起使用，真的是非常方便的。</p><p>如果你学会了就赶紧动手去实践一下吧，有数据表明，学习后实践的吸收效果比不实践的效果高几十倍！</p><p>今天的内容确实比较轻松和简单，后面我将继续带领大家一起学习新的内容，大家敬请期待吧！</p><p>最后，我和大家分享一下我学习的一些经验或者是见解吧。我们再学习的过程中，可能学的很多东西都是点状的，我们要把学习到的东西学会融会贯通，将他们连接成线即学会相互联系，再将线形成面，再形成体，这样我们学到的知识才能形成一个完整的知识体系，不要只见树叶，不见森林，希望大家在学习的过程中，多思考，多总结！</p><p>Ps:扫描下面的二维码，关注「IT大飞说」，回复「加群」，拉你进入兄弟战斗群，最后告诉你们一个小秘密，公号对话框回复「装备01」 送你一件珍藏版的打怪装备，战斗力瞬间可增加 80！！！我使用过，效果杠杠滴！从此，我们就可以一起愉快的装逼了！</p><p>飞哥带你去装逼，一直装逼到天黑！</p><p>更多干货文章请关注我的微信公众号：<br><img src="https://img-blog.csdn.net/20180626144909992?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbnBlbmdmZWk1MjE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="扫一扫关注"></p><p>另外，我还建了一个免费的知识星球，感兴趣的微信扫码即可加入！</p><p><img src="http://image.x-sir.com/zsxq_qrcodezsxq_qrcode.jpg" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://image.x-sir.com/FstPHz-8U7d4k5MmkgEMSV2u4jZI&quot; alt=&quot;&quot;&gt;&lt;br&gt;题图：Pixabay License&lt;/p&gt;
&lt;p&gt;哈喽，朋友们，&lt;a href=&quot;https://mp.weixin.qq.
      
    
    </summary>
    
      <category term="Android" scheme="https://www.x-sir.com/categories/Android/"/>
    
    
      <category term="RxJava" scheme="https://www.x-sir.com/tags/RxJava/"/>
    
      <category term="RxJava2.x" scheme="https://www.x-sir.com/tags/RxJava2-x/"/>
    
      <category term="操作符" scheme="https://www.x-sir.com/tags/%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>RxJava2.x创建操作符之create和just (打怪升级版)！！！</title>
    <link href="https://www.x-sir.com/2019/05/18/RxJava2.x%E5%88%9B%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B9%8Bcreate%E5%92%8Cjust%20(%E6%89%93%E6%80%AA%E5%8D%87%E7%BA%A7%E7%89%88)%EF%BC%81%EF%BC%81%EF%BC%81/"/>
    <id>https://www.x-sir.com/2019/05/18/RxJava2.x创建操作符之create和just (打怪升级版)！！！/</id>
    <published>2019-05-18T06:52:56.000Z</published>
    <updated>2019-05-22T12:43:51.202Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://image.x-sir.com/FktTLU6ea8mEdcLduIBEfTh8ZYdV" alt=""></p><p>题图：来自网络</p><p>哈喽，朋友们，好久不见了，有段时间没推文了。从今天开始，我将计划更新 RxJava2.x 系列的文章，RxJava 是什么东西，我想也不用给大家介绍了吧。</p><p>其实，网上关于 RxJava 的相关文章一大堆，我之前也看过不少，对于新手来说，那些文章，要么就是比较长，不容易看下去，要么就是讲的全是理论，晦涩难懂，缺少实践性。</p><p>因此，我打算从今天开始，更新一系列的 RxJava2.x 教程，主要从常用的操作符讲起，目的很简单，带大家每天学会一个操作符的使用。</p><p>操作符是 RxJava 的重要组成部分，因此学习操作符也是非常重要的，RxJava 的操作符虽然说比较多，但是我们可以将其进行分类，然后逐一进行理解学习，其实也是比较容易和轻松的，RxJava 的操作符大致可以分为以下几类：</p><p><img src="http://image.x-sir.com/FofYPEnQJ_1W2CKeqjO8XHWgakyX" alt=""></p><p>今天，我们先来学习两个简单的创建操作符 create &amp; just。</p><p>在学习之前，我们先来回顾下观察者模式，大多数同学应该都不陌生吧，例如 Android 的EventBus 等框架都使用了观察者模式，简单说这就是一种发布、订阅的模式，你可以简单理解为订阅报纸。</p><p>这与 RxJava 又有什么关系呢？我们先来看下 Rx 的概念：Rx 是一个使用可观察数据流进行异步编程的编程接口，也就是说 RxJava 中使用了观察者模式的这种编程思想，另外还结合了迭代器模式和函数式编程，并把它运用发挥到了极致。</p><p>我们都知道观察者模式中，有 3 个重要的概念，被观察者，观察者和订阅，类比到现实中订阅报纸的场景中就是，报纸是被观察者，阅读报纸的人是观察者，人订阅了报纸也就是说使用订阅将他们两者关联起来，这样就形成了一种发布、订阅的关系。</p><p>举个例子吧，我们来看看 Android 中点击事件的处理，注意：观察者模式与点击回调模式有很多的相似处，简单对比就是：回调是一对一的关系，只监听一个事件；观察者模式则是一个主题，可以有多个监听者，当主题变化时，向部分或所有监听者发出变化的通知，观察者模式是一对多的关系。</p><p><img src="http://image.x-sir.com/FqENsbJlDpDhhbFg7_fllxjBkAsu" alt=""></p><p>上面的代码很简单吧，我相信大家都能看得懂，一般我们习惯上将监听器写成匿名的，这里我是为了给大家做类比，所以分开写了，然后我们再结合观察者模式看看上面的代码，第一步实例化一个 Button 就相当于是创建了一个被观察者，第二步初始化一个监听器就相当于是创建了一个观察者，第三步将监听器和 Button 绑定就相当于是把被观察者和观察者通过订阅将他们两者关联起来，是不是理解起来非常简单。</p><p>我们再来看看 RxJava 如何来实现，我们就先从最简单的 Hello World 学习起来吧，同样的还是三步走！</p><p>第一步，创建被观察者（Observable）<br>第二步，创建观察者（Observer）<br>第三步，将被观察者和观察者绑定（subscribe）</p><p><img src="http://image.x-sir.com/FnIeZphHHxbniPktU0LPojPy-uLe" alt=""></p><p>和上面的点击事件对比一下，是不是感觉有异曲同工之妙？但是我们习惯上一般不分开写，而是将方法的调用写成链式调用，将对对象写成匿名的对象，我们将上面的代码变换下，如下所示：</p><p><img src="http://image.x-sir.com/FhRcbDj6_Pav2DBwUQRLpbMBRJJw" alt=""></p><p>我们看到，在上面的创建被观察者的 subscribe 方法中，调用了 onNext 方法，将 “Hello World” 字符串传递下去，而在下面调用 subscribe 的时候，传递了一个 Consumer 对象（观察者），而这个 Consumer 的回调方法就会收到 onNext 的传递过来的值，接着，我们在下面打印了一下 onNext 传递过来的字符串。</p><p>实际上，subscribe（订阅）是一个重载方法，它可以接收 0-4 个参数，当传递一个参数时，就代表接收处理成功时的回调（onNext），如传递多个参数则代表接收处理错误、完成、当订阅完成时的事件处理，我们这里为了演示，就只处理成功事件就行了。</p><p>上面的代码看着还是不太完美，我们这里使用 just 操作符将它改造一下，just 是什么鬼？看着怎么一脸懵逼，好吧，那就让大飞哥来给你讲解下 just 操作符。</p><p>just 操作符和 create 操作符一样，也是创建操作符的一种，just 操作符是将一个或多个对象转换成发射这个或这些对象的一个 Observable，看完概念还是一脸懵逼怎么办？确实，这些概念是比较抽象的，其实，用起来特别简单，当你会用了之后，你再回过头去理解起来会容易很多。</p><p>来继续将我们的 Hello World 用 just 操作符改造一下：</p><p><img src="http://image.x-sir.com/FqctUFNUoi_pT5I0QQX4Q1R99LdF" alt=""></p><p>怎么样，是不是更简单了，我们点开 just 方法，我们看到它接收的是一个 T，也就是说它可以接收任意类型的参数，我们以后就可以使用 just 操作符来很方便的创建各种被观察者对象了，非常棒！我们又学会了一个操作符，欧耶！</p><p>上面的代码看着还是有点长，我们可以用 Lambda 表达式改造一下看看：</p><p><img src="http://image.x-sir.com/FlGPbco53npYjS-AkQ4jxKwoQfJx" alt=""></p><p>哇哦！It’s beautiful! 一行代码就搞定了，有木有？</p><p>至此，我们今天的学习目标就算达成了，感觉是不是很简单，很轻松？</p><p>如果你学会了就赶紧动手去实践一下吧，实践是检验真理的唯一标准，眼过千遍不如手过一遍，代码是用来敲的不是用来看的，希望我们程序员都是实干家！</p><p>今天的内容确实比较轻松和简单，后面还有更大的挑战呢，从今天开始，大飞哥将带你一起打怪升级练本领，一起去闯关，去战斗！大家敬请期待吧！</p><p>最后，引用大飞哥的一句名言作为结尾吧：“是兄弟，就一起去战斗吧！”</p><p>Ps:扫描下面的二维码，关注「IT大飞说」，回复「加群」，拉你进入兄弟战斗群，最后告诉你们一个小秘密，公号对话框回复「装备01」 送你一件珍藏版的打怪装备，战斗力瞬间可增加 80！！！我使用过，效果杠杠滴！从此，我们就可以一起愉快的装逼了！</p><p>飞哥带你去装逼，一直装逼到天黑！</p><p>更多干货文章请关注我的微信公众号：<br><img src="https://img-blog.csdn.net/20180626144909992?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbnBlbmdmZWk1MjE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="扫一扫关注"></p><p>另外，我还建了一个免费的知识星球，感兴趣的微信扫码即可加入！</p><p><img src="http://image.x-sir.com/zsxq_qrcodezsxq_qrcode.jpg" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://image.x-sir.com/FktTLU6ea8mEdcLduIBEfTh8ZYdV&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;题图：来自网络&lt;/p&gt;
&lt;p&gt;哈喽，朋友们，好久不见了，有段时间没推文了。从今天开始，我将计划更新 RxJava2.x
      
    
    </summary>
    
      <category term="Android" scheme="https://www.x-sir.com/categories/Android/"/>
    
    
      <category term="RxJava" scheme="https://www.x-sir.com/tags/RxJava/"/>
    
      <category term="RxJava2.x" scheme="https://www.x-sir.com/tags/RxJava2-x/"/>
    
      <category term="操作符" scheme="https://www.x-sir.com/tags/%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>你不知道的 Gradle 高级技巧（一）</title>
    <link href="https://www.x-sir.com/2019/01/30/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%20Gradle%20%E6%8A%80%E5%B7%A7/"/>
    <id>https://www.x-sir.com/2019/01/30/你不知道的 Gradle 技巧/</id>
    <published>2019-01-30T06:52:30.000Z</published>
    <updated>2019-01-30T06:52:57.695Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>作为一名Android 开发者，我们都有发布 APP 内测版本的经历，有的公司是发布到自己的服务器上，生成一个连接或者二维码扫描就可以下载，有的公司使用一些内测平台如蒲公英、fir.im 等，有这么好的内测平台为什么不用呢？一方面这些平台的基本都是免费提供服务的，另外一方面也提供了许多丰富的 api，方便开发者使用，提升效率！</p></blockquote><h2 id="1"><a href="#1" class="headerlink" title="1."></a><em>1.</em></h2><p>前段时间研究 Android 端的自动打包，采用的是 Jenkins + Git 的方式，这样，当你 push 完代码之后，Jenkins 会自动拉取你的代码，然后再用 Gradle 工具进行自动化打包，Jenkins 可以配置许多插件，当打包完之后可以自动上传到蒲公英和 fir.im 等平台，特别方便，基本就是这么个流程，我们之前公司是运维帮我们在服务器端搭建的自动打包程序，这样的好处是当你需要打几十个包时，特别快，因为服务器的配置一般比电脑都高，并且不用占用自己电脑的资源。我自己前段时间也在自己的电脑上装了一个 Jenkins，然后一些配置，也可以进行自动化打包，但是我觉得没必要，因为你把代码 push 上去，然后再拉下来，然后再打包，用的还是你本地电脑的资源，还不如直接用 AS 打包来的快，我看了下 Jenkins 上传到公测平台的实现，其实就是用了一个 <code>curl</code> 命令来实现的，我就想着能不能在 <strong>Gradle</strong> 中配置上传的脚本？答案当然是可以的！</p><h2 id="2"><a href="#2" class="headerlink" title="2."></a><em>2.</em></h2><p>首先，我们了解下什么是 curl？</p><p>下面的概念来自某度的解释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl 命令是一个利用 URL 规则在命令行下工作的文件传输工具。它支持文件的上传和下载，所以是综合传输工具，但按传统，习惯称 curl 为下载工具。作为一款强力工具，curl 支持包括 HTTP、HTTPS、ftp 等众多协议，还支持 POST、cookies、认证、从指定偏移处下载部分文件、用户代理字符串、限速、文件大小、进度条等特征。</span><br></pre></td></tr></table></figure><p>简单说他就是一个命令，Linux 和 Mac 系统自带，Windows 需要安装 curl 才能使用，在哪里下载 curl?为了方便大家我已经帮大家下载好了，复制下面的字符发送到后台即可：</p><center><strong>curl</strong></center><p>里面包含 32 位 &amp; 64 位的安装程序，还有安装教程的链接供大家参考，安装完成后需要配置环境变量，然后在 cmd 中输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --version</span><br></pre></td></tr></table></figure><p>如果显示 curl 的版本号说明安装成功了~</p><h2 id="3"><a href="#3" class="headerlink" title="3."></a><em>3.</em></h2><p>有了 curl 命令，我们就可以执行 curl 命令来进行上传文件了，我们先看下蒲公英上传 apk 的接口文档，如下图：</p><p><img src="https://img-blog.csdnimg.cn/20190130093717762.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbnBlbmdmZWk1MjE=,size_16,color_FFFFFF,t_70" alt="image"></p><p>其中，_api_key、uKey 和 file 字段是必须的，其他参数都是可选项，_api_key 和 uKey 蒲公英都会为每个 APP 自动分配一个，在你的蒲公英账号对应的 APP 的信息中可以找到，file 参数就是要上传的文件了，为了让我们上传的 APP 有每次更新的描述，我们还需要添加一个 buildUpdateDescription 字段，这样，每次上传 APP 之后就可以显示本次更新的描述信息了。</p><p>文档看完之后，我们需要使用 curl 命令来发送一个上传文件的 POST 请求，url 的语法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl(选项)(参数)</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20190130093812715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbnBlbmdmZWk1MjE=,size_16,color_FFFFFF,t_70" alt="image"></p><p>curl 命令的选项有很多，上图只是截取了其中的一部分，根据蒲公英上传 APP 的接口文档，提交的是 multipart/form-data 类型的数据，因此我们使用 -F 选项，我们可以写出伪命令了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -F 参数1 -F 参数2 -F 参数3 接口地址</span><br></pre></td></tr></table></figure><p>因为我们上传 APP 需要 3 个参数，所以这里也需要三个参数，后面再加上我们请求的接口地址就可以了，这应该很好理解吧？</p><p>我们再把参数部分替换成真实的的参数，完整的命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -F &quot;file=app/build/outputs/apk/release/release-v1.0.apk&quot; -F &quot;uKey=ce0e825125bfe666762b2a93feb7de00&quot; -F &quot;_api_key=534a49154990d8e9126918fbdbee600a&quot; -F &quot;buildUpdateDescription=bugs fix!&quot; https://www.pgyer.com/apiv2/app/upload</span><br></pre></td></tr></table></figure><p>好了，一条完整的 curl 上传命令算是完成了，其中，-F 后面的参数是字段名和参数的值，中间用 “=” 号进行连接，然后我们打开 AS 的 Terminal，执行上面的命令即可进行上传 apk 到蒲公英，上传过程也有进度显示，如果显示 100%，说明上传成功了，注意上面的 uKey 和 _api_key 的值换成你自己的，另外也要注意你打完包的 apk 文件路径要真实存在，否则会出现异常！</p><h2 id="4"><a href="#4" class="headerlink" title="4."></a><em>4.</em></h2><p>上面我们已经学会了使用 curl 命令上传我们的 apk 了，但是你们有没有发现，我们每次上传 apk 需要好几步：</p><ul><li>打包 apk；</li><li>修改上传命令中 apk 的文件名和描述信息；</li><li>复制 curl 命令到 Terminal 中执行；</li><li>…</li></ul><p>至少需要 3 步才能完成，这也是一件非常麻烦的事情，作为程序员，都是比较懒的，与其说懒不如说是机智，避免做浪费时间的事情，我再想，能不能一条命令一步到位呢？当然是可以的。</p><p>我们先进行改造上传命令的第一步，先把 curl 命令中 file 的值，也就是 apk 路径动态进行获取，这样就不用每次都去修改了，我们知道 gradle 语法中的字符串有两种，一种是单引号，另一种是双引号，区别就是，双引号支持插值，这样我们就可以写一个方法，这个方法的作用就是获取打包好的 apk 的全路径，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def getApkFullPath() &#123;</span><br><span class="line">    return rootDir.getAbsolutePath() + &quot;/app/build/outputs/apk/release/&quot; + getApkName()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">def getApkName() &#123;</span><br><span class="line">    return &quot;update-app-example-v$&#123;android.defaultConfig.versionName&#125;-$&#123;releaseTime()&#125;.apk&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static def releaseTime() &#123;</span><br><span class="line">    return new Date().format(&quot;yyyy-MM-dd&quot;, TimeZone.getTimeZone(&quot;UTC&quot;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面总共有 3 个方法，也比较简单，大家应该都能看得懂，就不过多解释了，其中第一个方法中的 <code>rootDir.getAbsolutePath()</code> 说一下，它可以获取你当前项目在你本地电脑的全路径。</p><p>方法写好了，我们还需要把打包脚本稍微修改下，具体如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">release &#123;</span><br><span class="line">            minifyEnabled false</span><br><span class="line">            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;</span><br><span class="line">            signingConfig signingConfigs.release</span><br><span class="line">            android.applicationVariants.all &#123; variant -&gt;</span><br><span class="line">                variant.outputs.all &#123;</span><br><span class="line">                    outputFileName = getApkName()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>注意看上面的 <code>outputFileName = getApkName()</code>，这样写每次生成的 apk 的名字就是我们要获取的 apk 的文件名，这样每次打包完后我们都能获取到打包完后的 apk 的文件名了！这样，我们 curl 上传命令中动态获取 apk 文件路径这个问题就算解决了，我们再看下我们的 curl 命令中还有 uKey 和 _api_key 两个参数，因为这两个值属于比较私密的东西我们一般都是配置到 <code>local.properties</code> 文件中，然后动态读取的，git 默认是忽略提交 <code>local.properties</code> 文件的，这样防止自己的私密信息被提交和泄露出去，因此，这里也写个方法动态读取一下吧：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def readProperties(key) &#123;</span><br><span class="line">    File file = rootProject.file(&apos;local.properties&apos;)</span><br><span class="line">    if (file.exists()) &#123;</span><br><span class="line">        InputStream inputStream = rootProject.file(&apos;local.properties&apos;).newDataInputStream()</span><br><span class="line">        Properties properties = new Properties()</span><br><span class="line">        properties.load(inputStream)</span><br><span class="line"></span><br><span class="line">        if (properties.containsKey(key)) &#123;</span><br><span class="line">            return properties.getProperty(key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法也比较简单，相信大家都能看的明白！</p><p>现在我们的上传命令中还有一个字段 <code>buildUpdateDescription</code>，更新描述信息，每次上传 apk 都需要修改一下更新的描述，直接在命令中修改，也不太好，因此我们也写个方法动态获取吧，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static def getUpdateDescription() &#123;</span><br><span class="line">    return &apos;1.修复一些bug；\n2.提升用户体验！&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，非常简单，一目了然，只要是程序员都能看得懂，如果你看不懂，说明你是伪程序员！</p><p>好了，终于完成了，我们最终上传的命令被改造成了这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -F &quot;file=@$&#123;getApkFullPath()&#125;&quot; -F &quot;uKey=$&#123;readProperties(&apos;pgyer.userKey&apos;)&#125;&quot; -F &quot;_api_key=$&#123;readProperties(&apos;pgyer.apiKey&apos;)&#125;&quot; -F &quot;buildUpdateDescription=$&#123;getUpdateDescription()&#125;&quot; https://www.pgyer.com/apiv2/app/upload</span><br></pre></td></tr></table></figure><h2 id="5"><a href="#5" class="headerlink" title="5."></a><em>5.</em></h2><p>上面的命令算是改造完成了，不知道你们有没有发现，有个致命的问题就是，这条命令怎么执行啊？因为我么你的命令中动态调用了 Gradle 中我们写的方法，直接在 Terminal 中执行肯定是会报错的！这可就尴尬了。。我们想了想，要想让我们上传命令中的方法能够被成功调用，这个命令和被调用的方法肯定是在同一个 Gradle 文件中的，我们再想能不能写一个 Task，这这个 Task 中执行我们的上传命令，这样不就解决问题了吗？嗯，想了想是可以的，我发现在写的过程中 Task 好写，但是我们这个命令怎么才能够执行呢？肯定也需要一个东西才能执行我们的命令，搜了下，Gradle 中有个 <code>exec</code> 东西，它可以执行一条具体的 bash 命令，嗯，灰常不错，可以的，very good!真香！最终我们写的完整的 Task 如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">task(&quot;uploadApk&quot;) &#123;</span><br><span class="line">        def command = &quot;curl -F \&quot;file=@$&#123;getApkFullPath()&#125;\&quot; -F \&quot;uKey=$&#123;readProperties(&apos;pgyer.userKey&apos;)&#125;\&quot; -F \&quot;_api_key=$&#123;readProperties(&apos;pgyer.apiKey&apos;)&#125;\&quot; -F \&quot;buildUpdateDescription=$&#123;getUpdateDescription()&#125;\&quot; https://www.pgyer.com/apiv2/app/upload&quot;</span><br><span class="line">        println &quot;command:&quot; + command</span><br><span class="line">        try &#123;</span><br><span class="line">            exec &#123;</span><br><span class="line">                ExecSpec execSpec -&gt;</span><br><span class="line">                    executable &apos;bash&apos;</span><br><span class="line">                    args &apos;-c&apos;, command</span><br><span class="line">            &#125;</span><br><span class="line">            println &quot;uploadApk success~&quot;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码相对也比较简单，其中 <code>ExecSpec</code> 大家可能看着比较陌生，executable ‘bash’ 为固定写法，其中 bash 代表 shell 的类型，Linux 下有很多种 shell 的类型，流行的 shell 有 ash、bash、ksh、csh、zsh 等，一般我们常用的都是 bash，其中的 command 就是一条具体的命令了。</p><p>这样，我们只要执行这个 Task 就可以自动执行上传命令并动态获取我们所需要的参数了~</p><h2 id="6"><a href="#6" class="headerlink" title="6."></a><em>6.</em></h2><p>上面的命令执行起来是非常方便的，但是在实际使用中，我们发现，需要先打完包之后才能执行上传的 Task，我们知道 Gradle 中的 Task 是可以依赖另一个 Task 的，打包命令实质上也是一个 Task，这样我们让我们自己写的 Task 依赖于打包的 Task 不就行了吗？我觉得没毛病，这样，当执行完打包后，自动执行上传命令，这样一条命令就可以解决问题，另外，我们自己的 Task 也需要稍微修改下，将上传的实现部分放到 <code>doLast</code> 闭包中，完成代码入下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">task(&quot;uploadApk&quot;) &#123;</span><br><span class="line">    doLast &#123;</span><br><span class="line">        def command = &quot;curl -F \&quot;file=@$&#123;getApkFullPath()&#125;\&quot; -F \&quot;uKey=$&#123;readProperties(&apos;pgyer.userKey&apos;)&#125;\&quot; -F \&quot;_api_key=$&#123;readProperties(&apos;pgyer.apiKey&apos;)&#125;\&quot; -F \&quot;buildUpdateDescription=$&#123;getUpdateDescription()&#125;\&quot; https://www.pgyer.com/apiv2/app/upload&quot;</span><br><span class="line">        println &quot;command:&quot; + command</span><br><span class="line">        try &#123;</span><br><span class="line">            exec &#123;</span><br><span class="line">                ExecSpec execSpec -&gt;</span><br><span class="line">                    executable &apos;bash&apos;</span><br><span class="line">                    args &apos;-c&apos;, command</span><br><span class="line">            &#125;</span><br><span class="line">            println &quot;uploadApk success~&quot;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">uploadApk.dependsOn(&quot;assembleRelease&quot;)</span><br></pre></td></tr></table></figure><p>从此，我们只要在 Terminal 中执行一条命令就可以实现打包上传了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./gradlew uploadApk</span><br></pre></td></tr></table></figure><p>温馨提示：Windows 用户执行命令不需要加 ./</p><p>怎么样？是不是很爽！这个效率上的提升不是一点半点，后续我再想能不能把这个功能封装成一个 Gradle 插件的形式，提供给大家使用，这样也许是要添加一两行代码引用一下插件的就可以使用了，这样就更加方便了，敬请期待吧~</p><p>如果我的文章对你有用，欢迎留言！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;作为一名Android 开发者，我们都有发布 APP 内测版本的经历，有的公司是发布到自己的服务器上，生成一个连接或者二维码扫描就可以下载，有的公司使用一些内测平台如蒲公英、fir.im 等，有这么好的内测平台为什么不用呢？一方面这些平台的基本都是
      
    
    </summary>
    
      <category term="Android" scheme="https://www.x-sir.com/categories/Android/"/>
    
    
      <category term="pgyer" scheme="https://www.x-sir.com/tags/pgyer/"/>
    
      <category term="Gradle" scheme="https://www.x-sir.com/tags/Gradle/"/>
    
      <category term="upload" scheme="https://www.x-sir.com/tags/upload/"/>
    
  </entry>
  
  <entry>
    <title>一行代码实现蒲公英市场APP检查更新</title>
    <link href="https://www.x-sir.com/2019/01/08/%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E8%92%B2%E5%85%AC%E8%8B%B1%E5%B8%82%E5%9C%BAAPP%E6%A3%80%E6%9F%A5%E6%9B%B4%E6%96%B0/"/>
    <id>https://www.x-sir.com/2019/01/08/一行代码实现蒲公英市场APP检查更新/</id>
    <published>2019-01-08T14:40:00.000Z</published>
    <updated>2019-01-09T14:41:06.007Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我们知道，只要是个 APP 就都有更新的功能，可以说这个功能是比较重要的功能，我们在上架之前都会发布测试的版本，测试一般都是发布到蒲公英、Fir.im 等平台，可以说这个需求也算是比较普遍的一个功能了，之前我们的 APP 用的是蒲公英公测，然后现在又有一个新的 APP 需要，这就需要把之前的更新功能重写一遍，其实这是比较麻烦的，也没有必要，我想着能不能把这个功能抽取出来，于是就有了今天这个库。</p></blockquote><h2 id="1-实现思路"><a href="#1-实现思路" class="headerlink" title="1.实现思路"></a>1.实现思路</h2><p>其实，要实现这个功能也比较简单，第一步，我先是判断是否有读写外部存储的权限，因为下载 apk 一般来说是要下载到手机的 SD 卡上；如果有权限，那就调用蒲公英的更新检测接口，这个接口至少需要两个参数，apiKey 和 appKey，这两个值我们在蒲公英的 APP 信息中可以查到，我的想法是在清单文件中，让用户去设置这两个值，然后我动态取出来，这样就解决了这两个参数值传递的问题；接口请求成功后，会返回 buildVersionNo这个字段，然后通过这个返回字段与本地的 versionCode 去比对，如果比本地的大，说明就有新版本，然后弹出对话框，提示用户更新，当用户点击“更新”时，就去下载对应的版本即可，下载完成后调用安装程序，这样基本的更新思路就出来了。</p><h2 id="2-使用方式"><a href="#2-使用方式" class="headerlink" title="2.使用方式"></a>2.使用方式</h2><p>使用方式也比较简单，我已经将库发布到 jCenter 上了，大家查看项目的主页即可：</p><p><a href="https://github.com/xinpengfei520/pgyer-android-app-update" target="_blank" rel="noopener">https://github.com/xinpengfei520/pgyer-android-app-update</a></p><p>如果你觉得有帮助的话，请帮我点个 star，谢谢！另外，欢迎大家 fork 和 PR。</p><p>温馨提示：<br>点击查看原文可以看到项目的主页。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;我们知道，只要是个 APP 就都有更新的功能，可以说这个功能是比较重要的功能，我们在上架之前都会发布测试的版本，测试一般都是发布到蒲公英、Fir.im 等平台，可以说这个需求也算是比较普遍的一个功能了，之前我们的 APP 用的是蒲公英公测，然后现在
      
    
    </summary>
    
      <category term="Android" scheme="https://www.x-sir.com/categories/Android/"/>
    
    
      <category term="update-app" scheme="https://www.x-sir.com/tags/update-app/"/>
    
      <category term="pgyer" scheme="https://www.x-sir.com/tags/pgyer/"/>
    
  </entry>
  
  <entry>
    <title>BaseRecyclerViewAdapterHelper 让 RecyclerView 用起来更爽</title>
    <link href="https://www.x-sir.com/2018/12/27/BaseRecyclerViewAdapterHelper/"/>
    <id>https://www.x-sir.com/2018/12/27/BaseRecyclerViewAdapterHelper/</id>
    <published>2018-12-27T09:10:57.000Z</published>
    <updated>2018-12-27T09:13:01.859Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>BaseRecyclerViewAdapterHelper 是 GitHub 上的一个开源库，它可以让 RecyclerView 的使用更简单，方便和清晰，和原始的 adapter 相比，减少 70% 的代码量。确实，我最近的项目中也集成了这个库，并把之前的所有的 Adapter 都替换了为了库中的实现方式，代码量减少了，逻辑也更加清晰了，减少了一些无用功，提高了开发效率！强烈推荐大家使用。</p></blockquote><p>这个库也算封装的很好了，正常情况下，可以满足大部分的开发需求，其主要有一下几大优点：</p><ol><li>支持设置各种加载动画；</li><li>支持添加多个头和多个尾布局；</li><li>支持自动加载和预加载；</li><li>支持分组布局；</li><li>支持树形结构，也就是我们常说的折叠分组效果；</li><li>支持多种数据类型及多种布局的实现效果；</li><li>支持设置数据为空时的布局；</li><li>支持侧滑刷新和拖拽动作；</li><li>支持下拉刷新和加载更多；</li><li>支持自定义 ViewHolder；</li><li>更多请自行去发现…</li></ol><p>开源库地址：<a href="https://github.com/CymChad/BaseRecyclerViewAdapterHelper" target="_blank" rel="noopener">https://github.com/CymChad/BaseRecyclerViewAdapterHelper</a></p><p>开源库中文文档：<a href="https://www.jianshu.com/p/b343fcff51b0" target="_blank" rel="noopener">https://www.jianshu.com/p/b343fcff51b0</a></p><p>官方网站：<a href="http://www.recyclerview.org/" target="_blank" rel="noopener">http://www.recyclerview.org/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;BaseRecyclerViewAdapterHelper 是 GitHub 上的一个开源库，它可以让 RecyclerView 的使用更简单，方便和清晰，和原始的 adapter 相比，减少 70% 的代码量。确实，我最近的项目中也集成了这个库，
      
    
    </summary>
    
      <category term="Android" scheme="https://www.x-sir.com/categories/Android/"/>
    
    
      <category term="RecyclerView" scheme="https://www.x-sir.com/tags/RecyclerView/"/>
    
      <category term="Adapter" scheme="https://www.x-sir.com/tags/Adapter/"/>
    
  </entry>
  
  <entry>
    <title>绘制一个漂亮的弧形 View</title>
    <link href="https://www.x-sir.com/2018/11/06/%E7%BB%98%E5%88%B6%E4%B8%80%E4%B8%AA%E6%BC%82%E4%BA%AE%E7%9A%84%E5%BC%A7%E5%BD%A2%20View/"/>
    <id>https://www.x-sir.com/2018/11/06/绘制一个漂亮的弧形 View/</id>
    <published>2018-11-06T03:28:01.000Z</published>
    <updated>2018-12-08T15:02:48.596Z</updated>
    
    <content type="html"><![CDATA[<p>来，先看下效果图：</p><p><img src="http://pcobk8jbf.bkt.clouddn.com/FjVEV1HKnkl637u0Qs7im1YRfBjo" alt=""></p><p>怎么样？漂亮吧，上面是一个标题栏，下面是一个弧形的 View，标题栏和弧形 View 从左到右都有一个线性的渐变色，类似于手机 QQ 顶部的渐变效果，关于弧形的这种效果，使用的场景还是比较普遍的，小面我们就一起来看看如何绘制吧。</p><h2 id="1-先自定义一个-ArcView"><a href="#1-先自定义一个-ArcView" class="headerlink" title="1.先自定义一个 ArcView"></a>1.先自定义一个 ArcView</h2><p>创建一个类 ArcView 继承于 View，然后我们重写其三个构造方法，还有 onMeasure() 和 onDraw() 方法，这都是自定义 View 最基本的写法，比较简单这里就不详细说了， onMeasure() 用于测量 View 的宽高尺寸，onDraw() 就是具体的绘制过程了，具体的绘制思路是：我们在 onMeasure（）方法中拿到测量出来的宽和高，然后再 onDraw() 中初始化一个画笔，我们可以创建一个 LinearGradient 对象，然后调用设置画笔的 setShader() 方法就可以达到画笔渐变色的效果，然后再创建一个 Rect 对象，这里只是创建了一个矩形对象，要想绘制弧形，我们还需要设置绘制的路径，创建一个 Path 对象，分别调用 moveTo() 方法，和 quadTo() 方法，moveTo （）不会进行绘制，只用于移动移动画笔，一般和其他方法配合使用，这里和 quadTo() 方法配合使用，而 quadTo() 用于绘制圆滑的曲线，即贝塞尔曲线。mPath.quadTo(x1, y1, x2, y2) 其中x1、y1 为控制点，x2、y2 为结束点。有了路径之后我们就可以轻而易举地绘制出一个弧形了，完整的代码请看下面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by x-sir on 2018/8/10 :)</span><br><span class="line"> * Function:自定义弧形 View</span><br><span class="line"> */</span><br><span class="line">public class ArcView extends View &#123;</span><br><span class="line"></span><br><span class="line">    private int mWidth;</span><br><span class="line">    private int mHeight;</span><br><span class="line">    private int mArcHeight; // 弧形高度</span><br><span class="line">    private int mBgColor; // 背景颜色</span><br><span class="line">    private Paint mPaint;</span><br><span class="line"></span><br><span class="line">    public ArcView(Context context) &#123;</span><br><span class="line">        this(context, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ArcView(Context context, @Nullable AttributeSet attrs) &#123;</span><br><span class="line">        this(context, attrs, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ArcView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">        super(context, attrs, defStyleAttr);</span><br><span class="line">        TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.ArcView);</span><br><span class="line">        mArcHeight = typedArray.getDimensionPixelSize(R.styleable.ArcView_arcHeight, 0);</span><br><span class="line">        mBgColor = typedArray.getColor(R.styleable.ArcView_bgColor, Color.parseColor(&quot;#1E90FF&quot;));</span><br><span class="line">        typedArray.recycle();</span><br><span class="line">        mPaint = new Paint();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @SuppressLint(&quot;DrawAllocation&quot;)</span><br><span class="line">    @Override</span><br><span class="line">    protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">        super.onDraw(canvas);</span><br><span class="line">        // 参数一为渐变起初点坐标 x 位置，参数二为 y 轴位置，参数三和四分辨对应渐变终点，最后参数为平铺方式，这里设置为镜像</span><br><span class="line">        LinearGradient lg = new LinearGradient(0, 0, mWidth, 0,</span><br><span class="line">                Color.parseColor(&quot;#4796FB&quot;), Color.parseColor(&quot;#5AB4F9&quot;),</span><br><span class="line">                Shader.TileMode.CLAMP);</span><br><span class="line">        // 刚才已经讲到 Gradient 是基于 Shader 类，所以我们通过 Paint 的 setShader 方法来设置这个渐变</span><br><span class="line">        mPaint.setShader(lg);</span><br><span class="line">        mPaint.setStyle(Paint.Style.FILL);</span><br><span class="line">        //mPaint.setColor(mBgColor);</span><br><span class="line">        mPaint.setAntiAlias(true);</span><br><span class="line">        Rect rect = new Rect(0, 0, mWidth, mHeight - mArcHeight);</span><br><span class="line">        canvas.drawRect(rect, mPaint);</span><br><span class="line">        Path path = new Path();</span><br><span class="line">        path.moveTo(0, mHeight - mArcHeight);</span><br><span class="line">        path.quadTo(mWidth / 2, mHeight, mWidth, mHeight - mArcHeight);</span><br><span class="line">        canvas.drawPath(path, mPaint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">        super.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        int widthSize = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">        int widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">        int heightSize = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">        int heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line"></span><br><span class="line">        if (widthMode == MeasureSpec.EXACTLY) &#123;</span><br><span class="line">            mWidth = widthSize;</span><br><span class="line">        &#125;</span><br><span class="line">        if (heightMode == MeasureSpec.EXACTLY) &#123;</span><br><span class="line">            mHeight = heightSize;</span><br><span class="line">        &#125;</span><br><span class="line">        setMeasuredDimension(mWidth, mHeight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我这里只定义了弧形的高度和背景颜色这两个自定义属性，其中还有渐变颜色的开始色值和结束色值，还有是否需要渐变等属性，都可以定义为自定义的属性，方便直接在布局文件中灵活进行配置，以适应不同的需求，也比较简单，我这里为了就不实现了。</p><h2 id="2-自定义一个通用的-titlebar"><a href="#2-自定义一个通用的-titlebar" class="headerlink" title="2.自定义一个通用的 titlebar"></a>2.自定义一个通用的 titlebar</h2><p>这样做我们可以提高代码的复用性，可以将一些功能封装进去，也更好地体现了封装的思想，实现也比较简单，使用 LayoutInflater 加载了一个布局文件，然后将 文字，字体大小，字体颜色和 title 背景色等定义成了自定义的属性，方便在布局文件中进行设置，另外我们内部默认处理了点击返回按钮的事件，对于需要其他特殊情况下返回按钮的处理，我们也定义了一个接口，方便外部使用接口来自行进行处理，代码也非常简单，看下面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Created by x-sir on 2018/9/2 :)</span><br><span class="line"> * Function:自定义通用 TitleBar</span><br><span class="line"> */</span><br><span class="line">public class TitleBarLayout extends LinearLayout &#123;</span><br><span class="line"></span><br><span class="line">    private ImageView ivBack;</span><br><span class="line">    private ImageView ivMenu;</span><br><span class="line">    private TextView tvTitleName;</span><br><span class="line">    private LinearLayout llTitleBg;</span><br><span class="line">    private CharSequence mText;</span><br><span class="line">    private int mTitleBgColor;</span><br><span class="line">    private boolean mMenuVisible;</span><br><span class="line">    private int mTextSize;</span><br><span class="line">    private int mTextColor;</span><br><span class="line">    private OnMenuClickListener mListener;</span><br><span class="line">    private OnBackClickListener mOnBackListener;</span><br><span class="line">    private static final String DEFAULT_TEXT = &quot;Title&quot;; // default text.</span><br><span class="line">    private static final int DEFAULT_TEXT_SIZE = 16; // default text size.</span><br><span class="line">    private static final String TAG = &quot;TitleBarLayout&quot;;</span><br><span class="line"></span><br><span class="line">    public TitleBarLayout(Context context) &#123;</span><br><span class="line">        this(context, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public TitleBarLayout(Context context, @Nullable AttributeSet attrs) &#123;</span><br><span class="line">        this(context, attrs, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public TitleBarLayout(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">        super(context, attrs, defStyleAttr);</span><br><span class="line"></span><br><span class="line">        TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.TitleBarLayout);</span><br><span class="line">        mText = typedArray.getText(R.styleable.TitleBarLayout_text);</span><br><span class="line">        mTextSize = typedArray.getDimensionPixelSize(R.styleable.TitleBarLayout_textSize, DEFAULT_TEXT_SIZE);</span><br><span class="line">        mTextColor = typedArray.getColor(R.styleable.TitleBarLayout_textColor, Color.parseColor(&quot;#FFFFFF&quot;));</span><br><span class="line">        mTitleBgColor = typedArray.getColor(R.styleable.TitleBarLayout_titleBgColor, Color.parseColor(&quot;#1E90FF&quot;));</span><br><span class="line">        mMenuVisible = typedArray.getBoolean(R.styleable.TitleBarLayout_menuVisible, false);</span><br><span class="line">        typedArray.recycle();</span><br><span class="line"></span><br><span class="line">        initView(context);</span><br><span class="line">        initData();</span><br><span class="line">        initListener();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void initView(Context context) &#123;</span><br><span class="line">        LayoutInflater.from(context).inflate(R.layout.common_titlebar, this);</span><br><span class="line">        ivBack = findViewById(R.id.ivBack);</span><br><span class="line">        ivMenu = findViewById(R.id.ivMenu);</span><br><span class="line">        tvTitleName = findViewById(R.id.tvTitleName);</span><br><span class="line">        llTitleBg = findViewById(R.id.llTitleBg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void initData() &#123;</span><br><span class="line">        String text = (mText != null) ? mText.toString() : DEFAULT_TEXT;</span><br><span class="line">        tvTitleName.setText(text);</span><br><span class="line">        tvTitleName.setTextSize(TypedValue.COMPLEX_UNIT_PX, mTextSize);</span><br><span class="line">        tvTitleName.setTextColor(mTextColor);</span><br><span class="line">        //llTitleBg.setBackgroundColor(mTitleBgColor);</span><br><span class="line">        ivMenu.setVisibility(mMenuVisible ? VISIBLE : INVISIBLE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void initListener() &#123;</span><br><span class="line">        ivBack.setOnClickListener(v -&gt; &#123;</span><br><span class="line">            // 如果监听器不为空就让其自己处理，为空就默认处理（销毁页面）</span><br><span class="line">            if (mOnBackListener != null) &#123;</span><br><span class="line">                mOnBackListener.onClick();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ((Activity) getContext()).finish();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        ivMenu.setOnClickListener(v -&gt; &#123;</span><br><span class="line">            if (mListener != null) &#123;</span><br><span class="line">                mListener.onClick();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTitleName(String title) &#123;</span><br><span class="line">        if (!TextUtils.isEmpty(title)) &#123;</span><br><span class="line">            tvTitleName.setText(title);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            Log.e(TAG, &quot;set title name failed, because title is null!&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setOnMenuListener(OnMenuClickListener mListener) &#123;</span><br><span class="line">        this.mListener = mListener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setOnBackListener(OnBackClickListener mOnBackListener) &#123;</span><br><span class="line">        this.mOnBackListener = mOnBackListener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public interface OnMenuClickListener &#123;</span><br><span class="line">        void onClick();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public interface OnBackClickListener &#123;</span><br><span class="line">        void onClick();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为这里为了和绘制的弧形协调，我将 title 布局的背景设置了一个渐变的 shape 。</p><h2 id="3-将布局延伸到系统状态栏"><a href="#3-将布局延伸到系统状态栏" class="headerlink" title="3.将布局延伸到系统状态栏"></a>3.将布局延伸到系统状态栏</h2><p>Android 5.0 之后我们可以设置 Activity 的布局延伸到系统状态栏中，这样我们页面看起来更美观和协调，设置也比较简单，直接贴代码了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span><br><span class="line">        getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>另外在布局文件中也可以设置，只需在你 App 引用的主题中添加一行代码即可：</p><p><img src="http://pcobk8jbf.bkt.clouddn.com/FtLpSwRRbekR_PbI6n24DXvRqM8m" alt=""></p><p>注意：因为这个属性是 5.0 之后才有的，在实际开发中需要做兼容处理，代码中设置时需要判断一下版本，布局文件中可以新建一个 values-v21 文件夹做兼容处理。</p><p>如果你的 title 的文字跑到状态栏里了，那样会很丑，在 title 布局的根标签中添加下面一行代码就可以了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:fitsSystemWindows=&quot;true&quot;</span><br></pre></td></tr></table></figure><p>这行代码的意思就是不占用系统状态栏的空间。</p><p>好了，所有绘制工作都已经完成了，是不是非常简单呢？如果觉得不错的话，欢迎点赞、评论和转发，你们的支持是我坚持不懈的动力！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;来，先看下效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://pcobk8jbf.bkt.clouddn.com/FjVEV1HKnkl637u0Qs7im1YRfBjo&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;怎么样？漂亮吧，上面是一个标题栏，下面是一个弧形的 View，标
      
    
    </summary>
    
      <category term="Android" scheme="https://www.x-sir.com/categories/Android/"/>
    
    
      <category term="技术提升" scheme="https://www.x-sir.com/tags/%E6%8A%80%E6%9C%AF%E6%8F%90%E5%8D%87/"/>
    
      <category term="View" scheme="https://www.x-sir.com/tags/View/"/>
    
      <category term="ArcView" scheme="https://www.x-sir.com/tags/ArcView/"/>
    
  </entry>
  
</feed>
