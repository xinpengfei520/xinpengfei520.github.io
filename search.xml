<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Maven 项目集成 Swagger2]]></title>
    <url>%2F2019%2F07%2F13%2FMaven%20%E9%A1%B9%E7%9B%AE%E9%9B%86%E6%88%90%20Swagger2%2F</url>
    <content type="text"><![CDATA[题图：来自飞哥的图片工厂 音乐推荐：背叛文丨IT大飞说预计阅读时间：3.2 分钟 哈喽，朋友们，今天我们来学习下如何使用 Swagger2。 什么是 Swagger?Swagger 是一款 RESTFUL 接口的、基于YAML、JSON语言的文档在线自动生成、代码自动生成的工具。 如何集成？打开 pom.xml 文件，添加如下依赖： 12345678910&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt; 注：编写本文时使用的最新版本是 2.9.2，当你看到这篇文章的时候可能会有更新，最新的版本可到 https://mvnrepository.com 查看。 新建一个 Swagger2 类，完整代码如下： 1234567891011121314151617181920212223242526272829303132@Configuration@EnableSwagger2 // 启用 Swagger@EnableWebMvcpublic class Swagger2 &#123; @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() // 为当前包路径 .apis(RequestHandlerSelectors.basePackage(&quot;com.xpf.imoney&quot;)) .paths(PathSelectors.any()) .build(); &#125; /** * 构建 api 文档的详细信息函数，注意这里的注解引用的是哪个 */ private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() // 页面标题 .title(&quot;SSM Application [iMoney] Swagger2 RESTFul API&quot;) // 创建人 .contact(new Contact(&quot;x-sir&quot;, &quot;http://www.x-sir.com&quot;, &quot;542270559@qq.com&quot;)) // 版本号 .version(&quot;1.0&quot;) // 描述 .description(&quot;This is [iMoney] API doc&quot;) .build(); &#125;&#125; 然后编译并启动你本地的服务，打开浏览器，输入下面的访问地址： 1http://localhost:8080/JavaWeb/swagger-ui.html 注：上面链接中的 JavaWeb 为你的项目名称，替换为你自己的！ 正常情况下你就会看到下面的页面了： Swagger 的几个常用注解 @Api：表示这个类是 Swagger 的资源； @ApiOperation：用在方法上，说明方法的作用； @ApiParam：用来修饰参数，表示对参数添加元数据； @ApiModel：用于类，对类进行说明； @ApiIgnore：用于类，方法，表示这个类或方法被忽略； @ApiImplicitParam：用于方法，表示单独的请求参数； 举个例子，我们的 UserController 中的简单使用，完整代码如下： 1234567891011121314@Api(value = &quot;/user&quot;, description = &quot;关于用户的一些操做。&quot;)@Controllerpublic class UserController &#123; @Resource private UserService userService; @ResponseBody @RequestMapping(value = &quot;/index&quot;) @ApiOperation(value = &quot;通过 ID 查询 USER 信息&quot;, httpMethod = &quot;GET&quot;, notes = &quot;暂无&quot;) public User index(@RequestParam(&quot;id&quot;) int id) &#123; return userService.getUserById(id); &#125;&#125; 基本的用法就这些，好了，今天的分享就到这里了。 最后，我这边有个技术交流群，平常我会分享一些学习资源到群里，还可以和大家一起交流学习，需要的朋友可以扫描下面的二维码加我微信并备注「加群」，拉你进入技术交流群！ 飞哥带你去装逼，一直装逼到天黑！]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>Maven</tag>
        <tag>Swagger</tag>
        <tag>Swagger2</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava2.x 操作符之 compose]]></title>
    <url>%2F2019%2F06%2F20%2FRxJava2.x%20%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B9%8B%20compose%2F</url>
    <content type="text"><![CDATA[题图：来自飞哥的图片工厂 音乐推荐：后来文丨IT大飞说预计阅读时间：2.3 分钟 哈喽，朋友们，之前我们学习了一些 RxJava2.x 的常用操作符，今天我们来继续学习一下 RxJava 的 compose 操作符。 compose 操作符能够从数据流中得到原始的被观察者，当创建被观察者时，compose 操作符会立即执行，而不像其他的操作符需要在 onNext() 调用后才能执行。 使用场景一我们可以用 compose 操作符来进行线程的切换，一般用在网络请求的地方。 原始的写法为： 12.subscribeOn(Schedulers.io()).observeOn(AndroidSchedulers.mainThread()) 我们可以将上面的操作封装成一个简单的工具类来使用，我这里提供了 Java 版和 Kotlin 版本： Java 版本： 123456789101112131415161718192021222324252627282930313233343536import io.reactivex.FlowableTransformer;import io.reactivex.MaybeTransformer;import io.reactivex.ObservableTransformer;import io.reactivex.android.schedulers.AndroidSchedulers;import io.reactivex.schedulers.Schedulers;/** * Created by x-sir on 2019/4/19 :) * Function:线程调度 */public class RxThreadUtils &#123; /** * Flowable 切换到主线程 */ public static &lt;T&gt; FlowableTransformer&lt;T, T&gt; flowableToMain() &#123; return upstream -&gt; upstream.subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()); &#125; /** * Observable 切换到主线程 */ public static &lt;T&gt; ObservableTransformer&lt;T, T&gt; observableToMain() &#123; return upstream -&gt; upstream.subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()); &#125; /** * Maybe 切换到主线程 */ public static &lt;T&gt; MaybeTransformer&lt;T, T&gt; maybeToMain() &#123; return upstream -&gt; upstream.subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()); &#125;&#125; Kotlin 版本： 12345678910111213141516171819202122232425262728293031323334353637383940414243import io.reactivex.FlowableTransformerimport io.reactivex.MaybeTransformerimport io.reactivex.ObservableTransformerimport io.reactivex.android.schedulers.AndroidSchedulersimport io.reactivex.schedulers.Schedulersimport java.util.concurrent.TimeUnit/** * Created by x-sir on 2019-06-02 :) * Function:RxJava2.x 线程切换工具类 */object RxThreadUtils &#123; /** * Observable 切换到主线程 */ fun &lt;T&gt; observableToMain(): ObservableTransformer&lt;T, T&gt; &#123; return ObservableTransformer &#123; upstream -&gt; upstream.subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) &#125; &#125; /** * Flowable 切换到主线程 */ fun &lt;T&gt; flowableToMain(): FlowableTransformer&lt;T, T&gt; &#123; return FlowableTransformer &#123; upstream -&gt; upstream.subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) &#125; &#125; /** * Maybe 切换到主线程 */ fun &lt;T&gt; maybeToMain(): MaybeTransformer&lt;T, T&gt; &#123; return MaybeTransformer &#123; upstream -&gt; upstream.subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) &#125; &#125;&#125; 调用起来也比较简单，我们在网络请求的时候就可以这样调用（假设网络请求返回的是Flowable 对象）： 1.compose(RxThreadUtils.flowableToMain()) 使用场景二compose 操作符可以和 Transformer 结合使用，一方面可以让代码看起来更加简洁，另一方面能够提高代码的复用性，因为 RxJava 提倡链式调用，我们可以合理的使用 compose 操作符来防止链式调用被打破。 RxLifecycle 是 trello 开源的一个配置 RxJava 使用的开源库，我们知道 RxJava 有个缺点就是会导致内存泄露，此时，RxLifecycle 横空出世了，它可以配合 RxJava 一起使用，可以有效防止内存泄漏发生，使用起来也是非常方便，举个简单的例子： 123myObservable .compose(RxLifecycle.bind(lifecycle)) .subscribe(); RxLifecycle 不在文本的讲解范围内，更多详细使用可看 GitHub 介绍： https://github.com/trello/RxLifecycle 另外，知乎也开源了一个 RxLifecycle 库，使用起来也是比较方便的，感兴趣的可以看看： https://github.com/zhihu/RxLifecycle 好了，今天的分享就到这里了。 最后，我这边有个技术交流群，平常我会分享一些学习资源到群里，还可以和大家一起交流学习，需要的朋友可以扫描下面的二维码加我微信并备注「加群」，拉你进入技术交流群！ 飞哥带你去装逼，一直装逼到天黑！]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
        <tag>RxJava2.x</tag>
        <tag>操作符</tag>
        <tag>compose</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava2.x 常用操作符列表]]></title>
    <url>%2F2019%2F06%2F10%2FRxJava2.x%20%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[All：判断 Observable 发射的所有的数据项是否都满足某个条件； Amb：给定多个 Observable，只让第一个发射数据的 Observable 发射全部数据； And/Then/When：通过模式（And条件）和计划（Then次序）组合两个或多个 Observable 发射的数据集； Average：计算 Observable发射的数据序列的平均值，然后发射这个结果； Buffer：缓存，可以简单理解为缓存，它定期从 Observable 收集数据到一个集合，然后把这些数据集合打包发射，而不是一次发射一个； Catch：捕获，继续序列操作，将错误替换为正常的数据，从 onError 通知中恢复； CombineLatest：当两个 Observables 中的任何一个发射了一个数据时，通过一个指定的函数组合每个 Observable 发射的最新数据（一共两个数据），然后发射这个函数的结果； Concat：不交错地连接多个 Observable 的数据； Connect：指示一个可连接的 Observable 开始发射数据给订阅者； Contains：判断 Observable 是否会发射一个指定的数据项； Count：计算 Observable 发射的数据个数，然后发射这个结果； Create：通过调用观察者的方法从头创建一个 Observable； Debounce：只有在空闲了一段时间后才发射数据，简单来说，就是如果一段时间没有操作，就执行一次操作； DefaultIfEmpty：发射来自原始 Observable 的数据，如果原始 Observable 没有发射数据，就发射一个默认数据； Defer：在观察者订阅之前不创建这个 Observable，为每一个观察者创建一个新的 Observable； Delay：延迟一段时间发射结果数据； Distinct：去重，过滤掉重复数据项； Do：注册一个动作占用一些 Observable 的生命周期事件，相当于 Mock 某个操作； Materialize/Dematerialize：将发射的数据和通知都当作数据发射，或者反过来； ElementAt：取值，取特定位置的数据项； Empty/Never/Throw：创建行为受限的特殊 Observable； Filter：过滤，过滤掉没有通过谓词测试的数据项，只发射通过测试的 First：首项，只发射满足条件的第一条数据； flatMap：扁平映射，将 Observable 发射的数据转换为 Observables 集合，然后将这些 Observable 发射的数据平坦化地放进一个单独的 Observable，可以认为是一个将嵌套的数据结构展开的过程； From：将其他对象或数据结构转换为 Observable； GroupBy：分组，将原来的 Observable 拆分为 Observable 集合，将原始 Observable 发射的数据按 Key 分组，每一个 Observable 发射一组不同的数据； IgnoreElements：忽略所有的数据，只保留终止通知(onError 或 onCompleted)； Interval：创建一个定时发射整数序列的 Observable； Join：无论何时，如果一个 Observable 发射了一个数据项，只要在另一个 Observable 发射的数据项定义的时间窗口内，就将两个 Observable 发射的数据合并发射； Just：将对象或者对象集合转换为一个会发射这些对象的 Observable； Last：末项，只发射最后一条数据； Map：映射，对序列的每一项都应用一个函数变换 Observable 发射的数据，实质是对序列中的每一项执行一个函数，函数的参数就是这个数据项； Max：计算并发射数据序列的最大值； Merge：将两个 Observable 发射的数据组合并成一个； Min：计算并发射数据序列的最小值； ObserveOn：指定观察者观察 Observable 的调度程序（工作线程）； Publish：将一个普通的 Observable 转换为可连接的； Range：创建发射指定范围的整数序列的 Observable； Reduce：按顺序对数据序列的每一项数据应用某个函数，然后返回这个值； RefCount：使一个可连接的 Observable 表现得像一个普通的 Observable； Repeat：创建重复发射特定的数据或数据序列的 Observable； Replay：确保所有的观察者收到同样的数据序列，即使他们在 Observable 开始发射数据之后才订阅； Retry：重试，如果 Observable 发射了一个错误通知，重新订阅它，期待它正常终止辅助操作； Sample：取样，定期发射最新的数据，等同于数据抽样，有的实现中叫作 ThrottleFirst； Scan：扫描，对 Observable 发射的每一项数据应用一个函数，然后按顺序依次发射这些值； SequenceEqual：判断两个 Observable 是否按相同的数据序列； Serialize：强制 Observable 按次序发射数据并且功能是有效的； Skip：跳过前面的若干项数据； SkipLast：跳过后面的若干项数据； SkipUntil：丢弃原始 Observable 发射的数据，直到第二个 Observable 发射了一个数据，然后发射原始 Observable 的剩余数据； SkipWhile：丢弃原始Observable发射的数据，直到一个特定的条件为假，然后发射原始 Observable 剩余的数据； Start：创建发射一个函数返回值的 Observable； StartWith：在发射原来的 Observable 的数据序列之前，先发射一个指定的数据序列或数据项； Subscribe：收到 Observable 发射的数据和通知后执行的操作； SubscribeOn：指定 Observable 应该在哪个调度程序上执行； Sum：计算并发射数据序列的和； Switch：将一个发射 Observable 序列的 Observable 转换为这样一个 Observable，即它逐个发射那些 Observable 最近发射的数据； Take：只保留前面的若干项数据； TakeLast：只保留后面的若干项数据； TakeUntil：发射来自原始 Observable 的数据，直到第二个 Observable 发射了一个数据或一个通知； TakeWhile：发射原始 Observable 的数据，直到一个特定的条件为真，然后跳过剩余的数据； TimeInterval：将一个 Observable 转换为发射两个数据之间所耗费时间的 Observable； Timeout：添加超时机制，如果过了指定的一段时间没有发射数据，就发射一个错误通知； Timer：创建在一个指定的延迟之后发射单个数据的 Observable； Timestamp：给 Observable 发射的每个数据项添加一个时间戳； To：将 Observable 转换为其他对象或数据结构； Using：创建一个只在 Observable 生命周期内存在的一次性资源； Window：窗口，定期将来自 Observable 的数据拆分成一些 Observable 窗口，然后发射这些窗口，而不是每次发射一项；类似于 Buffer，但 Buffer 发射的是数据，Window 发射的是 Observable，每一个 Observable 发射原始 Observable 数据的一个子集； Zip：打包，使用一个指定的函数将多个 Observable 发射的数据组合在一起，然后将这个函数的结果作为单项数据发射；]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
        <tag>RxJava2.x</tag>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava2.x 并行编程]]></title>
    <url>%2F2019%2F06%2F04%2FRxJava2.x%20%E7%9A%84%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[题图：来自飞哥的图片工厂 音乐推荐：你的姑娘文丨IT大飞说预计阅读时间：1.2 分钟 哈喽，朋友们，之前我们学习了一些 RxJava2.x 的常用操作符，今天我们来继续学习一下RxJava 的并行编程。 随着手机 CPU 的高速发展，性能越来越强劲，核心数越来越多，我们要充分、高效地利用这些 CPU 资源，来提高程序运行的效率，解决复杂的业务问题，这将变得越来越重要。 1.什么是并行编程？对于并发我们可能比较清楚，那么并行是什么呢？它们的区别是什么？并发（concurrency）是指一个处理器同时处理多个任务，并行（parallelism）是多个处理器或者是多核处理器同时处理多个不同的任务，并行是同时发生的多个并发事件，具有并发的含义，而并发不一定是并行。 在 Java 8 中有个并行流（parallelStream），有的同学可能用过，我们想使用并行流的方式打印出 1-100 之间的整数，来看下面的代码： 1234567891011private void parallelismWithJava8() &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); for (int i = 1; i &lt;= 100; i++) &#123; list.add(i); &#125; list.parallelStream() .map(Object::toString) .forEach(s -&gt; LogUtil.i(TAG, &quot;s=&quot; + s + &quot;,Current Thread Name=&quot; + Thread.currentThread().getName())); &#125; 上面的结果会交错输出 1-100 之间的整数，因为并行的缘故所以每个输出执行的时间可能不一样，所以会交错输出，其实上面的代码是 Java 8 借助了 JDK 的 fork/join 框架来实现并行编程的。 2.使用 RxJava 的 flatMap 实现并行编程我们前面学习过 flatMap 操作符，我们知道 flatMap 可以将一些数据转换成一些 Observables，然后我们可以指定它的调度器来实现并行编程的目的，还是打印 1-100 的数字，直接看代码吧： 12345678private void parallelismWithRxJavaFlatMap() &#123; Observable.range(1, 100) .flatMap((Function&lt;Integer, ObservableSource&lt;String&gt;&gt;) integer -&gt; Observable.just(integer) .subscribeOn(Schedulers.computation()) .map(integer1 -&gt; integer1.toString())) .subscribe(s -&gt; LogUtil.i(TAG, &quot;s===&quot; + s));&#125; 这种方式使用的是默认的调度器，当然我们也可以创建一个线程池，来自定义调度器，修改后的代码如下： 12345678910111213private void parallelismWithRxJavaFlatMap() &#123; int threadNum = Runtime.getRuntime().availableProcessors() + 1; ExecutorService executorService = Executors.newFixedThreadPool(threadNum); final Scheduler scheduler = Schedulers.from(executorService); Observable.range(1, 100) .flatMap((Function&lt;Integer, ObservableSource&lt;String&gt;&gt;) integer -&gt; Observable.just(integer) .subscribeOn(scheduler) .map(integer1 -&gt; integer1.toString())) .doFinally(() -&gt; executorService.shutdown()) .subscribe(s -&gt; LogUtil.i(TAG, &quot;s===&quot; + s));&#125; 这 2 种实现方式都差不多，性能方面也差别不大，根据喜好请自行选择，注意一点，如果使用自己创建的线程池，那么记得使用 doFinally 操作符将线程池关闭，或者由下游的消费者进行处理！ 3.使用 ParallelFlowable 实现并行编程Flowable 是 RxJava2.x 新增的被观察者，支持背压，因此它对应的并行被观察者为 ParallelFlowable，因为并行编程肯定涉及到异步，而异步又涉及到背压，所以是没有 ParallelObservable 的。 我们还是用 ParallelFlowable 来实现打印 1-100 这个需求吧，请看代码： 123456789private void parallelFlowable() &#123; ParallelFlowable&lt;Integer&gt; parallelFlowable = Flowable.range(1, 100).parallel(); parallelFlowable .runOn(Schedulers.io()) .map(integer -&gt; integer.toString()) .sequential() .subscribe(s -&gt; LogUtil.i(TAG, &quot;s===&quot; + s));&#125; 其实代码是比较简单的，我们发现 runOn 和 sequential 操作符我们之前没见过，这里解释下，runOn 其实就是相当于我们上面使用 flatMap 实现中的 subscribeOn，我们可以用它来定义异步，它还有一个重载的方法，我们可以指定 prefetch 的数量。 sequential 操作符是将并行的操作结果返回到并行流中，这样，才能打印出所有的输出结果。 我们上面学会了好几种并行编程的方式，那么我们在实际的开发中应该选择哪种呢？ 并非所有的顺序操作在并行中都是有意义的，目前 ParallelFlowable 只支持如下操作：map、filter、flatMap、concatMap、reduce、collect、sorted、toSortedList、compose、fromArray、doOnCancel、doOnError、doOnComplete、doOnNext、doAfterNext、doOnSubscribe、doAfterTerminated、doOnRequest，优先推荐使用 ParallelFlowable 实现并行编程，对于无法使用 ParallelFlowable 的操作符，则使用 flatMap 来实现。 好了，今天的学习内容就算完成了，感觉是不是很简单？实践证明，学完后动手敲一遍的效果是最好的，赶紧去动手敲一遍吧！ 最后，我这边有个技术交流群，平常我会分享一些学习资源到群里，还可以和大家一起交流学习，需要的朋友可以扫描下面的二维码加我微信并备注「加群」，拉你进入技术交流群！ 飞哥带你去装逼，一直装逼到天黑！ 另外，我还建了一个免费的知识星球用于学习交流，感兴趣的可以使用微信扫码加入哦！]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
        <tag>RxJava2.x</tag>
        <tag>操作符</tag>
        <tag>并行编程</tag>
        <tag>parallelism</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android library 依赖 aar 包的两种方式]]></title>
    <url>%2F2019%2F05%2F30%2FAndroid%20library%20%E4%BE%9D%E8%B5%96%20aar%20%E5%8C%85%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[方式1将 aar 包放入 library module 的 libs 目录下，然后在工程的 build.gradle 文件中加入如下代码： 1flatDir &#123; dirs &apos;libs&apos;, &apos;../moduleName/libs&apos; &#125; 注：将 moduleName 替换为你自己的 library module 的 name. 然后在 module 的 build.gradle 文件中添加依赖： 1implementation(name: &apos;aar包名&apos;, ext: &apos;aar&apos;) 方式2这种方式的思路是，先把 aar 包放入一个单独的文件夹中，然后我们再依赖这个文件夹就可以了，这个文件夹你也可以理解成一个特殊的 module。 先在工程目录下新建一个文件夹（和app同级），然后将你的 aar 包放入 这个文件夹，然后再新建一个 build.gradle 文件，在这个文件中添加下面两句： 12configurations.maybeCreate(&quot;default&quot;)artifacts.add(&quot;default&quot;, file(&apos;aar包名.aar&apos;)) 然后在你需要依赖的 library module 的 build.gradle 文件中添加依赖： 1implementation project(&apos;:存放aar包的文件夹&apos;) 最后，同步下工程就 OK 了~]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>aar</tag>
        <tag>module</tag>
        <tag>依赖</tag>
        <tag>library</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava2.x 变换操作符之 flatMap 和 concatMap]]></title>
    <url>%2F2019%2F05%2F27%2FRxJava2.x%20%E5%8F%98%E6%8D%A2%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B9%8B%20flatMap%E5%92%8CconcatMap%2F</url>
    <content type="text"><![CDATA[题图：Pixabay License 哈喽，朋友们，上一篇文章我们学习了 filter 操作符，今天我们来学习 RxJava 中比较重要的两个操作符 flatMap 和 concatMap。 1.flatMap我们知道 flat 是平的意思，这个翻译还是有点生硬和抽象，我们还是不太理解，你就可以先理解成平铺的意思吧。 flatMap 是变换操作符的一种，它将一个发射数据的 Observable 变换为多个 Observable，然后将他们发射的数据合并后放入一个单独的 Observable。 举个简单的例子吧，假设上游有个数据源，数据源是学生对象的集合，学生有姓名和课程的属性，每个学生的课程可以有多个，需求是打印出所有学生的课程名称。 123456789101112131415161718192021222324252627282930313233Student student1 = new Student();List&lt;Student.Course&gt; list1 = new ArrayList&lt;&gt;();list1.add(new Student.Course(&quot;语文1&quot;));list1.add(new Student.Course(&quot;数学1&quot;));list1.add(new Student.Course(&quot;英语1&quot;));list1.add(new Student.Course(&quot;物理1&quot;));list1.add(new Student.Course(&quot;化学1&quot;));student1.setName(&quot;张三&quot;);student1.setCourses(list1);Student student2 = new Student();List&lt;Student.Course&gt; list2 = new ArrayList&lt;&gt;();list2.add(new Student.Course(&quot;语文2&quot;));list2.add(new Student.Course(&quot;数学2&quot;));list2.add(new Student.Course(&quot;英语2&quot;));student2.setName(&quot;李四&quot;);student2.setCourses(list2);List&lt;Student&gt; studentList = new ArrayList&lt;&gt;();studentList.add(student1);studentList.add(student2);Observable.just(studentList) .flatMap((Function&lt;List&lt;Student&gt;, ObservableSource&lt;Student&gt;&gt;) students -&gt; Observable.fromIterable(students)) .flatMap((Function&lt;Student, ObservableSource&lt;Student.Course&gt;&gt;) student -&gt; &#123; LogUtil.i(TAG, &quot;student name===&quot; + student.getName()); return Observable.fromIterable(student.getCourses()); &#125;) .subscribe(course -&gt; LogUtil.i(TAG, &quot;course===&quot; + course.getCourseName())); 执行结果如下： 12345678910I/RxJavaOperatorActivity: student name===张三I/RxJavaOperatorActivity: course===语文1I/RxJavaOperatorActivity: course===数学1I/RxJavaOperatorActivity: course===英语1I/RxJavaOperatorActivity: course===物理1I/RxJavaOperatorActivity: course===化学1I/RxJavaOperatorActivity: student name===李四I/RxJavaOperatorActivity: course===语文2I/RxJavaOperatorActivity: course===数学2I/RxJavaOperatorActivity: course===英语2 我们看到上面的代码没有 for 循环，却遍历打印了集合中的数据，RxJava 就是为了简化或者是取消 for 循环种方式，使用操作符来解决遍历循环的问题，从而是代码更加扁平化，使代码更加清晰和便于理解。 注意：flatMap 对这些 Observables 发射的数据做的是合并(merge)操作，因此它们可能是交错的，即不能保证数据的发射顺序。 2.concatMap我们将上面的 flatMap 操作符换成 concatMap 操作符再看看打印的结果，修改代码如下： 1234567Observable.just(studentList) .concatMap((Function&lt;List&lt;Student&gt;, ObservableSource&lt;Student&gt;&gt;) students -&gt; Observable.fromIterable(students)) .concatMap((Function&lt;Student, ObservableSource&lt;Student.Course&gt;&gt;) student -&gt; &#123; LogUtil.i(TAG, &quot;student name===&quot; + student.getName()); return Observable.fromIterable(student.getCourses()); &#125;) .subscribe(course -&gt; LogUtil.i(TAG, &quot;course===&quot; + course.getCourseName())); 执行结果如下： 12345678910I/RxJavaOperatorActivity: student name===张三I/RxJavaOperatorActivity: course===语文1I/RxJavaOperatorActivity: course===数学1I/RxJavaOperatorActivity: course===英语1I/RxJavaOperatorActivity: course===物理1I/RxJavaOperatorActivity: course===化学1I/RxJavaOperatorActivity: student name===李四I/RxJavaOperatorActivity: course===语文2I/RxJavaOperatorActivity: course===数学2I/RxJavaOperatorActivity: course===英语2 我们看到和 flatMap 的执行结果是一样的，我们发现打印的结果也是按照添加数据的顺序打印出来了，理论上 flatMap 执行的结果可能会有交错，原因是我们添加的数据过少，因此它们执行的时间也是差不多的，所以提现不出交错的情况。 好了，今天的学习内容就算完成了，感觉是不是非常简单？其实有时候你光看，理解起来是很慢的，但是你动手敲一遍立马就明白了，所以代码这个东西还是得多敲！ 最后，我这边建了一个技术交流群，需要的朋友可以扫描下面的二维码加我微信并备注「加群」，拉你进入技术交流群！ 飞哥带你去装逼，一直装逼到天黑！ 另外，我还建了一个免费的知识星球用于学习交流，感兴趣的可以使用微信扫码加入哦！]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
        <tag>RxJava2.x</tag>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava2.x 操作符之 filter]]></title>
    <url>%2F2019%2F05%2F23%2FRxJava2.x%20%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B9%8B%20filter%2F</url>
    <content type="text"><![CDATA[题图：Pixabay License 哈喽，朋友们，上一篇文章我们学习了 repeate 操作符，今天我们继续来学习 filter 操作符。 我们都知道 filter 是过滤的意思，也就是说这个操作符就是帮助我们来过滤掉一些我们不需要的数据。 举个简单的例子吧，假设上游有个数据源，顺序向下游发送 0-9 十个数字，我们只想打印大于 5 的数字，我们就可以这么写： 1234567891011121314Observable.interval(1, TimeUnit.SECONDS) .take(10) .filter(new Func1&lt;Long, Boolean&gt;() &#123; @Override public Boolean call(Long aLong) &#123; return aLong &gt; 5; &#125; &#125;) .subscribe(new Action1&lt;Long&gt;() &#123; @Override public void call(Long aLong) &#123; LogUtil.i(&quot;aLong===&quot; + aLong); &#125; &#125;); 执行结果如下： 1234I/RxJavaOperatorActivity: aLong===6I/RxJavaOperatorActivity: aLong===7I/RxJavaOperatorActivity: aLong===8I/RxJavaOperatorActivity: aLong===9 结果打印出来的都是大于 5 的数字，当然你还可以设置其他的过滤条件，例如空值等！ 好了，今天的学习内容就算完成了，感觉是不是非常简单？如果你学会了就赶紧动手去实践一下吧，说不定你会有新的发现哦！ 最后，我和大家分享一下我学习的一些经验或者是见解吧。我们再学习的过程中，可能学的很多东西都是点状的，我们要把学习到的东西学会融会贯通，将他们连接成线即学会相互联系，再将线形成面，再形成体，这样我们学到的知识才能形成一个完整的知识体系，不要只见树叶，不见森林，希望大家在学习的过程中，多思考，多总结！ Ps:扫描下面的二维码，关注「IT大飞说」，回复「加群」，拉你进入兄弟战斗群，最后告诉你们一个小秘密，公号对话框回复「装备01」 送你一件珍藏版的打怪装备，战斗力瞬间可增加 80！！！我使用过，效果杠杠滴！从此，我们就可以一起愉快的装逼了！ 飞哥带你去装逼，一直装逼到天黑！ 更多干货文章请关注我的微信公众号： 另外，我还建了一个免费的知识星球，感兴趣的微信扫码即可加入！]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
        <tag>RxJava2.x</tag>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava2.x 操作符之 repeat]]></title>
    <url>%2F2019%2F05%2F21%2FRxJava2.x%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B9%8Brepeat%2F</url>
    <content type="text"><![CDATA[题图：Pixabay License 哈喽，朋友们，上一篇文章我们学习了 from 操作符，今天我们继续来学习 repeat 操作符。 我们都知道 repeat 是重复的意思，也就是说这个操作符就是帮助我们来操作处理一些重复的数据或者操作，repeat 有三个相关的操作符：repeat、repeatWhen、repeatUntil，从字面也很好理解，repeat 就是简单的重复操作，repeatWhen 当达到什么条件的时候重复，repeatUntil 是直到某个条件不在重复。 1.repeat举个简单的例子吧，例如我们想重复打印一下 “Hello World!”，我们就可以这么写： 12345private void repeat() &#123; Observable.just(&quot;Hello World!&quot;) .repeat(3) .subscribe(s -&gt; LogUtil.i(TAG, s));&#125; 很简单吧，这个就不用我多说了吧。需要注意的是，如果不指定重复的次数，则会无限地重复下去！ 2.repeatWhen例如，我们想按顺序打印 0-3 的数字，当 2 秒后我们再重复打印一次，我们就可以这么写。 123Observable.range(0, 4) .repeatWhen(objectObservable -&gt; Observable.timer(2, TimeUnit.SECONDS)) .subscribe(integer -&gt; LogUtil.i(TAG, &quot;integer===&quot; + integer)); 上面的代码也比较简单，首先我们使用了一个新的操作符 range，也就是范围的意思，我们可以用它来指定一个数字的范围，并按顺序发射出去，repeatWhen 中使用了一个新的操作符 timer，我们用他创建了一个定时器的被观察者对象，并指定了两秒的时长，当到达 2 秒时就会重复原始的 Observable 并重新订阅和发射。 3.repeatUntil例如，我想间隔 1 秒顺序打印数字 0-2，当从开始打印到第 5 秒的时候就停止打印，代码如下： 1234Observable.interval(1000, TimeUnit.MILLISECONDS) .take(3) .repeatUntil(() -&gt; System.currentTimeMillis() - currentTimeMillis &gt; 5000) .subscribe(aLong -&gt; LogUtil.i(TAG, &quot;aLong===&quot; + aLong)); 这里我们使用了一个新的操作符 interval，它可以指定时间单位的时长发送数字序列，还有一个操作符是 take，它表示只取前 3 个，注意：从 0 开始，不包含它自己，接下来我们在 repeatUntil 里加了个判断，当大于 5 秒就停止重复打印。 执行结果如下： 123456I/RxJavaOperatorActivity: aLong===0I/RxJavaOperatorActivity: aLong===1I/RxJavaOperatorActivity: aLong===2I/RxJavaOperatorActivity: aLong===0I/RxJavaOperatorActivity: aLong===1I/RxJavaOperatorActivity: aLong===2 怎么样？是不是立马就明白了。 好了，今天的学习内容就算完成了，感觉是不是非常简单？如果你学会了就赶紧动手去实践一下吧，说不定你会有新的发现哦！ 最后，我和大家分享一下我学习的一些经验或者是见解吧。我们再学习的过程中，可能学的很多东西都是点状的，我们要把学习到的东西学会融会贯通，将他们连接成线即学会相互联系，再将线形成面，再形成体，这样我们学到的知识才能形成一个完整的知识体系，不要只见树叶，不见森林，希望大家在学习的过程中，多思考，多总结！ Ps:扫描下面的二维码，关注「IT大飞说」，回复「加群」，拉你进入兄弟战斗群，最后告诉你们一个小秘密，公号对话框回复「装备01」 送你一件珍藏版的打怪装备，战斗力瞬间可增加 80！！！我使用过，效果杠杠滴！从此，我们就可以一起愉快的装逼了！ 飞哥带你去装逼，一直装逼到天黑！ 更多干货文章请关注我的微信公众号： 另外，我还建了一个免费的知识星球，感兴趣的微信扫码即可加入！]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
        <tag>RxJava2.x</tag>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava2.x 创建操作符之 from]]></title>
    <url>%2F2019%2F05%2F19%2FRxJava2.x%E5%88%9B%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B9%8Bfrom%2F</url>
    <content type="text"><![CDATA[题图：Pixabay License 哈喽，朋友们，上一篇文章我们学习了 create &amp; just 操作符，今天我们继续来学习 from 操作符。 from 操作符和 just 操作符一样，也属于创建操作符的一种，from 可将其他种类的对象和数据类型转换为 Observable。 从概念看，just 和 from 是比较相似的，那么，他们两者有什么区别呢？ just 只是简单的原样发射，它会将数组或 Iterable 当做单个数据发射出去，而 from 会将数组或 Iterable 的数据按顺序取出来，然后逐个发射出去，举个例子你就明白了。 举例，我们初始化了一个 list，分别用 just 和 fromIterable 操作符进行处理，并打印了数据的结果。 12345678List&lt;Integer&gt; list = new ArrayList&lt;&gt;();for (int i = 0; i &lt; 6; i++) &#123; list.add(i);&#125;Observable.just(list).subscribe((Consumer&lt;List&gt;) list1 -&gt; LogUtil.i(TAG, &quot;just():&quot; + Arrays.toString(list1.toArray())));Observable.fromIterable(list).subscribe(integer -&gt; LogUtil.i(TAG, &quot;fromIterable():&quot; + integer)); 执行结果如下： 1234567I/RxJavaOperatorActivity: just():[0, 1, 2, 3, 4, 5]I/RxJavaOperatorActivity: fromIterable():0I/RxJavaOperatorActivity: fromIterable():1I/RxJavaOperatorActivity: fromIterable():2I/RxJavaOperatorActivity: fromIterable():3I/RxJavaOperatorActivity: fromIterable():4I/RxJavaOperatorActivity: fromIterable():5 从上面打印的日志我们可以看到，just 是将整个 list 数据传递下来了，而 fromIterable 是将 list 中的数据遍历并一个一个发射出去，数组也是一样的道理，数组使用 fromArray 操作符。 这里需要注意一个点，just 是可以接收 1-10 参数的，如果传入 1-5 的数字作为参数，那么它也会按顺序去打印的，而不是作为一个数组发射出去。 举个例子你就明白了： 1Observable.just(1, 2, 3, 4, 5).subscribe(integer -&gt; LogUtil.i(TAG, &quot;just():&quot; + integer)); 执行结果如下： 12345I/RxJavaOperatorActivity: just():1I/RxJavaOperatorActivity: just():2I/RxJavaOperatorActivity: just():3I/RxJavaOperatorActivity: just():4I/RxJavaOperatorActivity: just():5 怎么样？是不是瞬间就懂了。 另外，from 还有一个 fromFuture 操作符，Future 是什么东西？fromFuture 又是如何使用的呢？这个问题问的好，大飞这就给你细细道来。 Future 是 java.util.concurrent 包下的一个接口，我们都知道，创建线程的 2 种方式，一种是直接继承 Thread，另外一种就是实现 Runnable接口，但是这 2 种方式都有一个缺点就是在执行完任务之后无法获取执行的结果。 如果需要获取执行结果，就必须通过共享变量或者使用线程通信的方式来达到效果，这样使用起来就比较麻烦。而自从 JDK 1.5 开始，给我们提供了 Callable 和 Future 接口，通过这两个接口我们可以在任务执行完毕之后得到线程执行的结果。 一般来说，Callable 需要和 ExecutorService 配合来使用的，举个非常简单的例子吧。 1234567891011121314151617181920212223242526static class MyCallable implements Callable&lt;Integer&gt; &#123; @Override public Integer call() throws Exception &#123; LogUtil.i(TAG, &quot;call():在这里模拟一些耗时操作...&quot;); Thread.sleep(3000); int sum = 0; for (int i = 0; i &lt;= 100; i++) &#123; sum += i; &#125; return sum; &#125;&#125;private void calculate() &#123; ExecutorService executorService = Executors.newCachedThreadPool(); Future&lt;Integer&gt; future = executorService.submit(new MyCallable()); try &#123; LogUtil.i(TAG, &quot;任务运行的结果：&quot; + future.get()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125;&#125; 上面的代码也比较简单，我相信大家都能看得懂，我们的 MyCallable 类实现了 Callable 接口，在 call 方法中进行了一些耗时的操作，然后将结果返回出去，紧接着我们创建了一个线程池，创建了一个 MyCallable 的对象并将其提交到线程池中，最后将执行的结果打印出来。 执行结果如下： 122019-05-19 16:22:36.932 I/RxJavaOperatorActivity: call():在这里模拟一些耗时操作...2019-05-19 16:22:40.933 I/RxJavaOperatorActivity: 任务运行的结果：5050 我们再来看看如何配合 RxJava 来使用，这里使用到了 fromFuture 操作符，其实使用起来非常简单，简单修改一下上面的代码，相信你立刻就秒懂了！ 1Observable.fromFuture(future).subscribe(s -&gt; LogUtil.i(TAG, &quot;任务运行的结果：&quot; + s)); 这里我们就不调用 future 的 get 方法来获取执行的结果了，而是将 future 对象使用 fromFuture 操作符将其作为参数传递进去，当任务执行完成后，我们的观察者就会收到执行完后的结果，说白了就是 RxJava 内部帮你执行了 get 的方法并把结果回调给你了。 总结一下，对于 Future，它会发射 Future.get() 方法返回的单个数据。 细心的你可能已经发现了，fromFuture 还有一个重载方法： 1fromFuture(Future&lt;? extends T&gt; future, long timeout, TimeUnit unit)； 那第二个参数和第三个参数是什么意思呢？先别急，我们先看下 Future 接口的定义： 12345678public interface Future&lt;V&gt; &#123; boolean cancel(boolean mayInterruptIfRunning); boolean isCancelled(); boolean isDone(); V get() throws InterruptedException, ExecutionException; V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;&#125; 看到没有，我们发现原来 get 方法也有一个重载方法，也就是说 fromFuture 3 个参数的方法中后两个参数对应的就是 get 重载方法中的这两个参数。 那么问题来了，这两个参数有什么作用呢？这两参数的意思是，我们可以指定执行任务的时长和时间单位，如果过了指定的时长，Future 还没有返回一个结果，那么这个 Observable 就会发射异常通知并终止。 我们可以测试一下是不是这样的。我们现在指定一个执行任务的时长，我在执行任务的方法中睡了 3 秒，那么这里我就给它设置成 2 秒，这样设置，任务肯定是没有执行完成的，我们看看这个时候会不会和我们猜测的一样会抛异常。 123Observable.fromFuture(future, 2, TimeUnit.SECONDS).subscribe(s -&gt; Observable.fromFuture(future, 2, TimeUnit.SECONDS) .subscribe(s -&gt; LogUtil.i(TAG, &quot;任务运行的结果：&quot; + s) , throwable -&gt; LogUtil.e(TAG, &quot;onError:&quot; + throwable.getMessage())); 执行结果如下： 12I/RxJavaOperatorActivity: call():在这里模拟一些耗时操作...E/RxJavaOperatorActivity: onError:null 看到没有，果不其然报错了，这样我们就可以在超时的时候做一些处理了。 好了，我们今天的学习目标就算达成了，感觉是不是很简单，很轻松？我们来回顾下今天所学的东西，首先我们学习了 fromIterable 操作符，它与 just 操作符有相似之处，因此我将其与 just 操作符举例说明了他们的区别。 紧接着我们回顾了 Java 中创建线程的相关知识，并学会了将其配合 fromFuture 操作符一起使用，真的是非常方便的。 如果你学会了就赶紧动手去实践一下吧，有数据表明，学习后实践的吸收效果比不实践的效果高几十倍！ 今天的内容确实比较轻松和简单，后面我将继续带领大家一起学习新的内容，大家敬请期待吧！ 最后，我和大家分享一下我学习的一些经验或者是见解吧。我们再学习的过程中，可能学的很多东西都是点状的，我们要把学习到的东西学会融会贯通，将他们连接成线即学会相互联系，再将线形成面，再形成体，这样我们学到的知识才能形成一个完整的知识体系，不要只见树叶，不见森林，希望大家在学习的过程中，多思考，多总结！ Ps:扫描下面的二维码，关注「IT大飞说」，回复「加群」，拉你进入兄弟战斗群，最后告诉你们一个小秘密，公号对话框回复「装备01」 送你一件珍藏版的打怪装备，战斗力瞬间可增加 80！！！我使用过，效果杠杠滴！从此，我们就可以一起愉快的装逼了！ 飞哥带你去装逼，一直装逼到天黑！ 更多干货文章请关注我的微信公众号： 另外，我还建了一个免费的知识星球，感兴趣的微信扫码即可加入！]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
        <tag>RxJava2.x</tag>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava2.x创建操作符之create和just (打怪升级版)！！！]]></title>
    <url>%2F2019%2F05%2F18%2FRxJava2.x%E5%88%9B%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%AC%A6%E4%B9%8Bcreate%E5%92%8Cjust%20(%E6%89%93%E6%80%AA%E5%8D%87%E7%BA%A7%E7%89%88)%EF%BC%81%EF%BC%81%EF%BC%81%2F</url>
    <content type="text"><![CDATA[题图：来自网络 哈喽，朋友们，好久不见了，有段时间没推文了。从今天开始，我将计划更新 RxJava2.x 系列的文章，RxJava 是什么东西，我想也不用给大家介绍了吧。 其实，网上关于 RxJava 的相关文章一大堆，我之前也看过不少，对于新手来说，那些文章，要么就是比较长，不容易看下去，要么就是讲的全是理论，晦涩难懂，缺少实践性。 因此，我打算从今天开始，更新一系列的 RxJava2.x 教程，主要从常用的操作符讲起，目的很简单，带大家每天学会一个操作符的使用。 操作符是 RxJava 的重要组成部分，因此学习操作符也是非常重要的，RxJava 的操作符虽然说比较多，但是我们可以将其进行分类，然后逐一进行理解学习，其实也是比较容易和轻松的，RxJava 的操作符大致可以分为以下几类： 今天，我们先来学习两个简单的创建操作符 create &amp; just。 在学习之前，我们先来回顾下观察者模式，大多数同学应该都不陌生吧，例如 Android 的EventBus 等框架都使用了观察者模式，简单说这就是一种发布、订阅的模式，你可以简单理解为订阅报纸。 这与 RxJava 又有什么关系呢？我们先来看下 Rx 的概念：Rx 是一个使用可观察数据流进行异步编程的编程接口，也就是说 RxJava 中使用了观察者模式的这种编程思想，另外还结合了迭代器模式和函数式编程，并把它运用发挥到了极致。 我们都知道观察者模式中，有 3 个重要的概念，被观察者，观察者和订阅，类比到现实中订阅报纸的场景中就是，报纸是被观察者，阅读报纸的人是观察者，人订阅了报纸也就是说使用订阅将他们两者关联起来，这样就形成了一种发布、订阅的关系。 举个例子吧，我们来看看 Android 中点击事件的处理，注意：观察者模式与点击回调模式有很多的相似处，简单对比就是：回调是一对一的关系，只监听一个事件；观察者模式则是一个主题，可以有多个监听者，当主题变化时，向部分或所有监听者发出变化的通知，观察者模式是一对多的关系。 上面的代码很简单吧，我相信大家都能看得懂，一般我们习惯上将监听器写成匿名的，这里我是为了给大家做类比，所以分开写了，然后我们再结合观察者模式看看上面的代码，第一步实例化一个 Button 就相当于是创建了一个被观察者，第二步初始化一个监听器就相当于是创建了一个观察者，第三步将监听器和 Button 绑定就相当于是把被观察者和观察者通过订阅将他们两者关联起来，是不是理解起来非常简单。 我们再来看看 RxJava 如何来实现，我们就先从最简单的 Hello World 学习起来吧，同样的还是三步走！ 第一步，创建被观察者（Observable）第二步，创建观察者（Observer）第三步，将被观察者和观察者绑定（subscribe） 和上面的点击事件对比一下，是不是感觉有异曲同工之妙？但是我们习惯上一般不分开写，而是将方法的调用写成链式调用，将对对象写成匿名的对象，我们将上面的代码变换下，如下所示： 我们看到，在上面的创建被观察者的 subscribe 方法中，调用了 onNext 方法，将 “Hello World” 字符串传递下去，而在下面调用 subscribe 的时候，传递了一个 Consumer 对象（观察者），而这个 Consumer 的回调方法就会收到 onNext 的传递过来的值，接着，我们在下面打印了一下 onNext 传递过来的字符串。 实际上，subscribe（订阅）是一个重载方法，它可以接收 0-4 个参数，当传递一个参数时，就代表接收处理成功时的回调（onNext），如传递多个参数则代表接收处理错误、完成、当订阅完成时的事件处理，我们这里为了演示，就只处理成功事件就行了。 上面的代码看着还是不太完美，我们这里使用 just 操作符将它改造一下，just 是什么鬼？看着怎么一脸懵逼，好吧，那就让大飞哥来给你讲解下 just 操作符。 just 操作符和 create 操作符一样，也是创建操作符的一种，just 操作符是将一个或多个对象转换成发射这个或这些对象的一个 Observable，看完概念还是一脸懵逼怎么办？确实，这些概念是比较抽象的，其实，用起来特别简单，当你会用了之后，你再回过头去理解起来会容易很多。 来继续将我们的 Hello World 用 just 操作符改造一下： 怎么样，是不是更简单了，我们点开 just 方法，我们看到它接收的是一个 T，也就是说它可以接收任意类型的参数，我们以后就可以使用 just 操作符来很方便的创建各种被观察者对象了，非常棒！我们又学会了一个操作符，欧耶！ 上面的代码看着还是有点长，我们可以用 Lambda 表达式改造一下看看： 哇哦！It’s beautiful! 一行代码就搞定了，有木有？ 至此，我们今天的学习目标就算达成了，感觉是不是很简单，很轻松？ 如果你学会了就赶紧动手去实践一下吧，实践是检验真理的唯一标准，眼过千遍不如手过一遍，代码是用来敲的不是用来看的，希望我们程序员都是实干家！ 今天的内容确实比较轻松和简单，后面还有更大的挑战呢，从今天开始，大飞哥将带你一起打怪升级练本领，一起去闯关，去战斗！大家敬请期待吧！ 最后，引用大飞哥的一句名言作为结尾吧：“是兄弟，就一起去战斗吧！” Ps:扫描下面的二维码，关注「IT大飞说」，回复「加群」，拉你进入兄弟战斗群，最后告诉你们一个小秘密，公号对话框回复「装备01」 送你一件珍藏版的打怪装备，战斗力瞬间可增加 80！！！我使用过，效果杠杠滴！从此，我们就可以一起愉快的装逼了！ 飞哥带你去装逼，一直装逼到天黑！ 更多干货文章请关注我的微信公众号： 另外，我还建了一个免费的知识星球，感兴趣的微信扫码即可加入！]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RxJava</tag>
        <tag>RxJava2.x</tag>
        <tag>操作符</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你不知道的 Gradle 高级技巧（一）]]></title>
    <url>%2F2019%2F01%2F30%2F%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%20Gradle%20%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[作为一名Android 开发者，我们都有发布 APP 内测版本的经历，有的公司是发布到自己的服务器上，生成一个连接或者二维码扫描就可以下载，有的公司使用一些内测平台如蒲公英、fir.im 等，有这么好的内测平台为什么不用呢？一方面这些平台的基本都是免费提供服务的，另外一方面也提供了许多丰富的 api，方便开发者使用，提升效率！ 1.前段时间研究 Android 端的自动打包，采用的是 Jenkins + Git 的方式，这样，当你 push 完代码之后，Jenkins 会自动拉取你的代码，然后再用 Gradle 工具进行自动化打包，Jenkins 可以配置许多插件，当打包完之后可以自动上传到蒲公英和 fir.im 等平台，特别方便，基本就是这么个流程，我们之前公司是运维帮我们在服务器端搭建的自动打包程序，这样的好处是当你需要打几十个包时，特别快，因为服务器的配置一般比电脑都高，并且不用占用自己电脑的资源。我自己前段时间也在自己的电脑上装了一个 Jenkins，然后一些配置，也可以进行自动化打包，但是我觉得没必要，因为你把代码 push 上去，然后再拉下来，然后再打包，用的还是你本地电脑的资源，还不如直接用 AS 打包来的快，我看了下 Jenkins 上传到公测平台的实现，其实就是用了一个 curl 命令来实现的，我就想着能不能在 Gradle 中配置上传的脚本？答案当然是可以的！ 2.首先，我们了解下什么是 curl？ 下面的概念来自某度的解释： 1curl 命令是一个利用 URL 规则在命令行下工作的文件传输工具。它支持文件的上传和下载，所以是综合传输工具，但按传统，习惯称 curl 为下载工具。作为一款强力工具，curl 支持包括 HTTP、HTTPS、ftp 等众多协议，还支持 POST、cookies、认证、从指定偏移处下载部分文件、用户代理字符串、限速、文件大小、进度条等特征。 简单说他就是一个命令，Linux 和 Mac 系统自带，Windows 需要安装 curl 才能使用，在哪里下载 curl?为了方便大家我已经帮大家下载好了，复制下面的字符发送到后台即可： curl 里面包含 32 位 &amp; 64 位的安装程序，还有安装教程的链接供大家参考，安装完成后需要配置环境变量，然后在 cmd 中输入 1curl --version 如果显示 curl 的版本号说明安装成功了~ 3.有了 curl 命令，我们就可以执行 curl 命令来进行上传文件了，我们先看下蒲公英上传 apk 的接口文档，如下图： 其中，_api_key、uKey 和 file 字段是必须的，其他参数都是可选项，_api_key 和 uKey 蒲公英都会为每个 APP 自动分配一个，在你的蒲公英账号对应的 APP 的信息中可以找到，file 参数就是要上传的文件了，为了让我们上传的 APP 有每次更新的描述，我们还需要添加一个 buildUpdateDescription 字段，这样，每次上传 APP 之后就可以显示本次更新的描述信息了。 文档看完之后，我们需要使用 curl 命令来发送一个上传文件的 POST 请求，url 的语法如下： 1curl(选项)(参数) curl 命令的选项有很多，上图只是截取了其中的一部分，根据蒲公英上传 APP 的接口文档，提交的是 multipart/form-data 类型的数据，因此我们使用 -F 选项，我们可以写出伪命令了： 1curl -F 参数1 -F 参数2 -F 参数3 接口地址 因为我们上传 APP 需要 3 个参数，所以这里也需要三个参数，后面再加上我们请求的接口地址就可以了，这应该很好理解吧？ 我们再把参数部分替换成真实的的参数，完整的命令如下： 1curl -F &quot;file=app/build/outputs/apk/release/release-v1.0.apk&quot; -F &quot;uKey=ce0e825125bfe666762b2a93feb7de00&quot; -F &quot;_api_key=534a49154990d8e9126918fbdbee600a&quot; -F &quot;buildUpdateDescription=bugs fix!&quot; https://www.pgyer.com/apiv2/app/upload 好了，一条完整的 curl 上传命令算是完成了，其中，-F 后面的参数是字段名和参数的值，中间用 “=” 号进行连接，然后我们打开 AS 的 Terminal，执行上面的命令即可进行上传 apk 到蒲公英，上传过程也有进度显示，如果显示 100%，说明上传成功了，注意上面的 uKey 和 _api_key 的值换成你自己的，另外也要注意你打完包的 apk 文件路径要真实存在，否则会出现异常！ 4.上面我们已经学会了使用 curl 命令上传我们的 apk 了，但是你们有没有发现，我们每次上传 apk 需要好几步： 打包 apk； 修改上传命令中 apk 的文件名和描述信息； 复制 curl 命令到 Terminal 中执行； … 至少需要 3 步才能完成，这也是一件非常麻烦的事情，作为程序员，都是比较懒的，与其说懒不如说是机智，避免做浪费时间的事情，我再想，能不能一条命令一步到位呢？当然是可以的。 我们先进行改造上传命令的第一步，先把 curl 命令中 file 的值，也就是 apk 路径动态进行获取，这样就不用每次都去修改了，我们知道 gradle 语法中的字符串有两种，一种是单引号，另一种是双引号，区别就是，双引号支持插值，这样我们就可以写一个方法，这个方法的作用就是获取打包好的 apk 的全路径，代码如下： 1234567891011def getApkFullPath() &#123; return rootDir.getAbsolutePath() + &quot;/app/build/outputs/apk/release/&quot; + getApkName()&#125;def getApkName() &#123; return &quot;update-app-example-v$&#123;android.defaultConfig.versionName&#125;-$&#123;releaseTime()&#125;.apk&quot;&#125;static def releaseTime() &#123; return new Date().format(&quot;yyyy-MM-dd&quot;, TimeZone.getTimeZone(&quot;UTC&quot;))&#125; 上面总共有 3 个方法，也比较简单，大家应该都能看得懂，就不过多解释了，其中第一个方法中的 rootDir.getAbsolutePath() 说一下，它可以获取你当前项目在你本地电脑的全路径。 方法写好了，我们还需要把打包脚本稍微修改下，具体如下： 12345678910release &#123; minifyEnabled false proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos; signingConfig signingConfigs.release android.applicationVariants.all &#123; variant -&gt; variant.outputs.all &#123; outputFileName = getApkName() &#125; &#125; &#125; 注意看上面的 outputFileName = getApkName()，这样写每次生成的 apk 的名字就是我们要获取的 apk 的文件名，这样每次打包完后我们都能获取到打包完后的 apk 的文件名了！这样，我们 curl 上传命令中动态获取 apk 文件路径这个问题就算解决了，我们再看下我们的 curl 命令中还有 uKey 和 _api_key 两个参数，因为这两个值属于比较私密的东西我们一般都是配置到 local.properties 文件中，然后动态读取的，git 默认是忽略提交 local.properties 文件的，这样防止自己的私密信息被提交和泄露出去，因此，这里也写个方法动态读取一下吧： 123456789101112def readProperties(key) &#123; File file = rootProject.file(&apos;local.properties&apos;) if (file.exists()) &#123; InputStream inputStream = rootProject.file(&apos;local.properties&apos;).newDataInputStream() Properties properties = new Properties() properties.load(inputStream) if (properties.containsKey(key)) &#123; return properties.getProperty(key) &#125; &#125;&#125; 这个方法也比较简单，相信大家都能看的明白！ 现在我们的上传命令中还有一个字段 buildUpdateDescription，更新描述信息，每次上传 apk 都需要修改一下更新的描述，直接在命令中修改，也不太好，因此我们也写个方法动态获取吧，如下所示： 123static def getUpdateDescription() &#123; return &apos;1.修复一些bug；\n2.提升用户体验！&apos;&#125; 上面的代码，非常简单，一目了然，只要是程序员都能看得懂，如果你看不懂，说明你是伪程序员！ 好了，终于完成了，我们最终上传的命令被改造成了这样： 1curl -F &quot;file=@$&#123;getApkFullPath()&#125;&quot; -F &quot;uKey=$&#123;readProperties(&apos;pgyer.userKey&apos;)&#125;&quot; -F &quot;_api_key=$&#123;readProperties(&apos;pgyer.apiKey&apos;)&#125;&quot; -F &quot;buildUpdateDescription=$&#123;getUpdateDescription()&#125;&quot; https://www.pgyer.com/apiv2/app/upload 5.上面的命令算是改造完成了，不知道你们有没有发现，有个致命的问题就是，这条命令怎么执行啊？因为我么你的命令中动态调用了 Gradle 中我们写的方法，直接在 Terminal 中执行肯定是会报错的！这可就尴尬了。。我们想了想，要想让我们上传命令中的方法能够被成功调用，这个命令和被调用的方法肯定是在同一个 Gradle 文件中的，我们再想能不能写一个 Task，这这个 Task 中执行我们的上传命令，这样不就解决问题了吗？嗯，想了想是可以的，我发现在写的过程中 Task 好写，但是我们这个命令怎么才能够执行呢？肯定也需要一个东西才能执行我们的命令，搜了下，Gradle 中有个 exec 东西，它可以执行一条具体的 bash 命令，嗯，灰常不错，可以的，very good!真香！最终我们写的完整的 Task 如下： 1234567891011121314task(&quot;uploadApk&quot;) &#123; def command = &quot;curl -F \&quot;file=@$&#123;getApkFullPath()&#125;\&quot; -F \&quot;uKey=$&#123;readProperties(&apos;pgyer.userKey&apos;)&#125;\&quot; -F \&quot;_api_key=$&#123;readProperties(&apos;pgyer.apiKey&apos;)&#125;\&quot; -F \&quot;buildUpdateDescription=$&#123;getUpdateDescription()&#125;\&quot; https://www.pgyer.com/apiv2/app/upload&quot; println &quot;command:&quot; + command try &#123; exec &#123; ExecSpec execSpec -&gt; executable &apos;bash&apos; args &apos;-c&apos;, command &#125; println &quot;uploadApk success~&quot; &#125; catch (Exception e) &#123; e.printStackTrace() &#125;&#125; 上面的代码相对也比较简单，其中 ExecSpec 大家可能看着比较陌生，executable ‘bash’ 为固定写法，其中 bash 代表 shell 的类型，Linux 下有很多种 shell 的类型，流行的 shell 有 ash、bash、ksh、csh、zsh 等，一般我们常用的都是 bash，其中的 command 就是一条具体的命令了。 这样，我们只要执行这个 Task 就可以自动执行上传命令并动态获取我们所需要的参数了~ 6.上面的命令执行起来是非常方便的，但是在实际使用中，我们发现，需要先打完包之后才能执行上传的 Task，我们知道 Gradle 中的 Task 是可以依赖另一个 Task 的，打包命令实质上也是一个 Task，这样我们让我们自己写的 Task 依赖于打包的 Task 不就行了吗？我觉得没毛病，这样，当执行完打包后，自动执行上传命令，这样一条命令就可以解决问题，另外，我们自己的 Task 也需要稍微修改下，将上传的实现部分放到 doLast 闭包中，完成代码入下： 123456789101112131415161718task(&quot;uploadApk&quot;) &#123; doLast &#123; def command = &quot;curl -F \&quot;file=@$&#123;getApkFullPath()&#125;\&quot; -F \&quot;uKey=$&#123;readProperties(&apos;pgyer.userKey&apos;)&#125;\&quot; -F \&quot;_api_key=$&#123;readProperties(&apos;pgyer.apiKey&apos;)&#125;\&quot; -F \&quot;buildUpdateDescription=$&#123;getUpdateDescription()&#125;\&quot; https://www.pgyer.com/apiv2/app/upload&quot; println &quot;command:&quot; + command try &#123; exec &#123; ExecSpec execSpec -&gt; executable &apos;bash&apos; args &apos;-c&apos;, command &#125; println &quot;uploadApk success~&quot; &#125; catch (Exception e) &#123; e.printStackTrace() &#125; &#125;&#125;uploadApk.dependsOn(&quot;assembleRelease&quot;) 从此，我们只要在 Terminal 中执行一条命令就可以实现打包上传了： 1./gradlew uploadApk 温馨提示：Windows 用户执行命令不需要加 ./ 怎么样？是不是很爽！这个效率上的提升不是一点半点，后续我再想能不能把这个功能封装成一个 Gradle 插件的形式，提供给大家使用，这样也许是要添加一两行代码引用一下插件的就可以使用了，这样就更加方便了，敬请期待吧~ 如果我的文章对你有用，欢迎留言！]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>pgyer</tag>
        <tag>Gradle</tag>
        <tag>upload</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一行代码实现蒲公英市场APP检查更新]]></title>
    <url>%2F2019%2F01%2F08%2F%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E8%92%B2%E5%85%AC%E8%8B%B1%E5%B8%82%E5%9C%BAAPP%E6%A3%80%E6%9F%A5%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[我们知道，只要是个 APP 就都有更新的功能，可以说这个功能是比较重要的功能，我们在上架之前都会发布测试的版本，测试一般都是发布到蒲公英、Fir.im 等平台，可以说这个需求也算是比较普遍的一个功能了，之前我们的 APP 用的是蒲公英公测，然后现在又有一个新的 APP 需要，这就需要把之前的更新功能重写一遍，其实这是比较麻烦的，也没有必要，我想着能不能把这个功能抽取出来，于是就有了今天这个库。 1.实现思路其实，要实现这个功能也比较简单，第一步，我先是判断是否有读写外部存储的权限，因为下载 apk 一般来说是要下载到手机的 SD 卡上；如果有权限，那就调用蒲公英的更新检测接口，这个接口至少需要两个参数，apiKey 和 appKey，这两个值我们在蒲公英的 APP 信息中可以查到，我的想法是在清单文件中，让用户去设置这两个值，然后我动态取出来，这样就解决了这两个参数值传递的问题；接口请求成功后，会返回 buildVersionNo这个字段，然后通过这个返回字段与本地的 versionCode 去比对，如果比本地的大，说明就有新版本，然后弹出对话框，提示用户更新，当用户点击“更新”时，就去下载对应的版本即可，下载完成后调用安装程序，这样基本的更新思路就出来了。 2.使用方式使用方式也比较简单，我已经将库发布到 jCenter 上了，大家查看项目的主页即可： https://github.com/xinpengfei520/pgyer-android-app-update 如果你觉得有帮助的话，请帮我点个 star，谢谢！另外，欢迎大家 fork 和 PR。 温馨提示：点击查看原文可以看到项目的主页。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>update-app</tag>
        <tag>pgyer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BaseRecyclerViewAdapterHelper 让 RecyclerView 用起来更爽]]></title>
    <url>%2F2018%2F12%2F27%2FBaseRecyclerViewAdapterHelper%2F</url>
    <content type="text"><![CDATA[BaseRecyclerViewAdapterHelper 是 GitHub 上的一个开源库，它可以让 RecyclerView 的使用更简单，方便和清晰，和原始的 adapter 相比，减少 70% 的代码量。确实，我最近的项目中也集成了这个库，并把之前的所有的 Adapter 都替换了为了库中的实现方式，代码量减少了，逻辑也更加清晰了，减少了一些无用功，提高了开发效率！强烈推荐大家使用。 这个库也算封装的很好了，正常情况下，可以满足大部分的开发需求，其主要有一下几大优点： 支持设置各种加载动画； 支持添加多个头和多个尾布局； 支持自动加载和预加载； 支持分组布局； 支持树形结构，也就是我们常说的折叠分组效果； 支持多种数据类型及多种布局的实现效果； 支持设置数据为空时的布局； 支持侧滑刷新和拖拽动作； 支持下拉刷新和加载更多； 支持自定义 ViewHolder； 更多请自行去发现… 开源库地址：https://github.com/CymChad/BaseRecyclerViewAdapterHelper 开源库中文文档：https://www.jianshu.com/p/b343fcff51b0 官方网站：http://www.recyclerview.org/]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RecyclerView</tag>
        <tag>Adapter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[绘制一个漂亮的弧形 View]]></title>
    <url>%2F2018%2F11%2F06%2F%E7%BB%98%E5%88%B6%E4%B8%80%E4%B8%AA%E6%BC%82%E4%BA%AE%E7%9A%84%E5%BC%A7%E5%BD%A2%20View%2F</url>
    <content type="text"><![CDATA[来，先看下效果图： 怎么样？漂亮吧，上面是一个标题栏，下面是一个弧形的 View，标题栏和弧形 View 从左到右都有一个线性的渐变色，类似于手机 QQ 顶部的渐变效果，关于弧形的这种效果，使用的场景还是比较普遍的，小面我们就一起来看看如何绘制吧。 1.先自定义一个 ArcView创建一个类 ArcView 继承于 View，然后我们重写其三个构造方法，还有 onMeasure() 和 onDraw() 方法，这都是自定义 View 最基本的写法，比较简单这里就不详细说了， onMeasure() 用于测量 View 的宽高尺寸，onDraw() 就是具体的绘制过程了，具体的绘制思路是：我们在 onMeasure（）方法中拿到测量出来的宽和高，然后再 onDraw() 中初始化一个画笔，我们可以创建一个 LinearGradient 对象，然后调用设置画笔的 setShader() 方法就可以达到画笔渐变色的效果，然后再创建一个 Rect 对象，这里只是创建了一个矩形对象，要想绘制弧形，我们还需要设置绘制的路径，创建一个 Path 对象，分别调用 moveTo() 方法，和 quadTo() 方法，moveTo （）不会进行绘制，只用于移动移动画笔，一般和其他方法配合使用，这里和 quadTo() 方法配合使用，而 quadTo() 用于绘制圆滑的曲线，即贝塞尔曲线。mPath.quadTo(x1, y1, x2, y2) 其中x1、y1 为控制点，x2、y2 为结束点。有了路径之后我们就可以轻而易举地绘制出一个弧形了，完整的代码请看下面： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * Created by x-sir on 2018/8/10 :) * Function:自定义弧形 View */public class ArcView extends View &#123; private int mWidth; private int mHeight; private int mArcHeight; // 弧形高度 private int mBgColor; // 背景颜色 private Paint mPaint; public ArcView(Context context) &#123; this(context, null); &#125; public ArcView(Context context, @Nullable AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public ArcView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.ArcView); mArcHeight = typedArray.getDimensionPixelSize(R.styleable.ArcView_arcHeight, 0); mBgColor = typedArray.getColor(R.styleable.ArcView_bgColor, Color.parseColor(&quot;#1E90FF&quot;)); typedArray.recycle(); mPaint = new Paint(); &#125; @SuppressLint(&quot;DrawAllocation&quot;) @Override protected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); // 参数一为渐变起初点坐标 x 位置，参数二为 y 轴位置，参数三和四分辨对应渐变终点，最后参数为平铺方式，这里设置为镜像 LinearGradient lg = new LinearGradient(0, 0, mWidth, 0, Color.parseColor(&quot;#4796FB&quot;), Color.parseColor(&quot;#5AB4F9&quot;), Shader.TileMode.CLAMP); // 刚才已经讲到 Gradient 是基于 Shader 类，所以我们通过 Paint 的 setShader 方法来设置这个渐变 mPaint.setShader(lg); mPaint.setStyle(Paint.Style.FILL); //mPaint.setColor(mBgColor); mPaint.setAntiAlias(true); Rect rect = new Rect(0, 0, mWidth, mHeight - mArcHeight); canvas.drawRect(rect, mPaint); Path path = new Path(); path.moveTo(0, mHeight - mArcHeight); path.quadTo(mWidth / 2, mHeight, mWidth, mHeight - mArcHeight); canvas.drawPath(path, mPaint); &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; super.onMeasure(widthMeasureSpec, heightMeasureSpec); int widthSize = MeasureSpec.getSize(widthMeasureSpec); int widthMode = MeasureSpec.getMode(widthMeasureSpec); int heightSize = MeasureSpec.getSize(heightMeasureSpec); int heightMode = MeasureSpec.getMode(heightMeasureSpec); if (widthMode == MeasureSpec.EXACTLY) &#123; mWidth = widthSize; &#125; if (heightMode == MeasureSpec.EXACTLY) &#123; mHeight = heightSize; &#125; setMeasuredDimension(mWidth, mHeight); &#125;&#125; 我这里只定义了弧形的高度和背景颜色这两个自定义属性，其中还有渐变颜色的开始色值和结束色值，还有是否需要渐变等属性，都可以定义为自定义的属性，方便直接在布局文件中灵活进行配置，以适应不同的需求，也比较简单，我这里为了就不实现了。 2.自定义一个通用的 titlebar这样做我们可以提高代码的复用性，可以将一些功能封装进去，也更好地体现了封装的思想，实现也比较简单，使用 LayoutInflater 加载了一个布局文件，然后将 文字，字体大小，字体颜色和 title 背景色等定义成了自定义的属性，方便在布局文件中进行设置，另外我们内部默认处理了点击返回按钮的事件，对于需要其他特殊情况下返回按钮的处理，我们也定义了一个接口，方便外部使用接口来自行进行处理，代码也非常简单，看下面： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/** * Created by x-sir on 2018/9/2 :) * Function:自定义通用 TitleBar */public class TitleBarLayout extends LinearLayout &#123; private ImageView ivBack; private ImageView ivMenu; private TextView tvTitleName; private LinearLayout llTitleBg; private CharSequence mText; private int mTitleBgColor; private boolean mMenuVisible; private int mTextSize; private int mTextColor; private OnMenuClickListener mListener; private OnBackClickListener mOnBackListener; private static final String DEFAULT_TEXT = &quot;Title&quot;; // default text. private static final int DEFAULT_TEXT_SIZE = 16; // default text size. private static final String TAG = &quot;TitleBarLayout&quot;; public TitleBarLayout(Context context) &#123; this(context, null); &#125; public TitleBarLayout(Context context, @Nullable AttributeSet attrs) &#123; this(context, attrs, 0); &#125; public TitleBarLayout(Context context, @Nullable AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.TitleBarLayout); mText = typedArray.getText(R.styleable.TitleBarLayout_text); mTextSize = typedArray.getDimensionPixelSize(R.styleable.TitleBarLayout_textSize, DEFAULT_TEXT_SIZE); mTextColor = typedArray.getColor(R.styleable.TitleBarLayout_textColor, Color.parseColor(&quot;#FFFFFF&quot;)); mTitleBgColor = typedArray.getColor(R.styleable.TitleBarLayout_titleBgColor, Color.parseColor(&quot;#1E90FF&quot;)); mMenuVisible = typedArray.getBoolean(R.styleable.TitleBarLayout_menuVisible, false); typedArray.recycle(); initView(context); initData(); initListener(); &#125; private void initView(Context context) &#123; LayoutInflater.from(context).inflate(R.layout.common_titlebar, this); ivBack = findViewById(R.id.ivBack); ivMenu = findViewById(R.id.ivMenu); tvTitleName = findViewById(R.id.tvTitleName); llTitleBg = findViewById(R.id.llTitleBg); &#125; private void initData() &#123; String text = (mText != null) ? mText.toString() : DEFAULT_TEXT; tvTitleName.setText(text); tvTitleName.setTextSize(TypedValue.COMPLEX_UNIT_PX, mTextSize); tvTitleName.setTextColor(mTextColor); //llTitleBg.setBackgroundColor(mTitleBgColor); ivMenu.setVisibility(mMenuVisible ? VISIBLE : INVISIBLE); &#125; private void initListener() &#123; ivBack.setOnClickListener(v -&gt; &#123; // 如果监听器不为空就让其自己处理，为空就默认处理（销毁页面） if (mOnBackListener != null) &#123; mOnBackListener.onClick(); &#125; else &#123; ((Activity) getContext()).finish(); &#125; &#125;); ivMenu.setOnClickListener(v -&gt; &#123; if (mListener != null) &#123; mListener.onClick(); &#125; &#125;); &#125; public void setTitleName(String title) &#123; if (!TextUtils.isEmpty(title)) &#123; tvTitleName.setText(title); &#125; else &#123; Log.e(TAG, &quot;set title name failed, because title is null!&quot;); &#125; &#125; public void setOnMenuListener(OnMenuClickListener mListener) &#123; this.mListener = mListener; &#125; public void setOnBackListener(OnBackClickListener mOnBackListener) &#123; this.mOnBackListener = mOnBackListener; &#125; public interface OnMenuClickListener &#123; void onClick(); &#125; public interface OnBackClickListener &#123; void onClick(); &#125;&#125; 因为这里为了和绘制的弧形协调，我将 title 布局的背景设置了一个渐变的 shape 。 3.将布局延伸到系统状态栏Android 5.0 之后我们可以设置 Activity 的布局延伸到系统状态栏中，这样我们页面看起来更美观和协调，设置也比较简单，直接贴代码了： 1234567@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION); &#125; 另外在布局文件中也可以设置，只需在你 App 引用的主题中添加一行代码即可： 注意：因为这个属性是 5.0 之后才有的，在实际开发中需要做兼容处理，代码中设置时需要判断一下版本，布局文件中可以新建一个 values-v21 文件夹做兼容处理。 如果你的 title 的文字跑到状态栏里了，那样会很丑，在 title 布局的根标签中添加下面一行代码就可以了： 1android:fitsSystemWindows=&quot;true&quot; 这行代码的意思就是不占用系统状态栏的空间。 好了，所有绘制工作都已经完成了，是不是非常简单呢？如果觉得不错的话，欢迎点赞、评论和转发，你们的支持是我坚持不懈的动力！]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>View</tag>
        <tag>技术提升</tag>
        <tag>ArcView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你租的房子遇 “坑” 了么？]]></title>
    <url>%2F2018%2F10%2F26%2F%E4%BD%A0%E7%A7%9F%E7%9A%84%E6%88%BF%E5%AD%90%E9%81%87%20%E2%80%9C%E5%9D%91%E2%80%9D%20%E4%BA%86%E4%B9%88%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[你租的房子遇 “坑” 了么？ 前段时间真的是太忙了，出差了一周，另外还有自己的一堆事儿，忙成狗，几乎每天也就睡 5、6 个小时，现在终于不忙了，然后就可以安安静静地写文章了，好久没更了，让大家久等了。最近这段时间我身边发生了好多事情，有欠钱不还的，有租房被中介坑的，有公司裁员的… 真的是发生在谁身上谁倒霉，有些事情我们也无法避免，我们要做的就是不断吸取教训，长点心眼，提高自己判断力，来保护自己的利益不受侵害。 自从前一段时间爆出来自如甲醛房子的问题，后来又有自媒体爆料，一阿里 P7 员工在租住了杭州自如房 6 个月后，被查出患白血病，不久之后病情恶化，去世，一度引发舆论的关注！最近，又有媒体陆续曝出租客在自如出租房内的插座里发现针孔摄像头，租住数月后才发现。最近我身边几个认识的同学、同事租房也被中介坑，好像最近一段时间骗子又猖狂起来了？ 1.“寓见”你真是倒了八辈子的霉了【上海寓见公寓“爆仓”“租金贷”风险恐密集爆发】曾被雷军看好的长租公寓“爆仓”了。如今寓见公寓资金链断裂，一些房东在未收到租金的情况下，要求房客搬出。部分租客已聚集在寓见公寓总部所在地的上海市徐汇经侦支队报案，并试图“围堵”寓见公寓CEO 兼创始人林小森。在寓见公寓此次“爆仓”前，已经有多家长租公寓品牌出现问题。 这件事情真真切切的就发生在我同学的身上，他们从“寓见公寓”那里租的房子，“寓见公寓”从房东那里租的房子，她们每个月按时把租金交给“寓见公寓”，而“寓见公寓”没有把钱给房东，现在房东没有收到钱，房东现在找租客的事，另外，“寓见公寓”给租客们签的合同都是通过贷款平台贷的款，相当于是每个月的房租是分期付款，假设你签了 1 年的合同，那也就是说，“寓见公寓” 一次性就拿到了 1 年的租金（有钱了就可以去用钱去赚更多的钱了），然后，租客就每个月向贷款机构去还钱，这里说明一下，租客其实是不知道他们向贷款机构借钱了，签合同的时候，寓见的人只是说，这这个平台只是交租金，并没有向租客明确说明贷款这件事，我认为“寓见”隐瞒了事实，侵犯了租客的知情权，存在欺诈行为，当出现了事情之后，租客们才知道是“被”贷款了，如果没出现这事，租客可能一直都不知道“被”贷款了，现在的各种贷款都和你的征信挂钩，如果你没有按时交的话，有可能已经影响到你的征信了，可能影响到你买房买车等，但是你却全然不知，真的是太坑了，稍微一不注意就掉坑里了。现在“寓见”跑路，房东不让租客住房子，为了不影响征信，租客还要还贷款，你说这不是两头受气吃亏么？都是打工的，辛辛苦苦工作一个月，把工资的一大部分都交房租了，还遇到这样的事情，你说糟心不糟心？这种事情报案的话，处理起来也比较麻烦，能起到的作用也比较有限，所以，我们要擦亮自己的眼睛才是最主要的！ 在这里提醒大家一下：如果租房的时候让你绑定个人银行卡并且还要让你通过某个你没听过的平台交房租时，你可得警惕注意了，稍不注意你就“被”贷款了！ 2.黑中介“昊园恒业”是真的黑 这件事也是发生在我之前同事的身上，她之前是通过“昊园恒业”租的房子，然后在不知情的情况下，也被贷款了，是通过一个叫“元宝e家”的分期付款平台，元宝一次性把钱转给中介，现在中介违约了，中途让租客搬家，现在中介需要把钱返给元宝或者是将剩余的部分返给租客，但是中介一直拖着迟迟不给，现在租客和元宝之间的贷款还是有效的，也就说租客还要给元宝还贷款（影响征信），为什么中介迟迟拿不出钱？想都不用想，中介肯定把钱挪作他用了，一次性收一年的房租，中介才不会傻傻把钱拿手里或者存银行，他肯定是用这笔收过来的租金再搞其他投资，然后赚更多的钱，说白了就是以租房为幌子，玩的是资金流的把戏，美其名曰：“帮租客们减轻租房的压力，分期付款，享受高品质的生活”，嗯，没毛病，这样租户付款压力减轻了，还不用支付额外的利息，于是很多租户就接受了这种付款方式，这样租客们就轻轻松松的掉坑里了！ 下图是我前同事给大家的一些建议，都是血淋淋的教训，希望大家引以为鉴！ 最后，建议大家在租房的时候，首先找个人的房源或者是比较靠谱的中介，可以先搜一下中介的网上的评价或者有没有负面信息，然后再考虑要不要租，再签合同的时候也需要仔细看看有没有坑，另外对于押金条及合同等其他的材料要保留好，如果发生其他情况可作为证据，对于合同内容部分应该也必须加盖相应的公章，否则合同也是无效的合同，有些中介根本就没有合同或者合同很粗糙（严格来说不算合同），那你就得注意了，希望大家在租房的时候多留意，多长点心眼；还有就是租房的时候不要租刚装修完的房子，看着很干净，实则甲醛等严重超标，最好时租之前有人住过的房子就基本没什么问题。最后送给大家一句话，害人之心不可有，防人之心不可无！ 如果，你也在租房时遇到坑了，欢迎在下方评论，让更多的人看到，另外你觉得文章不错的话，欢迎点赞和转发，原创不易，且行且珍惜，谢谢你们！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>租房</tag>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手把手教你搭建 Hexo + GitHub 博客]]></title>
    <url>%2F2018%2F10%2F10%2FHexoBlogBuild%2F</url>
    <content type="text"><![CDATA[1.环境安装1.1 GitWindows:https://gitforwindows.org/ 如果是 Mac 电脑的话，请先安装 Xcode，因为 Xcode 自带 Git. 1.2 Node.js下载对应系统的 node 安装包，一路 next 无脑安装即可； https://nodejs.org/en/ 1.3 hexo因为 npm 命令是 node 中的，所有需要先安装node 然后再安装 hexo，然后利用 npm 命令即可安装 hexo（Windows 在任意位置点击鼠标右键，选择 Git bash，Mac 直接在终端中如下执行命令即可） 1npm install -g hexo 提示本篇文章可能存在时效性，最新版本 hexo 的安装请查看官方文档： https://hexo.io/docs/ 报错: npm ERR! registry error parsing json 错误，可能需要设置 npm 代理，执行命令 1npm config set registry http://registry.cnpmjs.org hexo:command not found删除刚刚安装的 npm 目录，重新执行命令： 1npm install -g hexo 来安装 hexo。 2.开始搭建首先创建 hexo 文件夹，如 HexoBlog，注意创建的文件夹一定是空的！！！进入 HexoBlog 目录并执行以下指令(Windows 在 HexoBlog 文件夹内点击鼠标右键，选择 Git bash，Mac 直接 cd 进入)，Hexo 即会自动在文件夹生成网站所需要的所有文件。 1hexo init 安装依赖包: 1npm install 报错： evernotecid://785B2D88-EE4A-435D-8F13-6593AEC86C1F/appyinxiangcom/15001405/ENResource/p25846 根据错误提示，是系统没有 package.json 这个文件导致。这个文件的作用就是管理你本地安装的npm 包，一个 package.json 文件可以做如下事情： 1.展示项目所依赖的npm包；2.允许你指定一个包的版本[范围]；3.让你建立起稳定，意味着你可以更好的与其他开发者共享； 此刻我们需要执行命令： 1npm init 创建package.json文件，系统会提示相关配置，也可以使用命令： 1npm init -y 直接创建 package.json 文件，这样创建好处是必填项已经帮你填好，执行完命令后可以看到用户路径下多了一个 package.json 文件。 温馨提示：如果是 Mac 的话，执行每一步命令记得都需要加 sudo ! 现在我们已经搭建起本地的 hexo 博客了，执行以下命令，然后到浏览器输入12 hexo generatehexo server12345678910好了，至此，我们本地博客已经搭建起来了，这里只能本地访问，别人看不到的，我们搭建的博客如果只是在本地那是没有任何意义的，接下来，我们需要把本地的博客部署到 GitHub 上去。报错：执行 ```hexo server``` 提示找不到该指令!解决办法：在 **Hexo 3.0** 后 **server** 被单独出来了，需要安装 **server**，安装的命令如下： npm install hexo -server –save123456789101112安装 **server** 后再试，问题解决~## 3.GitHub 创建博客如果已经有 GitHub 账号就创建一个仓库，仓库的名字需要和你的账号对应，格式为: **yourname.github.io** 其中 yourname 就是你的 GitHub 的用户名。如果没有 GitHub 账号，您需要先注册一个账号，注册完之后需要把你本地机器的 公钥添加到 GitHub 中去。### 3.1 生成 SSH 密钥打开 Git Bash 执行如下命令行： ssh-keygen -t rsa -C “youremailaddress”123456执行完会提示你输入一些信息，这里我们直接一路回车即可，密码设置为空。### 3.2 查看 SSH 密钥SSH 公钥默认储存在账户的主目录下的 ~/.ssh 目录，进入 .ssh 目录下，命令行： ls1234567891011121314151617181920查看如果显示 id_rsa 和 id_rsa.pub，说明已经成功生成了 SSH 公钥。### 3.3 添加 SSH 密钥打开 id_rsa.pub（Windows 可用任意一个文本编辑器打开，Mac 下用 cat 或者 vim 编辑器查看）复制里面的全部内容到:[https://github.com/settings/ssh](https://github.com/settings/ssh) 找到 Add SSH key，粘贴进去并保存～添加 ssh 的作用是你的 GitHub 就可以和你本地的机器进行 push 和 pull 操作了，不需要输入任何的密码，GitHub 就已经知道你是操作的了。## 4.Hexo 的使用### 4.1 Hexo 的目录结构![](http://pcobk8jbf.bkt.clouddn.com/Fpjfqr-LghTX4LF8Ivk4U06WdRNo)### 4.2 全局配置文件_config.yml Hexo ConfigurationDocs: http://hexo.io/docs/configuration.htmlSource: https://github.com/hexojs/hexo/Site #站点信息title: #标题subtitle: #副标题description: #站点描述，给搜索引擎看的author: #作者email: #电子邮箱language: zh-CN #语言 URL #链接格式url: #网址root: / #根目录permalink: :year/:month/:day/:title/ #文章的链接格式tag_dir: tags #标签目录archive_dir: archives #存档目录category_dir: categories #分类目录code_dir: downloads/codepermalink_defaults: Directory #目录source_dir: source #源文件目录public_dir: public #生成的网页文件目录 Writing #写作new_post_name: :title.md #新文章标题default_layout: post #默认的模板，包括 post、page、photo、draft（文章、页面、照片、草稿）titlecase: false #标题转换成大写external_link: true #在新选项卡中打开连接filename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsehighlight: #语法高亮 enable: true #是否启用 line_number: true #显示行号 tab_replace: Category &amp; Tag #分类和标签default_category: uncategorized #默认分类category_map:tag_map: Archives2: 开启分页1: 禁用分页0: 全部禁用archive: 2category: 2tag: 2 Server #本地服务器port: 4000 #端口号server_ip: localhost #IP 地址logger: falselogger_format: dev Date / Time format #日期时间格式date_format: YYYY-MM-DD #参考http://momentjs.com/docs/#/displaying/format/time_format: H:mm:ss Pagination #分页per_page: 10 #每页文章数，设置成 0 禁用分页pagination_dir: page Disqus #Disqus评论，替换为多说disqus_shortname: Extensions #拓展插件theme: landscape-plus #主题exclude_generator:plugins: #插件，例如生成 RSS 和站点地图的 hexo-generator-feed hexo-generator-sitemapDeployment #部署，将 lmintlcx 改成用户名deploy:type: gitrepo: git@github.com:yourgithub/yourgithub.github.io.gitbranch: master12345678编辑 **config.yml** 文件将 repo: git@github.com:yourgithub/yourgithub.github.io.git 替换为你刚建的 GitHub 仓库的地址。注意：每一行配置文件的冒号 “:” 后面有一个空格！repo 的这种形式的是配置了SSH Key之后的，如果没有配置则使用 https 形式的地址。然后执行如下命令即可完成生成静态网页 &amp; 部署： hexo generatehexo deploy1234提示：每次在执行上面两条命令之前先 hexo clean 一下，这样可以防止缓存的影响。如上命令可以简写，简写和全写命令对应如下： hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy123456问题：![](http://pcobk8jbf.bkt.clouddn.com/FiSI_f8EBlBMHZXLfeqVa0kTQvt8)安装 deployer: npm install hexo-deployer-git –save12再重新 hexo d，如果显示以下提示说明部署成功： [info] Deploy done: git123456789101112131415161718然后打开浏览器输入：yourgithub.github.io如果你看到了和刚才本地访问一样的网页，说明我们的博客已经成功的部署到了 GitHub 了。## 5.绑定域名博客搭建完，默认的域名只能是：yourgithub.github.io 而且是不能修改的，如果要想逼格更高点，想绑定自己的域名也是可以的。### 5.1 购买域名首先你需要购买一个域名，现在基本都是到万网或者腾讯等也可以购买域名，购买也比较简单，这里放出阿里万网购买地址：[https://wanwang.aliyun.com/](https://wanwang.aliyun.com/)### 5.2 配置DNS地址这里以万网为例，进入万网的管理控制台(阿里云手机 APP 也可以)进行修改，修改 DNS 为 DNSPod 的免费 DNS 地址： f1g1ns1.dnspod.netf1g1ns2.dnspod.net1234### 5.3 域名解析登录万网控制台或阿里云手机 APP 之后，把我们新注册的域名加进去，在域名解析列表中国添加 3 条解析记录： @ A 192.30.252.153@ A 192.30.252.154www CNAME yourname.github.io123456其中A的两条记录指向的 ip 地址是 GitHub Pages 的提供的 ip，如何知道你的 GitHub 上项目的 ip？### 5.4 添加 CNAME 文件新建一个名为 CNAME 的文件，无后缀，内容为你的域名地址，将该文件放入本地博客的 source 文件夹里面，执行下面命令并更新到 Github。 hexo cleanhexo ghexo d1234567891011121314151617181920注意：域名的地址不需要添加协议头 **http://** ,直接写域名即可，例如：www.baidu.com然后在你的浏览器中输入你的域名，是不是和之前一样，如果一样，说明你的域名已经绑定成功了～搭建博客本身的难度不大，重要的是搭建博客这个过程，主要考验自己的动手能力和问题解决能力，过程中你可能会遇见各种各样的问题，然后你会一个个的解决掉这些问题，这本身就是学习的过程，希望大家也能多多动手，希望大家搭建成功～最后晒上我的博客地址：[http://www.x-sir.com](http://www.x-sir.com)## 6.Hexo 博客主题美化### 6.1 clone 主题Hexo官网：[https://hexo.io/themes](https://hexo.io/themes)里面有特别多的主题可以选择，我在这里选的是 next这个主题，下载主题： cd themesgit clone https://github.com/Fechin/hexo-theme-diaspora.git diaspora1234### 6.2 启用主题修改Hexo配置文件 _config.yml 主题项设置为diaspora …theme: diaspora…1234### 6.3 更新主题注意：请在更时主题时备份_config.yml配置文件 cd themes/diasporagit pull1234### 6.4 发布新主题执行如下命令然后浏览器中输入博客地址查看： hexo cleanhexo ghexo d123456789101112注意：更换新的主题，可能会有一些延迟！## 7.Hexo 博客细节配置需要修改的内容可以参考网站：[https://hexo.io/zh-cn/docs/configuration](https://hexo.io/zh-cn/docs/configuration)里面对各个参数有一些详细的解释，我这里修改一些博客的标题，副标题，描述，语言等，建议大家修改一项，重新部署网站一下，因为一旦出错，这样就比较容易找到原因。## 8.安装插件 安装插件：npm install 插件名 –save卸载插件：npm uninstall 插件名更新插件和博客框架：npm update12执行以下命令安装 RSS 插件: npm install hexo-generator-feed –save12生成站点地图: npm install hexo-generator-sitemap –save12生成百度站点地图: npm install hexo-generator-baidu-sitemap –save12SEO 优化: npm install hexo-generator-seo-friendly-sitemap –save12HTML 压缩: npm install hexo-html-minifier –save12CSS 压缩: npm install hexo-clean-css –save12JS 压缩: npm install hexo-uglify –save12imagages 压缩: npm install hexo-imagemin –save1234插件开启配置根目录下的 `_config.yml`，添加以下代码: RSSfeed:type: atompath: atom.xmllimit: 20 sitemap提交给谷歌搜素引擎，SEO优化开启配置是一样的sitemap: path: sitemap.xml 提交百度搜索引擎baidusitemap: path: baidusitemap.xml HTML压缩html_minifier: exclude: css压缩clean_css: exclude: - &apos;*.min.css&apos; js压缩uglify: mangle: true output: compress: exclude: - &apos;*.min.js&apos; image压缩imagemin: enable : true interlaced : false multipass : false optimizationLevel: 2 pngquant : false progressive: false` 注意：目前设置 HTML 压缩有报错！图片压缩会导致图片破损！package.json 文件中可以看安装了哪些插件。 9.安装 gitalk 评论插件参考下面的博客即可，写的比较详细： https://segmentfault.com/a/1190000014085547 如果安装过程中，出现问题请先戳gitalk issue 区看看有没有解决方案： https://github.com/gitalk/gitalk/issues 参考链接 https://hexo.io/docs/ http://wuxiaolong.me/2015/07/31/build-blog-by-hexo/ https://www.jianshu.com/p/e5f95eb990ad https://github.com/Fechin/hexo-theme-diaspora https://www.jianshu.com/p/77db3862595c https://www.jianshu.com/p/86557c34b671 https://github.com/gitalk/gitalk https://www.jianshu.com/p/9be29ed2f4b7 https://imsun.net/posts/gitment-introduction/#more https://calpa.me/2018/03/10/gitalk-error-validation-failed-442-solution]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>iTunes</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[技术人如何提升自己（推荐必读）]]></title>
    <url>%2F2018%2F09%2F24%2F%E6%8A%80%E6%9C%AF%E4%BA%BA%E5%A6%82%E4%BD%95%E6%8F%90%E5%8D%87%E8%87%AA%E5%B7%B1%EF%BC%88%E6%8E%A8%E8%8D%90%E5%BF%85%E8%AF%BB%EF%BC%89%2F</url>
    <content type="text"><![CDATA[点击关注“IT大飞说”，置顶或星标公众号订阅公众号（ID：ITBigFly）第一时间收到推送 作为一个技术人，我们不仅要不断地学习来提升自己不被淘汰，另外也要不断总结自己的经验和教训，踩过的坑、走过的弯路要善于去思考如何避免下次再踩坑？我们也不要一直局限于自己的技术世界一心只敲代码，两耳不闻窗外事，这样未免就有点太局限了，也不利于自己的发展。我们经历着互联网飞速发展的时代，从最初的 PC 时代，到移动互联网，然后到近几年的大数据、人工智能、区块链等技术，技术迭代的速度比以前更加快速了，这也意味着新的技术也会慢慢的代替掉一些旧的技术，因此你也要跟随着时代的变化，不断更新自己的技术栈，去适应新的技术环境，提升自己的核心竞争力！一些新兴技术行业的兴盛必然会导致另一些技术的衰落，衰落这个词用的不是太恰当，举个例子，例如 12、13 年很火的移动开发到这几年逐渐的也没那么火了，其实经过这几年的发展，开发的门槛越来越低，对技术人才的需求也日渐趋于饱和了，但是初级工程师还是占很大一部分，高级工程师还是比较少，所以中间出现了断层的现象，如果你是初级者，怎样更快速地去提升自己，实现向高级的跨越？这应该是你需要思考的问题。如果是中高级开发者，也应该有一些危机感，这样才能时刻提醒自己去不断的学习，不断地去改变和适应技术的发展，跟随技术的潮流不断前进，以至于才不会被淘汰！另外，也不要一直守着自己的一亩三分地，要适当的多学习一些其他方面的技术，培养自己的第二技术能力，前提是首先得干好自己的本职工作，利用闲余时间去学习一些其他技术，技术之间也是相通的，如果你对某一个方面研究比较透彻的话，学习其他方面的技术也是很容易能够上手的。之前看过美国那些 FLAG 公司，他们一般招聘都不会去明确的注明招聘的岗位，一般面试主要都是让你做算法题，他们认为你把算法这么难的东西都搞会了，不管干其他什么岗位工作都是没有问题的。另外在工作的同时也要注重提升自己的技术影响力，我觉得这个也是比较重要的一方面，好处是不仅可以帮你之后找工作、升职、加薪和赚钱都是有帮助的，那么该如何提升自己呢？ 1.坚持写作我认为，写作对于一个技术人来说太重要了，一方面不仅可以提高自己的写作水平，另一方面也可以锻炼自己的语言组织和表达能力，巩固知识点，加深理解和记忆。写作有形式可以是写博客和公众号，还有像知乎这种其他平台。特别说一下写博客，现在的博客平台有很多，比较有名的有 CSDN、简书、掘金等平台，基本都可以使用可视化的 MarkDown 编辑器来写，用 MarkDown 的好处是语法简单，显示效果很简洁，不需要去特别排版，这样写作的效率就提高了；作为技术文章，我强烈建议大家原创，只有这样才能将自己的学到的知识总结并且转化为自己的输出，更重要的是在写作的过程中会让你有更加深刻的理解，有时候虽然你学会了某个新技术，但是你不一定能写的出来，可以这么说，学会了是一个境界，理解了又是一个境界，理解了并写出来又是另一个境界，写出来并且让别人能看懂又是一种更高的境界！建议大家在技术的道路上切勿眼高手低，实践是检验真理的唯一标准！实践出真知！写作要多站到读者的角度去思考怎么写？怎么写才能让读者更容易的理解？怎样写才能适合不同技术水平层次的人理解？多思考几个为什么，不骄不躁，慢慢地一步一个脚印，写的时间长了也就得心应手了，如果你能一直坚持下去，越往后写你会发现你会喜欢上写作的，一天不写你就会觉得手痒痒，习惯一旦养成了，就自然而然的去执行了，即习惯成自然。随着你坚持写作的时间越来越长，你的读者和文章的阅读量也会越来越多，可能还有读者给你留言与你交流，这时候你需要和读者一起互动或者耐心的帮助他们解答问题，这样可以增加读者对你的好感度，容易积攒自己的口碑，口碑上去了影响力自然就有了，容易提升个人品牌的知名度！知名度上去了就会产生品牌效应。当然，要想达到这种程度，非常的难，好多人坚持到一半就坚持不下去了，如果你能一直坚持下去你就成功了一半，你看好多公号大V，大多都是吭哧吭哧坚持写了好几年，最好才成大V的。不必羡慕别人，你需要做的是静下心，坚持下去，在对的时间做对的事，剩下的就交给时间，相信功夫不负有心人，你要的岁月都会给你！ 2.热爱开源作为全世界最大的同 xing 交(开)友(源)社区GitHub，被大家戏称为 GayHub，我想作为一个程序员应该都不陌生吧，说实在的，开源社区真的是我们程序员的福利之地啊，好多大厂包括 Google、FaceBook、Square、Apache、阿里、腾讯等都开源了好多优秀的框架，大大提升了程序员开发效率，也降低了开发的成本。我是在 14 年的时候就申请了 GitHub 账号，刚开始只是在上面找一些东西，也不怎么会用，也不会开源项目，直到 16 年的时候看了一些 GitHub 的教程，逐渐的发现了它的好，它的强大之处，然后开始为开源世界做贡献，从此一发不可收拾，慢慢的就喜欢上 GitHub 了…什么？卧槽！你特么 qinshou 啊，连 GitHub 都不放过! 汗====囧 emmmmmmmmmmm~ 我竟无言以对，感觉自己有点方啊！好了，言归正传，继续说我们的 GitHub，GitHub 汇集了全世界好多的优秀开源项目和一大批的优秀开发者，从此学习交流不分国界，不仅可以和全世界各地的开发者一起沟通交流，fork 优秀的开源项目来进行学习，另外可以 PR 和提 issue，一起为开源世界做贡献，时间长了，你会发现这是一件很有成就感的事情。当你看到自己提交的历史，特别有成就感！ 下面是我的 commit map. 我虽然也不是每天都 commit，但不定期零零散散都会坚持去 commit，在使用 GitHub 的这几年，我也收到了好几份的面试邀请邮件，其中包括几个大厂，有 Amazon、阿里等，这个好像也是根据 GitHub 排名和贡献来发招聘邀请邮件的，虽说这种招人的方式有一定的局限，但是我觉得最起码可以体现出，你一定是一个热爱开源，热于分享的程序员，没毛病！ 下面是我收到的邮件： 3.多向大牛学习大牛之所以是大牛，肯定是在某一方很厉害，有值得你去学习的地方，跟着大牛的脚步可以让你事半功倍，不仅可以借鉴一下大牛们的成功经验，也可以让我们少走弯路，这里的少走弯路的意思是避免让你走错方向，把时间浪费在不必要的地方，当然学习过程中遇到的坎和坑，该经历的还是要经历的，遇到的坑多了以后你就都能应对自如了，这就是经验吧！只有自己亲身体会了、总结了才能转化为自己的经验。多与大牛接触和交流，学习大牛解决问题的方式，然后结合自身去不断实践，取长补短，不断总结并完善自己！那么怎样向大牛学习呢？大牛们一般都有自己的公号，博客或者技术圈子，你可以关注大牛的公号或博客来学习，另外，这两年知识付费也火热起来，像知识星球、极客时间等一些有代表性的平台更是火热，一些大牛也有自己的知识星球或者是付费专栏，你可以选择几个适合自己的然后加入圈子学习，这样就可以更近距离的与大牛交流和学习了。知识付费还有一个作用就是对信息的筛选，说实在的，我们都处在信息爆炸的时代，每天都会接受到各种各样的信息，当然也包括各种垃圾信息，很容易让人眼花缭乱，知识的内容也鱼龙混杂，质量也参差不齐，而知识付费的好处就是别人帮你把知识已经筛选好了，而且质量也比较有保证，接下来你只要安心的学习就好了！而有的人就是喜欢免费的，之前听有人说：“现在学习还要花钱啊，网上一找一大堆！” 是，没错！现在网上最不缺的就是免费的学习资源了，这么多资源，你知道课程的质量怎么样么？你如何才能筛选出最好的资源？这些资源都是你需要花时间和精力去做的事情，而且找到的并不一定好，而大牛们用他们多年来的经验然后总结出来的东西，你只需要花几十块或者上百块买来去学习，何乐而不为呢？这样大佬们也乐于分享，你也得到了一个学习的圈子，加入圈子的人都和你一样，都是为了学习才加入的，相当于是给你们营造了一个学习的氛围，物以类聚，人以群分，和学习的人在一起，你学习的动力也有了，学习也就更快了，这样你自己的时间成本也会省下来，相当于是用钱买时间，有的人就是算不清这个账，愿意花上百块的钱去玩，也不愿意花钱去投资自己的学习，那么我只能说你的目光太短浅了，我希望大家不要只看到眼前的利益，目光放长远一些，多提高一些自己的认知能力，建议大家能用钱解决问题的一定要用钱去解决！ 好了，今天的分享就到这里，如果我的文章对你有帮助、有启发，请帮我点个赞，谢谢！另外也欢迎大家在下方评论留言与我交流。 猜你喜欢：给大家推荐一个神器Android 最全 Intent 传递数据姿势 欢迎扫码关注我的公众号]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>技术提升</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[825 安卓巴士精华总结]]></title>
    <url>%2F2018%2F08%2F24%2F825%20%E5%AE%89%E5%8D%93%E5%B7%B4%E5%A3%AB%E7%B2%BE%E5%8D%8E%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一年一度的安卓巴士开发者大会在上海隆重举行，有幸亲临参加了本次大会，本篇文章仅对本次大会的个人感受和各位技术大佬的分享以及未来的技术趋势与大家分享。 本次大会的主要内容有：技术大咖的个人主题分享，互动抽奖环节，圆桌会议，下午茶休息（提供各种水果和小吃甜点等），抽奖的奖品也比较丰厚，有技术图书，贴纸，抱枕，T恤，GDD 大会门票，各种小玩具等，奖品也比较丰厚。 上午场上午第一位分享的嘉宾是 openinstall 的联合创始人徐兴，分享的是 openinstall 的 App 免邀请码安装及 App 安装来源的数据统计等技术功能，对于App的推广和数据统计来说是一把利器，相比传统的邀请码安装方式更简单、更容易，想了解更多请到官网进行详细了解，这里就不赘述了。 上午第二位分享的嘉宾是饿了么大佬王雨威（江湖人称：巴掌），主要分享了一个饿了么的来源库：UETool ，简单说，它是一个让程序员，设计师，测试可以动态调试 View 各种属性的工具，功能很强大，大大提高了开发的效率，更多介绍请戳 GitHub： https://github.com/eleme/UETool 上午第三位分享的嘉宾是手机淘宝无线技术专家费义云，主要是先从计算机图形学引申到手机上的图形开发处理技术，从 GPU 底层的到上层应用进行详细的讲解，理论性和专业性都比较强，另外还有3D、AR、VR、OpenGL ES 等方面都做了细致的介绍，最后他还提出技术人提升的三层模型的观点，为技术人指明了方向，值得技术人思考。 下午场下午第一位分享的嘉宾是张涛，大家可能都知道他的张涛实验室，分享的主题是《Android 十年，还有哪些可以做的》，主要从 Android 的过去到现在的发展，以及Android 技术演变的历程为主线，以几个大厂商 App 为例，回顾了 Android 的技术演变和 App 架构演变历程，中间贯穿了各种技术知识，分享很棒，回顾过去，展望未来，对于 Android 未来技术的发展趋势也指明了方向。 下午第二位分享的嘉宾是美图高级安卓开发工程师邱炬，分享的主题是《全面解析Android 线程》，由浅入深，从上层到底层的线程创建，让我们更清楚的了解了线程的本质，还对线程的优先级进行详细的介绍，另外还对线程池及多线程开发的注意事项进行详细的讲解，还对线程的性能及安全性问题做了很细致的分享，这些问题都是实际开发中经常遇到的问题，真的是收益匪浅！ 下午第三位分享的嘉宾是我们的刘哥，也就是《Android进阶之光》的作者刘望舒，分享的主题是《Android应用开发如何更高效的阅读系统源码》，主要从：为何要阅读系统源码？如何阅读系统源码？系统源码的知识体系等几个问题来给大家分享了阅读系统源码的重要性和好处，这样以便于我们更好的理解 Android，理解 Android 系统，方便我们写出更高质量的代码，也可以解决一些难以解决的问题，最后还给大家推荐了一些优秀的博客作者和工具，干货满满，刘哥的演讲有激情、有速度！期待刘哥的新书《Android进阶解密》。 下午第三个进行分享的是：四位嘉宾的圆桌会议，四位嘉宾分别是：纪元（大数据嘉宾）MobData运营VP，费义云（机器学习嘉宾）手机淘宝无线技术专家，任义（区块链嘉宾）米客思科技公司董事长，章国良（人工智能嘉宾）AIhub 人工智能助推器CEO，四位大咖从各自不同的技术领域分享了如何用技术解决现实的问题，以及未来技术的发展趋势，开阔了我们的眼界，同时让我们对未来进行思考，我们不要仅仅停留在自己的一亩三分地，更应该去提升自己的技术栈和眼界，不断提高自身的能力，勇于创新，这样才能弯道超车！ 下午第四位分享的嘉宾是前爱奇艺多媒体开发何俊林，也就是我们的鱼哥，分享的主题是《Android音视频知识分享》，主要从多媒体基础概念，Android平台播放器，常见音视频开发中的问题总结，播放案例介绍等几个方面详细介绍了音视频的相关知识，讲的很详细很系统。这两年音视频也算是比较火的一个方向，对于音视频开发者来说，真的是干货很足！ 下午第五位分享的嘉宾是扔物线朱凯，也是最后一位分享嘉宾，分享的主题是《从图片上传说起：我们究竟需要怎样的Android工程师》，主要从图片上传怎么做？BASE64 更安全和稳定？怎么给服务器提交信息？Retrofit 比 OkHttp 好用？等几个问题，由浅入深地进行讲解，简单明了，作为技术人应该知其然，也要知其所以然。最后还为我们的安卓工程师指明了方向，分析了特殊时代的困境和机遇，如何迈向「高级」工程师，我想每个人自己的心里都有一个答案。 总体来说，本次大会真的是收益匪浅，不仅可以和大佬们面对面分享，另外还可以认识一些同行的朋友，建议大家以后有机会多参加一些这样的活动。本文只对本次大会做简单的总结，如果想查看本次大会的视频，照片，PPT可关注“安卓巴士Android开发者门户”公众号，回复关键字：「825资料」、「825视频」、「825照片」即可获取。 声明一下，本文没有任何商业推广等利益关系，纯粹是为了给大家分享技术来进行学习交流！]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>openinstall</tag>
        <tag>UETool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给大家推荐一个神器]]></title>
    <url>%2F2018%2F08%2F24%2F%E7%BB%99%E5%A4%A7%E5%AE%B6%E6%8E%A8%E8%8D%90%E4%B8%80%E4%B8%AA%E7%A5%9E%E5%99%A8%2F</url>
    <content type="text"><![CDATA[今天不扯淡，给你们来点干的，推荐给你们一个神器…这个神器是什么呢？ 现如今，对于广大 IT 从业人员来说，很重要的三项技能是编程、英语和写作，编程不用说了，我们就靠这个吃饭的；英语对大多数的人来说，可能比较差，也算是比较头疼的，对于编程人员来说，对英语门槛的要求还算比较低的，因为写代码基本都是一些常用的编程语法词汇，另外对于英文的技术文档的阅读也还好，其实也就那么多的词汇，基本都是一些专业词汇，英文技术文档看多了，基本也没太多的生词，偶尔遇到不会的生词，用翻译软件查一下也特别的方便，但是我认为这只达到了编程所具备的基本英语水平，不算是真正的会英语，语言就是用来交流的，如果你能流畅的用英语交流才算是自己的一项技能，真正的会英语。对于大多数中国人来说，从小学到现在，学了差不多十几年，但是学的都是哑巴英语，老师大多发音也不标准，然后为了考试学习一堆的语法知识，全都是为了考试，根本没法用来交流，所以你英语没学好也不全是自己的原因。我自认为我自己的英语水平还可以，不算很厉害，但是在同龄人中应该算是比较偏上吧，一方面是有兴趣、喜欢学，另一方面自己也总结了一些学习英语方面的方法和技巧，回头有时间给大家整理一篇关于英语学习方面的文章，今天这里就不展开赘述了；另外一个技能就是写作了，对于大多数程序员来说，写作也算是比较困难的，尤其是刚开始写作，想半天写不出来一句话，说实话我自己也是，万事开头难，但是我相信只要坚持写作，坚持阅读，慢慢地一点一点，然后再写作过程中不断的总结，相信写多了你的写作水平会提高的，进步总有一个过程，写作这个技能还是要慢慢要磨出来的，不要寻求什么捷径，一夜变成大文豪，那是不可能的！回头有时间给大家整理一篇关于如何写作方面的文章。 如果说一篇文章内容很好，但是排版很差你会看吗？我想我是没有看下去的欲望，先抛开内容不说，排版可以说是一篇文章的脸面，第一印象不好，读者也就没有看下去的欲望了，所以一篇文章的第一印象是非常重要的。一篇好的文章排版肯定是经过精心设计的，包括文字的字体大小、颜色，字间距、行间距等等，另外还有文章的配图，颜色的搭配，文章段落的划分，文章的两端缩进等，总之一句话，好的排版会让你感觉看着很舒服，阅读起来也不会累。我刚开始写作的时候也遇到了排版的问题，不管怎么排，还是感觉怪怪的，没有达到自己想要的那种效果，我平时也比较喜欢写博客，现在好多博客平台大都支持 MarkDown 语法，你用 MarkDown 写完之后直接导入就行了，也不用过多的修改效果也很好，简单、清晰！但是还有一些平台是不支持 MarkDown 的，所以排版就是一个问题了，后来发现微信公众号有一个第三方的插件叫壹伴助手，试用过一段时间，不过他是收费的，后来我又发现了一个免费排版神器，也就是我现在一直用的，用了这么长时间感觉用的很爽，也很方便，所以我就推荐给大家，它叫 「Md2All」，是一个在线 MarkDown 排版神器，浏览器访问地址为：http://md.aclickall.com 可能一些读者已经用过了，用过的就不用往下看了，下面我就做一个简单的介绍和使用。 说一下我觉得比较好的地方： 支持一键排版； 支持几十种代码主题； 支持代码显示行数及代码紧凑； 支持导出带样式的 html; 支持上传到七牛云图床； … 更多功能介绍及使用，请访问：http://md.aclickall.com 查看，或者关注作者的微信公众号：颜家大少。 编辑面截图如下： 左边是 MarkDown 编辑区，右边是预览，界面很清晰、简洁！基本上，我每次排版的步骤是： 先用本地的 Markdown 编辑器写文章； 然后复制到 Md2All 的 MarkDown 编辑区； 设置文章的主题及边距、字体颜色大小等参数； 点击一键排版(自动会给你排好版); 点击复制，然后粘贴到微信公众号或者 CSDN、cnblog 的 html 编辑器中就可以发布文章了； 根据我以往的经验，如果是发布到 CSDN 或 cnblog，直接发布即可，如果是发布到微信公众号，你可以先推送到手机上预览一下，一般情况下做一些微调就可以了，例如字间距、行间距、两端缩进等，你可以参考本篇文章的排版效果。 好了，今天的推荐就到这里，声明一下，本篇文章没有任何利益及商业互推关系，纯粹是发自内心的觉得这个工具好用，所以就推荐给大家，好东西是要分享出来的，这样才有意义！ 大家好，才是真的好！ 喜欢我的话，就关注一下呗！]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>写作</tag>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手把手教你撸一个 Loading]]></title>
    <url>%2F2018%2F08%2F19%2F%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E6%92%B8%E4%B8%80%E4%B8%AALoading%2F</url>
    <content type="text"><![CDATA[点击上面蓝色字体关注“IT大飞说”置顶公众号（ID：ITBigFly）第一时间收到推送 作为 Android 开发者，无奈经常会碰到各种各样的奇葩需求，现在大多公司 UI 设计图、标注都是按 IOS 来设计的，包括一个IOS特有的效果等，要实现和 IOS 一样的效果，无奈 Android 只能各种仿 IOS 了，经常也是产品被怼，IOS 能实现，为什么 Android 不能实现？好吧，今天我们就来写一个仿 IOS 的加载 loading 效果。 1.先看效果图 效果还满意吧？实现的思路是，在页面上弹出一个全屏的 popupWindow,居中是一个半透明的圆角shape,中间一个 gif 图片，下面是一个 TextView，最外层布局背景为透明，另外把其他需外设置的属性及参数通过建造者模式从外部进行配置，同时提供默认的属性值，这样可以适应各种需求的变化了，代码也比较简单，我的注释也写的比较详细，相信你一定能看得懂。 2.代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404/** * Created by x-sir on 2018/8/22 :) * Function: */public class LoadingView &#123; private String mText; private int mTextSize; private int mGifWidth; private int mGifHeight; private int mDrawableId; private View mPopupView; private Context mContext; private String mTextColor; private int mCornerRadius; private int mLoadingWidth; private int mLoadingHeight; private int mTextMarginTop; private boolean mIsFocusable; private String mLoadingBgColor; private PopupWindow mPopupWindow; private WeakReference&lt;View&gt; mView; private OnLoadingListener mListener; private static final String DEFAULT_TEXT = &quot;加载中...&quot;; // default text private static final int DEFAULT_TEXT_SIZE = 12; // default text size private static final int DEFAULT_TEXT_MARGIN_TOP = 6; // default text margin top private static final String DEFAULT_TEXT_COLOR = &quot;#FFFFFF&quot;; // default text color private static final int DEFAULT_CORNER_RADIUS = 4; // default loading background radius size private static final String DEFAULT_LOADING_BG_COLOR = &quot;#CC000000&quot;; // default loading background color private static final int DEFAULT_DRAWABLE_ID = R.drawable.loading1; // default loading drawable private static final int DEFAULT_GIF_WIDTH = 30; // default gif width private static final int DEFAULT_GIF_HEIGHT = 30; // default gif height /** * Constructor. * * @param builder */ public LoadingView(Builder builder) &#123; this.mText = builder.text; this.mView = builder.view; this.mListener = builder.listener; this.mTextSize = builder.textSize; this.mTextColor = builder.textColor; this.mCornerRadius = builder.cornerRadius; this.mContext = builder.applicationContext; this.mLoadingBgColor = builder.loadingBgColor; this.mDrawableId = builder.drawableId; this.mGifWidth = builder.gifWidth; this.mGifHeight = builder.gifHeight; this.mLoadingWidth = builder.loadingWidth; this.mLoadingHeight = builder.loadingHeight; this.mTextMarginTop = builder.textMarginTop; this.mIsFocusable = builder.isFocusable; initView(); &#125; /** * Initialize view parameters. */ private void initView() &#123; if (mPopupView == null) &#123; mPopupView = View.inflate(mContext, R.layout.popupwindow_loading, null); &#125; if (mPopupWindow == null) &#123; mPopupWindow = new PopupWindow(mPopupView, WindowManager.LayoutParams.MATCH_PARENT, WindowManager.LayoutParams.MATCH_PARENT); &#125; mPopupWindow.setOnDismissListener(() -&gt; &#123; if (mListener != null) &#123; mListener.onDismiss(); &#125; &#125;); mPopupWindow.setBackgroundDrawable(new BitmapDrawable()); // 当 mIsFocusable 为 true 时，响应返回键消失，为 false 时响应 activity 返回操作，默认为 false mPopupWindow.setFocusable(mIsFocusable); LinearLayout llLoadingBg = (LinearLayout) mPopupView.findViewById(R.id.llLoadingBg); ImageView ivLoading = (ImageView) mPopupView.findViewById(R.id.ivLoading); TextView tvContent = (TextView) mPopupView.findViewById(R.id.tvContent); RelativeLayout.LayoutParams rlParams = (RelativeLayout.LayoutParams) llLoadingBg.getLayoutParams(); if (mLoadingWidth != -1 &amp;&amp; mLoadingHeight != -1) &#123; rlParams.width = dp2px(mLoadingWidth); rlParams.height = dp2px(mLoadingHeight); &#125; else &#123; rlParams.width = RelativeLayout.LayoutParams.WRAP_CONTENT; rlParams.height = RelativeLayout.LayoutParams.WRAP_CONTENT; &#125; llLoadingBg.setLayoutParams(rlParams); GradientDrawable mGroupDrawable = new GradientDrawable(); /*设置 Drawable 的形状为矩形*/ mGroupDrawable.setShape(GradientDrawable.RECTANGLE); /*设置背景颜色*/ mGroupDrawable.setColor(Color.parseColor(mLoadingBgColor)); /*设置圆角大小*/ mGroupDrawable.setCornerRadius(dp2px(mCornerRadius)); llLoadingBg.setBackground(mGroupDrawable); LinearLayout.LayoutParams params = (LinearLayout.LayoutParams) tvContent.getLayoutParams(); params.topMargin = dp2px(mTextMarginTop); tvContent.setLayoutParams(params); /*设置显示文本*/ tvContent.setText(mText); /*设置文本大小(以 SP 为单位)*/ tvContent.setTextSize(TypedValue.COMPLEX_UNIT_SP, mTextSize); /*设置文本颜色*/ tvContent.setTextColor(Color.parseColor(mTextColor)); LinearLayout.LayoutParams llParams = (LinearLayout.LayoutParams) ivLoading.getLayoutParams(); llParams.width = dp2px(mGifWidth); llParams.height = dp2px(mGifHeight); ivLoading.setLayoutParams(llParams); /*加载 GIF 图片*/ Glide.with(mContext).load(mDrawableId) .diskCacheStrategy(DiskCacheStrategy.SOURCE) .into(ivLoading); &#125; /** * Show popupWindow. */ public void show() &#123; dismiss(); if (mPopupWindow != null) &#123; // 必须要 post runnable，如果在onCreate中调用则会抛：android.view.WindowManager$BadTokenException: Unable to add window -- token mView.get().post(() -&gt; mPopupWindow.showAtLocation(mView.get(), Gravity.BOTTOM | Gravity.CENTER_HORIZONTAL, 0, 0)); &#125; &#125; /** * Cancel popupWindow showing. */ public void dismiss() &#123; if (mPopupWindow != null &amp;&amp; mPopupWindow.isShowing()) &#123; mPopupWindow.dismiss(); &#125; &#125; /** * Invoke on Activity onDestroy() method. */ public void dispose() &#123; if (mPopupWindow != null &amp;&amp; mPopupWindow.isShowing()) &#123; mPopupWindow.dismiss(); &#125; mPopupWindow = null; if (mView != null) &#123; mView.clear(); mView = null; &#125; &#125; /** * PopupWindow is or not showing. * * @return */ public boolean isShowing() &#123; return mPopupWindow != null &amp;&amp; mPopupWindow.isShowing(); &#125; /** * Builder inner class. */ public static final class Builder &#123; private String text; private String textColor; private int textSize = -1; private int gifWidth = -1; private int gifHeight = -1; private int drawableId = -1; private String loadingBgColor; private int cornerRadius = -1; private int loadingWidth = -1; private int loadingHeight = -1; private int textMarginTop = -1; private boolean isFocusable = false; private WeakReference&lt;View&gt; view; private OnLoadingListener listener; private Context applicationContext; /** * Constructor */ public Builder(Context context) &#123; this.applicationContext = context.getApplicationContext(); &#125; /** * Set content text. * * @param text * @return */ public Builder setText(String text) &#123; this.text = text; return this; &#125; /** * Set text size. * * @param textSize * @return */ public Builder setTextSize(int textSize) &#123; this.textSize = textSize; return this; &#125; /** * Set text margin top dimen. * * @param textMarginTop * @return */ public Builder setTextMarginTop(int textMarginTop) &#123; this.textMarginTop = textMarginTop; return this; &#125; /** * Set popupWindow&apos;s focusable. * * @param isFocusable * @return */ public Builder setFocusable(boolean isFocusable) &#123; this.isFocusable = isFocusable; return this; &#125; /** * Set gif imageView width. * * @param gifWidth * @return */ public Builder setGifWidth(int gifWidth) &#123; this.gifWidth = gifWidth; return this; &#125; /** * Set gif imageView height. * * @param gifHeight * @return */ public Builder setGifHeight(int gifHeight) &#123; this.gifHeight = gifHeight; return this; &#125; /** * Set gif loadingView width. * * @param loadingWidth * @return */ public Builder setLoadingWidth(int loadingWidth) &#123; this.loadingWidth = loadingWidth; return this; &#125; /** * Set gif loadingView height. * * @param loadingHeight * @return */ public Builder setLoadingHeight(int loadingHeight) &#123; this.loadingHeight = loadingHeight; return this; &#125; /** * Set text color. * * @param textColor * @return */ public Builder setTextColor(String textColor) &#123; this.textColor = textColor; return this; &#125; /** * Set loadingView corner radius. * * @param cornerRadius * @return */ public Builder setCornerRadius(int cornerRadius) &#123; this.cornerRadius = cornerRadius; return this; &#125; /** * Set loadingView background color. * * @param loadingBgColor * @return */ public Builder setLoadingBgColor(String loadingBgColor) &#123; this.loadingBgColor = loadingBgColor; return this; &#125; /** * Set gif drawable resource. * * @param drawableId * @return */ public Builder setGifDrawable(int drawableId) &#123; this.drawableId = drawableId; return this; &#125; /** * Set location at parent view, because popupWindow must be dependency activity. * * @param view * @return */ public Builder setDropView(View view) &#123; if (view != null) &#123; this.view = new WeakReference&lt;&gt;(view); &#125; else &#123; throw new IllegalArgumentException(&quot;must be point parent view!&quot;); &#125; return this; &#125; /** * set on popupWindow dismiss listener. * * @param listener * @return */ public Builder setListener(OnLoadingListener listener) &#123; this.listener = listener; return this; &#125; public LoadingView build() &#123; if (TextUtils.isEmpty(text)) &#123; text = DEFAULT_TEXT; &#125; if (textSize == -1) &#123; textSize = DEFAULT_TEXT_SIZE; &#125; if (textMarginTop == -1) &#123; textMarginTop = DEFAULT_TEXT_MARGIN_TOP; &#125; if (TextUtils.isEmpty(textColor)) &#123; textColor = DEFAULT_TEXT_COLOR; &#125; if (TextUtils.isEmpty(loadingBgColor)) &#123; loadingBgColor = DEFAULT_LOADING_BG_COLOR; &#125; if (cornerRadius == -1) &#123; cornerRadius = DEFAULT_CORNER_RADIUS; &#125; if (view == null) &#123; throw new IllegalArgumentException(&quot;must be point parent view!&quot;); &#125; if (drawableId == -1) &#123; drawableId = DEFAULT_DRAWABLE_ID; &#125; if (gifWidth == -1) &#123; gifWidth = DEFAULT_GIF_WIDTH; &#125; if (gifHeight == -1) &#123; gifHeight = DEFAULT_GIF_HEIGHT; &#125; return new LoadingView(this); &#125; &#125; /** * dp convert to px. * * @param dpValue * @return */ private int dp2px(float dpValue) &#123; float scale = mContext.getResources().getDisplayMetrics().density; return (int) (dpValue * scale + 0.5f); &#125; /** * Define popupWindow dismiss listener. */ interface OnLoadingListener &#123; void onDismiss(); &#125;&#125; 3.用法3.1初始化Loading1.最基本的用法: 12345// 因为 PopupWindow 依赖于Activity，所以必须要调用 setDropView 方法设置要挂载的 View，// 一般是 Activity 或 Fragment 的根 View，其他参数可根据需求进行设置。mLoadingView = new LoadingView.Builder(this) .setDropView(activity_main) .build(); 2.自定义设置各种参数: 12345678910111213141516mLoadingView = new LoadingView.Builder(this) .setText(&quot;拼命加载中...&quot;) // 设置文案 .setTextSize(12) // 设置字体大小(sp) .setTextColor(&quot;#FFFFFF&quot;) // 设置字体颜色(#RGB &amp; #ARGB) .setTextMarginTop(10) // 设置文字距上的距离(dp) .setCornerRadius(4) // 设置圆角半径(dp) .setLoadingBgColor(&quot;#CC000000&quot;) // 设置背景颜色(#RGB &amp; #ARGB) .setLoadingWidth(120) // 设置 loading 的宽(dp) .setLoadingHeight(100) // 设置 loading 的高(dp) .setListener(listener) // 设置监听 .setDropView(activity_main) // 设置要挂载的 View(必须要设置)，一般是 Activity 或 Fragment 的根 View .setGifDrawable(R.drawable.loading4) // 设置 gif 资源 .setFocusable(false) // 为 true 时，响应返回键消失，为 false 时响应 activity 返回操作，默认为 false .setGifWidth(16) // 设置 gif 的宽(dp) .setGifHeight(16) // 设置 gif 的高(dp) .build(); 3.2 显示Loading1mLoadingView.show(); 3.3 取消Loading1mLoadingView.dismiss(); 4.支持的自定义设置 支持设置字体文案、及颜色和字体的大小； 支持设置文字距上的边距； 支持设置Loading的宽高； 支持设置Loading的圆角半径及背景颜色； 支持设置Loading的监听； 支持设置加载其他gif资源； 支持设置gif图片显示的宽高； 支持设置Loading的焦点； … 好了，今天的分享就到这里，需要下载 Demo 的请点击 「阅读原文」！ 猜你喜欢：深入浅出Retrofit2.x(一)深入浅出Retrofit2.x(二)不得不会的10点Java基础知识Android 最全 Intent 传递数据姿势 欢迎扫码关注我的公众号]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Loading</tag>
        <tag>View</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最接地气的 Android 面经总结]]></title>
    <url>%2F2018%2F07%2F08%2F%E6%9C%80%E6%8E%A5%E5%9C%B0%E6%B0%94%E7%9A%84Android%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[由于个人原因，从北京转战上海来工作，从来到上海到找到工作差不多经历了一周的时间，接下来我会将面试的准备及过程中的一些问题，还有一些注意的点与大家进行分享。 1.面试准备面试的准备特别重要，一方面的话先需要把面试时一些常问的知识点必须要搞清楚，一些基础知识也要过一下。因为我当时人还没到上海，打算的是周日晚上到上海，然后周一开始面试，所以我是提前投了一些简历，然后已经排了几家公司的面试，从周一一直往后排，每天至少有一家公司的面试机会，等到来上海之后就可以直接去面试了。你到上海来之后肯定需要找一个落脚的地方，你可以先找朋友那边先暂住一下，或者是找一些可以短租的 APP，我是不太建议到朋友哪里住，因为朋友的话，见了面肯定会一起吃吃饭、聊聊天，因为长时间不见可能会聊个没完没了。如果朋友上班的话，也会影响上班，也不方便自己做一些面试准备什么的。为什么要推荐短租 APP 呢？因为我之前想着也是住酒店，然后我在网上查了一下价格，一线城市的酒店确实比较贵，而短租 APP 上的房子住一晚上平均也就 100 多，价格上比较划算，基本上都是民宿的房子，个人的房子比较多一些，我找的还算可以把，比较安静，睡着也比较舒服吧，另外也可以做一些面试前的准备。 在这期间也陆续接到好多公司的面试电话，基本上，我每天都是安排两家公司去面试，上午一家，下午一家，我建议不要安排太多，因为安排太多可能会导致时间比较紧张，有可能两家面试的公司距离比较远，你要面试完一家又要赶去另一家，所以我觉得每天面两家公司比较合理一些，也比较轻松一些吧。在面试的前一天晚上，你需要查一下去面试公司的路线，公交或者地铁，我建议能坐地铁的还是坐地铁吧，公交有时候会堵车，到时候堵车了你干急也没什么办法；然后我建议面试尽量提前半个小时到，这样不仅可以应对一些突发情况导致耽误时间，另一方面可以给面试的公司留下一个比较好的印象，然后计算好路程的花费时间，定好闹钟，然后就早早休息。另外还需要准备一些东西，如充电宝、纸巾、水等。充电宝的话用处就比较大了，因为你面试的时候一般都是通过手机去查路线导航过去的，所以手机也比较费电，这样可以防止手机没电，找不到地方影响面试，另外在公交或地铁上也会用手机，我一般在路上喜欢听歌，然后看一些面试题或者一些问题，听歌可以舒缓一下心情，其实，只要你准备的比较充分了，自然也就没什么可紧张的了。 2.公司筛选一般在面试时，我们会在好几个平台投递简历，我一般喜欢用 智联、拉钩、BOSS 等平台，期间你会接到好多公司的面试邀请电话，这些公司大都参差不齐，所以我们需要做一些筛选。这样我们就可把精力放在你中意的公司，不中意的就没有必要去面试浪费时间了。大致上，基本可以分为以下几类：初创公司、外包公司、创业了几年的公司、还有一些上市公司。由于我之前的公司就是创业公司，被坑了，所以这次果断把创业公司给筛掉了，另外一个就是外包公司了，我基本也是拒绝的，因为外包的话，好多打电话过来说是外派性质的，这种的话一是钱给不到位，另一个就是不稳定，有的明确说了，说项目干完之后自己安排工作，相当于干完活把你就扔了，基本上其他福利待遇也没有，工作时你会感觉两边不是人吧。所以我建议大家还是找相对发展成熟一点的公司吧，这样的公司工资还有其他福利待遇方面也是有保障的。另一个筛选的条件就是根据自己喜欢和擅长的方向来选一些公司，最好还是选一些有自己产品或者做自己产品的公司比较好，最好的是产品已经上市并且有一定的用户量，这样的产品算是比较成熟了，也相对有发展前途。 3.面试过程一般你到面试的公司，都会先让你填写一张应聘人员登记表，主要包含一些个人信息，工作经历、期望薪资等信息，我认为这个只是走个流程，一些个人信息完全没必要写的很详细，一是因为你还不一定到这个公司工作，另外一些个人信息简历中也是有的，不想填的可以不用填的太仔细。 一般面试的话，先是技术面你，也就是将来和你一起工作的同事面你，一般也会问一些比较细致的技术问题，和开发中比较常见的一些问题，基本都是比较基础的东西，没有太大难度，如果你们聊的可以的话，接下来的就是技术主管来面你。 主管的话，基本不会问太具体的技术点，大多会问你们开发中如何协作，如何解决问题等一些比较常见的问题，则更多的是看中你的表达能力，解决问题的能力及你的沟通协作能力，我觉得和主管聊的话，首先要有礼貌，不要打断他的讲话，另外一个就是要表现的比较自信，有活力一些，这样才能留一个好印象，更多的就是聆听吧，不要怼就行了。如果主管觉得满意的话，最后他会让人事和你谈薪资及待遇情况。 我第一家面试的公司是一个创业公司，严格说是一个建筑公司旗下的子公司，相当于母公司的研发团队，子公司服务于母公司，面试的时候先是技术的面，问了一些简单的技术问题，没有什么深度，然后他觉得我还可以，我时不时的也反问他一些问题，他可能感觉到有些被我的一些问题给问住了，然后就对我说，你这3、5年工作经验的也没啥可问的，问基础就有些太没意思了，他就撤了。我建议大家在面试的时候不要一味的被别人带领着走，你也可以适当的找机会去询问他一些问题，将带领全掌握在自己的手中，这样你可以往你比较擅长的地方扯了。 然后是技术老大面，他看着我的简历问了一些开发中的问题，以及做项目的情况，也基本没啥深度和难度，过了一会，他去找人事谈了一下，然后他回来就开始跟我谈薪资了，我靠，这速度有点快呀！慌得一批。。。 因为我之前做的东西也是比较偏硬件的，然后和他们公司做的东西也是比较接近的，然后他就直接和我谈薪资了，想录用我，这种情况下，我就不急了，因为决定权现在在自己手里，这时候工资建议大家要高一些。然后他又跟我谈各种福利待遇啥的，因为是创业公司嘛，我就知道一些福利待遇啥的基本没有，和他在谈话的过程中，了解到公司的技术团队都还没有招齐，谈话过程中听他说的意思就是创业公司，加班还是要加的，但是福利待遇因为公司制度问题，现在什么都没有，也就是说白加班，还说没有的都没有，大家都一视同仁，狗屁啊，跟我谈什么公平？我又不是免费的劳动力，凭什么啊！心里顿时有一万句：“mmp”，接下来就是大部分创业公司骗人的小把戏，专业画饼，给你画未来的大饼，各种福利待遇，肯定不会亏待你的，其他公司有的我们也都有，然后就是期权、股份等这些东西，这些可能对于刚工作的小伙伴可能能骗的了，对于工作几年的人来说，基本都不吃这一套，都是嘴上功夫。立马对这家公司没了兴趣，然后问我什么时候来上班，要跟我确定一下，我也有些不耐烦了，就说我回去再想一下再回复你吧，我推辞说我还有其他面试，然后就走了。到了下午，人事发消息问我，我直接果断给拒了，这种创业公司很明显不靠谱，建议大家不要犹豫，工资给的再高，也不要去！都是血淋淋的教训。 然后第二家公司面试的是一家上市公司，主要是做医疗方面的，公司也比较大，面我的是一个Android 工程师和技术主管，问的问题也是一些面试中频率比较高的问题，例如 Handler 机制、自定义 View 等，难度一般，还有一些开发中常见的问题，回答的中规中矩吧，有几个问题我自认为回答的不是很好，面完之后给我说，让我等消息吧，他说 3-5 天内给我答复，一般来说，这种话大部分情况下也就是没戏，只是没有当面拒绝你而已，我也感觉也是 GG 了，结果等到下午的时候，他们又联系我了，跟我谈了一下待遇，问我什么时候来上班，感觉有点意外，就这样这家公司决定录用我了。 第三家面试的公司是一家中型的公司，先是让我做了一份笔试题，还有一些情景测试类的题目，笔试题也比较简单，做完之后等了一会，然后是技术面，一个做 Android 的哥们，应该比我也大不了几岁，看着我的简历，问了我一些技术问题，也比较简单，我们之间聊得也比较轻松、愉快，更多的是相互交流不像是面试，这样使我们双方都比较轻松，我认为好的面试应该就是这样的，相互之间交流，交流的过程中穿插着一些技术的问题，我不喜欢一问一答那种比较刻板的面试方式。最后他感觉我还可以，我等了一会，接下来是技术主管面，技术主管是一个比较幽默的人，从一开口到面试的过程中，他的幽默会时不时的把你逗笑，面试的气氛也轻松、愉快，但是具体的技术问题他也会穿插着问一些，总的来说，感觉他和大部分的技术人不太一样，情商比较高，特别会说话，能感觉到你情绪的变化，然后适当的调节面试的气氛，而且技术层面也都问到了，从交流的过程中，了解到他是一个十几年的老程序员了，因为从他们那个年代过来的程序员基本都是从底层到上层，从软件到硬件，编程语言至少也会十几种，从汇编到高级语言，所以从他们的技术高度层面来看我现在简历上的很多技术，说白了就是会使用开发工具、会调用 api 而已，不懂底层，说白了其实没有啥技术含量，确实我也感觉到了一些不足的地方，例如没有核心竞争力，当然他也给我了一些建议，中间我们也聊了很多，给我指点了很多，确实我从这次面试中，感受到一些不一样的想法，让我更加了解到了自己的不足，让我受益匪浅。后来他看我也比较实在，然后就跟我谈了一下工资待遇啥的，谈完之后，问我什么时候来上班，我说我回去考虑一下吧，然后我就走了。总体来说还算比较满意吧，除了工资给的低一点。 后续，我又面了两家公司，一家公司面了几分钟不到就走人了(一个十几年经验的老鸟问了我几个比较深的问题，都没有答上来)，说是让我等消息，其实也就是 GG 了。另一家公司还可以，不论从公司的环境还是其他方面都还可以，公司有自己成熟的产品，看了他们的 APP 也没什么技术难度，3 个人开发一个APP，平时估计也是比较闲的那种，后来聊的也比较满意，最后让我去，我后来考虑了一下，没有接受，一方面是考虑到技术提升不是很大，另一方面因为比较闲到时候怕会废掉，所以就没去。 3 天内总共面试了 5 家，成了 4 家，还算可以，我目前选了一个比较稳定的公司。 4.如何谈薪一般情况下，公司招聘的岗位它会有一个薪资的范围，另外一个就是面试过程中，会根据你的表现及回答问题等也会有个基本的薪资定位，技术一般也会给人事参考。所以，你和人事在谈的时候你心里也肯定比较清楚自己的期望薪资及自己面试时的表现，一般来说，你第一口说出的薪资特别重要，所以，当你说完之后基本就可以理解为是你要的工资的顶端了，这个时候如果你要往上加的话就比较困难了，所以说，能要高点还是尽量往高要，如果公司决定要你了，这些都是可以谈判的，大不了都让步一下，你拿到手的工资也是应该让你比较满意的，另外你也可以问一下人事，公司的福利待遇及补助的情况，有的公司工资虽说比其他公司稍微低一点，但是其他待遇方面就比较优厚了，你可以对比一下，也要问清楚年终奖等福利，还有就是五险一金等缴纳的基数不同，拿到手的工资也不同，有的公司是按最低基数交的，有的公司是按全额交的，这样你就可以大致算出自己的薪资了，以便于自己更好的比较和做决定！ 另外，谈工资的时候最好不要含糊，不要觉得不好意思，建议大家还是要个具体的数字，尽量往高要，但不那种离谱的高，在自己能力水平工资的基础上高一些就行了，不要给一个范围，更不要说就按市场水平给吧，因为市场水平的有高有低，到时候按最低的发给你就傻了！ 5.面试总结从这几天面试的过程来看，也发现了一些问题，对于个人来说，必须要有自己的核心竞争力，也就是说某一项技能特别强或者精通，或者说别人没有的技能而你有，这样你就可以在面试的时候比别人更有竞争力了，当然也可以要一个好价钱！另外一方面我们在自己的技术领域必须要深入学习，多了解一些底层的原理机制，多阅读一些源码，了解其设计的思想。另外最好利用空闲时间学一些其他的开发语言或者是技能，不要局限于自己的领域，这样如果以后这个技能没饭吃了，可以有其他技能混口饭吃，也就是说需要培养自己的第二技能，不断拓展自己的技术栈。 好了，今天就分享这么多，如果大家有什么好的想法都可以在下方评论与我交流。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Android</tag>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不得不会的10点Java基础知识]]></title>
    <url>%2F2018%2F06%2F23%2F%E4%B8%8D%E5%BE%97%E4%B8%8D%E4%BC%9A%E7%9A%8410%E7%82%B9Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[1.实例变量和类变量实例变量：指每个对象独立的，修改其中一个对象的实例变量，不会影响其他实例变量的值，变量值无 static 关键字修饰； 类变量：是指所有对象共享的，其中一个对象把该变量的值修改了，那么所有对象的该变量的值都修改了，使用 static 关键字修饰，一般使用 「类名.属性」 来访问； 2.静态方法和非静态方法静态方法：是指使用 static 关键字修饰修饰的方法，一般使用 「类名.方法」 来访问，也可以通过 「对象.方法」 来访问，但是不建议这样写！静态方法中只能调用静态方法和使用静态成员，因为静态成员和静态方法会随着类的加载而加载，非静态成员或者方法的加载晚于静态的成员和方法，故静态方法不能调用非静态的方法和非静态的成员，即静态的对静态的； 非静态方法：是指没有使用 static 关键字修饰修饰的方法，一般使用 「对象.方法」 来访问，非静态方法中即可调用非静态方法和使用非静态成员也可以调用静态方法和使用静态成员； 3.Java 中包的作用在 Java 中，包的声明一般写在文件的第一行，使用关键字 package + 包名，其作用有：①避免重名，例如我们有时候在调用某个类的某个方法时会发现会有相同类名的方法，这时候你就要导入你要调用的类所在的包或者使用全类名调用即可，这样避免了重名；②用于权限控制，在同一个包下的类是可以相互调用的，如果调用其他包下的类，就必须要导入调用类所在的包，这样可以避免外部的非法调用，另外还可以合理的使用访问控制权限的关键字 public、protected、private 来进行访问权限的设置（更多各关键字权限控制参考附表1）；③划分项目结构层次，使得文件管理更有条理，例如MVC、MVP模式分包； 4.Java 中的静态导入静态导入是 JDK1.5 引入的新特性，一般情况下，我们调用某个类中的静态成员或静态方法使用 「类名.属性」 来调用，而静态导入可以把某个类下的静态成员(方法和变量)使用类似导包的方式导入进来，即可以直接导入到类的成员级别(方法和变量)，这样可以使被导入类的静态变量和静态方法在当前类直接可见，使用这些静态成员无需使用 「类名.属性」 的方式来调用，直接调用方法名或者属性，像调用自己类中的方法和属性一样简单。 静态导入的语法是： import static 包名.类名.静态成员变量; import static 包名.类名.静态成员函数; 注意导入的是静态成员变量和方法名，另外也可导入某个类下的所有静态成员： import static 包名.类名.*; *号代表通配所有。 一般情况下我们可以适度的使用静态导入，不建议大量滥用，因为我们知道 Java 是面向对象的语言，使用静态导入调用时，缺少了类名，即弱化了类的描述，有时候我们不知道调用的是哪个类的成员，可能还会思考一番，弱化了面向对象思想，导致类和类之间的调用关系不清晰！ 5.Java 中的 this 关键字在 Java 中，当创建一个对象后，Java 虚拟机就会为其分配一个指向对象本身的指针，这个指针就是 this 。this 的使用场景：①当方法的布局变量和与实例变量重名时，需要使用 this 关键字来区分，如果不重名也可以使用，通常不重名的情况下不写 this；②使用 this.方法名(参数); 来调用类的成员方法，一般情况下不写 this，直接调用；③使用 this(参数1…); 来调用本类中的其他构造方法，例如在 Android 中自定义一个 View，一般都会写 3 个重载的构造方法，单参数的构造方法中使用 this(参数1, 参数2); 来调用双参数的构造方法，双参数的构造方法中调用三个参数的构造方法；④ this 作为参数传递，在 Android 的 Activity 中，经常会使用 this 来作为参数传递；⑤在内部类或者匿名内部类中调用外部类的方法，如果在内部类中使用 this，这里的 this 代表的是当前类本身，即内部类，要想调用外部类中的方法必须使用 外部类名.this.方法名(); 来调用； 另外使用this关键字要注意一下几点： 在构造方法中使用 this 调用另一构造，必须要将调用放在方法的第一句且只能使用一次； 不能再实例方法中使用this 来调用构造，因为实例方法的调用必须要有对象，而对象的创建一定会调用构造方法，构造方法的调用应早于实例方法； 在构造中不能使用 this 来相互调用构造，例如，如果在单参数的构造中调用双参数的构造，在双参数的构造中调用单参数的构造，我们使用单参数的构造来创建一个实例，调用过程为：单参数构造 -&gt; 双参数构造 -&gt; 单参数构造，这样会无穷无尽的调用下去，另外这违背了在一个方法的调用链中只能调用一次同一个参数的构造方法的规则； 6.Java 中的 super 关键字 super(); 调用的父类是 Object的无参构造，默认自动调用，一般情况下都省略不写； this 和 super 关键字都是为了解决重名问题的，如果没有重名问题可以省略不写； this 和 super 都可以理解为父类的一个引用，即可以调用父类中的属性和方法； super.方法名(); 表示调用父类的方法； super.属性 表示调用父类中的属性(用的不多)； super();调用父类的构造方法； this 和 super 都只能放在方法的第一行，所以不能一起出现； super 只能出现在构造方法中； 在 Java 中，所有类的父类都是 Object，如果一个类没有使用 extends 关键字来继承父类，那么它默认继承的是 Object 类，子类不会继承父类的构造方法，但是一定会调用父类的构造方法，如果没有调用，必须要手动去调用，否则会编译报错； 7.Java 中的重载与重写重载即 Overload，在同一个类中，方法名相同参数列表不同的几个方法称为重载方法； 重写即 Override，在子父类中，子类与父类方法名称相同，参数列表必须相同；对于返回值类型子类要么和父类的一致，要么是父类返回值类型的子类；对于权限修饰符，子类的权限修饰符要么和父类的相同，要么比父类的权限修饰符更宽泛；如果有异常抛出，子类的异常捕获范围要么和父类的相同要么比父类的异常范围更小，即子类的异常是父类异常的子类； 8.== 与 equals关系操作符 “==” 生成的是一个boolean结果，它们计算的是操作数的值之间的关系，如果是基本数据类型，它比较的是他们值的本身，如果是引用数据类型，则比较的是对象在内存中的地址； equals 方法是基类 Object 中的方法，所有类都直接或间接继承于 Object类，因此所有类中都有该方法，如果没有重写 equals() 方法，调用 equals() 方法和使用 == 的效果一样，也是比较的内存中的地址值；在 Java 提供的大多数类中，如 String，Double，Date，Integer等，都对equals 方法进行了重写，用来比较指向的对象所存储的内容是否相等，如果是我们自己的定义的类，如果没有重写 equals 方法，使用 equals 默认比较的是对象在内存中的地址，要比较内容，就必须要重写 equals 方法。 9.对类的理解类是对一类事物的抽象描述，对象是类的实例，可以理解为类是汽车设计图，对象是实实在在的生产出来的汽车，一张设计图(类)可以生产出来多个汽车(对象)，类中包含属性和方法，属性描述了类所具有的特性，方法描述了类的具体功能，这样我们在设计类的时候就会更加注重某个类中的功能及特性，将他们抽象分装到类中，外部在调用的时候不需要关心类中的具体实现，这样就可以更多的考虑类与类之间的相互关系了，这样带来的好处就是可以提高对象的复用性，降低开发难度，多以所Java是面向对象的编程，即Everything is object. 对于面向对象的开发，一般来讲分为三个步骤：OOA（面向对象分析）、OOD（面向对象设计）、OOP（面向对象编程）。OOA 即根据具体的功能分析有哪些特性或者方法，OOD 即根据特性和方法抽象设计出具体的类；OOP 即建立类和类之间的相互调用的关联关系。 10.变量、内存和垃圾变量是内存中的一块存储区域，它的值是变化的，不是固定的; Java中的内存一般分为Java虚拟机栈和堆内存，栈中一般存放的是基本数据类型和引用类型的引用变量，堆内存中存放的是对象实例，Java堆是 Java 虚拟机所管理的内存中最大的一块，它是被所有线程共享的一块内存区域，在虚拟机启动时创建，可以不是物理上的连续区域，只要逻辑上连续即可；另外还有方法区、静态常量池、程序计数器、本地方法栈等内存分配区域的概念； 垃圾：指的是没有任何引用所指向的对象(一块堆内存空间)，这块空间就是垃圾，所有的垃圾都会等待GC（垃圾收集器）不定期的回收(释放内存空间)。 更多干货文章关注我的微信公众号：]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iTunes备份到电脑 F 盘]]></title>
    <url>%2F2018%2F05%2F24%2FiTunes%E5%A4%87%E4%BB%BD%E5%88%B0%E7%94%B5%E8%84%91F%E7%9B%98%2F</url>
    <content type="text"><![CDATA[默认情况下，iTunes 会备份到电脑的 C 盘，当 C 盘快满的时候，iTunes 老是提醒空间不足，导致备份失败，iTunes 也不可以设置将其备份到其他盘，但是我们可以想办法将其备份到其他盘，以前 Android 手机刚出来的时候，我们的手机配置都比较低，后来由于 APP 越来越大，装的越来越多，后来导致内存不足，安装不了应用，后来使用终端命令 ln -s 将 APP 安装目录映射（软连接） /data/app/ 到 SD 卡的某个目录，这样就解决了内存不足的情况，实现软件装到的是 SD 的目录，主要讲 SD 分出一部分格式化成 ext 日志文件系统，我们都知道 SD 卡都有寿命的，即读写的次数是有限的，这样做会降低手机 SD 卡的寿命，但是没关系，我们用时间换空间。 继续文章开头的问题，我们想 iTunes 的备份目录是不是也可以这样做呢？答案是可以的。 我们找到默认的 iTunes 的备份目录： 我的是： 1C:\Users\Administrator\AppData\Roaming\Apple Computer\MobileSync\Backup\ 在 Backup 目录下你会看到已经备份的一些文件，没关系，我们在其他盘新建一个文件夹，例如就叫：”F:\iTunes_backup” 吧，我们可以先将原来目录备份的文件移动到新建的目录下面，因为这样的话之前已经备份的还在，再次备份时就不用子再从 0 开始备份了，然后我们使用快键键：win + R 打开 window 运行，输入 cmd 打开 ms shell ,输入如下命令： 1mklink /D &quot;C:\Users\Administrator\AppData\Roaming\Apple Computer\MobileSync\Backup&quot; &quot;F:\iTunes_backup&quot; 然后回车，即建立目录映射链接，相当于是一个快捷方式。 如果执行命令的时候提示 “当文件已存在时，无法创建该文件。” 意思就是已经存在 Backup 目录了，所以先应该把原目录的Backup 目录删掉，因为这个链接就是要创建一个快捷方式，然后再次执行即可。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>iTunes</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7 重置 MySQL 8.0 密码]]></title>
    <url>%2F2017%2F12%2F24%2FCentOS7%E9%87%8D%E7%BD%AEMySQL8.0%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[上一篇文章我们已经讲完了 MySQL 的安装，本篇接下来将一下如何重置密码。 1.查看自动生成的密码 安装完成后 MySQL会给我们自动生成一个随机密码 查看命令如下： 1grep &apos;temporary password&apos; /var/log/mysqld.log 因为自动的生成的密码无法直接使用，也不便于我们记忆，所以我们要修改密码。 2.配置文件 MySQL 免密码登录 编辑 MySQL 的配置文件 1vim /etc/my.cnf 在 pid 开头的下面一行加入下面这句 1skip-grant-tables 保存并退出。 3.重启 MySQL 服务 1service mysqld restart 4.免密码登录到 MySQL 上 1mysql -u root -p 提示输入密码时直接敲回车。 5.选择 mysql 数据库 1use mysql; 因为 mysql 数据库中存储了一张 MySQL 用户的 user 表 6.在 mysql 数据库的 user 表中查看当前 root 用户的相关信息 1select host, user, authentication_string, plugin from user; 执行完上面的命令后会显示一个表格 表格中有以下信息： host: 允许用户登录的 ip ‘位置’ % 表示可以远程； user: 当前数据库的用户名； authentication_string: 用户密码（在mysql 5.7.9以后废弃了password字段和password()函数）； plugin： 密码加密方式； 7.将默认的 root 密码置空 12use mysql; update user set authentication_string=&apos;&apos; where user=&apos;root&apos;; 8.退出 mysql命令行 1quit 9.删除 /etc/my.cnf 文件最后的 skip-grant-tables 1vim /etc/my.cnf 删除 skip-grant-tables 并保存退出。 10.重启 MySQL 服务 1service mysqld restart 11.重新登录到 MySQL 上 1mysql -u root -p 提示输入密码时直接敲回车，因为我们刚才已经将密码置为空了。 12.使用 ALTER 修改 root 用户密码 1ALTER user &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;Xpf123@&apos;; 其中 Xpf123@ 为你设置的新密码，注意这个密码如果设置的比较简单，例如 123456 等等，会设置不成功，它会提示你设置的密码太简单，最好设置成大写字母、数字、符号的组合。 执行完之后会提示你 OK 的话，就代表修改成功了，至此重置密码也就算是完了，你可以使用新设置的密码去登录试试。 可能很多同学在修改的密码中遇到了很多问题，例如装的是 MySQL 8.0，然后去重置密码，还是用的旧的命令去修改密码，导致报错，因为 MySQL 5.7.6 以后废弃了 user 表中的 password 字段和 password() 方法，所以使用旧的方法去重置密码对 mysql 8.0 是不行的！ 好了，今天的讲解就到这里吧。 如果大家有什么问题，请在下方留言！]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 加载 GIF 图片的两种方式]]></title>
    <url>%2F2017%2F09%2F24%2FAndroid%E5%8A%A0%E8%BD%BDGIF%E5%9B%BE%E7%89%87%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[##方式一：使用第三开源框架直接在布局文件中加载gif ###1.在工程的build.gradle中添加如下 12345678910buildscript &#123; repositories &#123; mavenCentral() &#125; &#125; allprojects &#123; repositories &#123; mavenCentral() &#125; &#125; ###2.在app的build.gradle中添加依赖 'pl.droidsonroids.gif:android-gif-drawable:1.2.1'```12###3.布局文件中就可以直接写你需要加载的gif图片即可 &lt;pl.droidsonroids.gif.GifImageView android:layout_width=”wrap_content” android:layout_height=”wrap_content” android:src=”@drawable/gif2” /&gt;12345678##方式二：使用Glide加载gif这种方式就比较简单了，直接看代码↓###1.添加Glide图片加载框架依赖```compile &apos;com.github.bumptech.glide:glide:3.7.0&apos; ###2.布局文件中写一个普通的Imageview 1234&lt;ImageView android:id=&quot;@+id/ivGif&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; /&gt; ###3.代码中直接加载本地的gif图片到Imageview上即可 12Glide.with(MainActivity.this).load(R.drawable.gif1) .diskCacheStrategy(DiskCacheStrategy.ALL).into(ivGif); 以上就是加载gif图片的两种方式，我写的都是加载本地的gif，加载网络的gif图片应该也差不多一样，自己尝试吧… 代码比较简单，为了照顾初学者，需要的同学 下载 Thanks all. 2017.5.30日 农历：五月初五 端午节 最后祝大家端午节快乐！！！大家记得吃粽子哦 ：)]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Android</tag>
        <tag>GIF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 删除指定路径下指定前缀或后缀的文件]]></title>
    <url>%2F2017%2F09%2F24%2FAndroid%E5%88%A0%E9%99%A4%E6%8C%87%E5%AE%9A%E8%B7%AF%E5%BE%84%E4%B8%8B%E6%8C%87%E5%AE%9A%E5%89%8D%E7%BC%80%E6%88%96%E5%90%8E%E7%BC%80%E7%9A%84%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[微信公众号：CodingAndroidCSDN：http://blog.csdn.net/xinpengfei521声明：本文由 CodingAndroid 原创，未经授权，不可随意转载！ ##需求 我们在开发中都会遇到这样的一个需求：删除指定目录下指定的前缀或者后缀文件名的文件。 ##实现思路 对外暴露三个参数，参数一：要删除的文件目录的路径，参数二：区分是前缀还是后缀，参数三：具体前缀或者后缀字符规则。 先枚举出路径目录下的所有文件，枚举的同时实现一个FilenameFilter接口的类，可以自定义规则，比说前缀、后缀或者其他规则，枚举的同时将我们的过滤器作为参数，这样我们就可以匹配到指定条件的文件，然后删除即可。 ##实现一个删除逻辑的Runnable 代码实现的逻辑也比较简单，大家都能看得懂，下面我就直接贴代码了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package com.xpf.deletedemo;import android.support.annotation.NonNull;import android.text.TextUtils;import android.util.Log;import java.io.File;import java.io.FilenameFilter;/** * Created by xpf on 2017/12/25 :) * Function:删除指定规则的文件 */public class DeleteRunnable implements Runnable &#123; private String mRegEx; private String dirPath; private boolean isPrefix; private static final String TAG = DeleteRunnable.class.getSimpleName(); /** * Constructor * * @param dirPath 要删除文件所在的目录路径 * @param isPrefix true为前缀 false为后缀 * @param mRegEx 规则 */ public DeleteRunnable(String dirPath, boolean isPrefix, String mRegEx) &#123; this.mRegEx = mRegEx; this.dirPath = dirPath; this.isPrefix = isPrefix; &#125; @Override public void run() &#123; enumAllFileList(); &#125; /** * 枚举并删除所有符合条件(前缀)的文件 */ private void enumAllFileList() &#123; if (!TextUtils.isEmpty(dirPath)) &#123; File adDir = new File(dirPath); if (adDir.exists() &amp;&amp; adDir.isDirectory()) &#123; if (!TextUtils.isEmpty(mRegEx)) &#123; DeleteFileFilter filter = new DeleteFileFilter(isPrefix, mRegEx); // 2.匹配是否是需要删除的文件 File[] fileList = adDir.listFiles(filter); if (fileList != null &amp;&amp; fileList.length &gt; 0) &#123; for (File file : fileList) &#123; if (file.isFile() &amp;&amp; file.exists()) &#123; boolean delete = file.delete(); Log.i(TAG, &quot;删除符合条件前缀的旧广告素材&quot; + (delete ? &quot;成功~&quot; : &quot;失败！&quot;)); &#125; &#125; &#125; &#125; &#125; &#125; &#125; /** * Created by xpf on 2017/12/25 :) * Function:以xxx开头或后缀的文件名的过滤器 */ class DeleteFileFilter implements FilenameFilter &#123; private boolean isPrefix; private String mRegEx;// 前缀或后缀规则 public DeleteFileFilter(boolean isPrefix, @NonNull String regEx) &#123; this.isPrefix = isPrefix; this.mRegEx = regEx; &#125; @Override public boolean accept(File file, String s) &#123; return isPrefix ? s.startsWith(mRegEx) : s.endsWith(mRegEx); &#125; &#125;&#125; ##定义文件删除的异常操作工具类 因为操作文件属于耗时操作，我们使用 SingleThreadExecutor 线程池实现如下一个工具类 1234567891011121314151617181920/** * Created by xpf on 2017/12/25 :) * Function: */public class DeleteUtil &#123; private static final ExecutorService executor = Executors.newSingleThreadExecutor(); /** * 删除指定目录指定前后缀的文件 * * @param dirPath * @param isPrefix * @param regEx */ public static void delete(String dirPath, boolean isPrefix, String regEx) &#123; executor.execute(new DeleteRunnable(dirPath, isPrefix, regEx)); &#125;&#125; ##举例 例如我们要删除要删除SD卡下的Download目录下的所有以.png后缀结尾的文件，只需要这样写： 1DeleteUtil.delete(&quot;/sdcard/Download/&quot;, false, &quot;.png&quot;); 是不是感觉很方便，0.0~ 可以收藏了，以后当工具类来使用。 如果有不懂的地方或者不对的地方，欢迎评论交流，谢谢！ 最后附上下载Demo的地址:http://download.csdn.net/download/xinpengfei521/10172262 若在使用过程中遇到什么问题，或有好提议，欢迎在公众号“CodingAndroid”中提出]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 实现密码隐藏显示]]></title>
    <url>%2F2017%2F09%2F24%2FAndroid%E5%AE%9E%E7%8E%B0%E5%AF%86%E7%A0%81%E9%9A%90%E8%97%8F%E6%98%BE%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[需求：当用户点击提现按钮的时候，弹出输入支付密码的popupwindow,输入密码框后面有显示和隐藏支付密码的切换按钮。 老规矩先验货： ##1.布局文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;LinearLayout android:layout_width=&quot;275dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_centerInParent=&quot;true&quot; android:background=&quot;#FFFFFF&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:id=&quot;@+id/tvRecharge&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;16dp&quot; android:gravity=&quot;center&quot; android:text=&quot;支付密码验证&quot; android:textSize=&quot;18sp&quot; /&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;10dp&quot; android:background=&quot;#11000000&quot; android:gravity=&quot;center_vertical&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;EditText android:id=&quot;@+id/etPayPwd&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_weight=&quot;1&quot; android:background=&quot;@null&quot; android:hint=&quot;输入支付密码&quot; android:inputType=&quot;textPassword&quot; android:padding=&quot;10dp&quot; android:paddingRight=&quot;10dp&quot; /&gt; &lt;ToggleButton android:id=&quot;@+id/togglePwd&quot; android:layout_width=&quot;20dp&quot; android:layout_height=&quot;20dp&quot; android:layout_marginRight=&quot;10dp&quot; android:background=&quot;@drawable/toggle_pwd_selector&quot; android:padding=&quot;10dp&quot; android:textOff=&quot;&quot; android:textOn=&quot;&quot; /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;TextView android:id=&quot;@+id/tvCancel&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;48dp&quot; android:layout_weight=&quot;1&quot; android:gravity=&quot;center&quot; android:text=&quot;取消&quot; android:textSize=&quot;16sp&quot; /&gt; &lt;TextView android:id=&quot;@+id/tvConfirm&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;48dp&quot; android:layout_weight=&quot;1&quot; android:gravity=&quot;center&quot; android:text=&quot;确定&quot; android:textSize=&quot;16sp&quot; /&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt;&lt;/RelativeLayout&gt; ##2.代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class MainActivity extends AppCompatActivity &#123; private PopupWindow popupWindow; private View popupView; private EditText etPayPwd; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button btnWithdraw = (Button) findViewById(R.id.btnWithdraw); btnWithdraw.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; showPayPwdDialog(); BrightnessManager.lightOff(MainActivity.this); &#125; &#125;); &#125; private void showPayPwdDialog() &#123; if (popupWindow == null) &#123; popupView = View.inflate(MainActivity.this, R.layout.popupwindow_pay_pwd, null); popupWindow = new PopupWindow(popupView, WindowManager.LayoutParams.MATCH_PARENT, WindowManager.LayoutParams.MATCH_PARENT); popupWindow.setOnDismissListener(new PopupWindow.OnDismissListener() &#123; @Override public void onDismiss() &#123; BrightnessManager.lightOn(MainActivity.this); etPayPwd.setText(&quot;&quot;); &#125; &#125;); popupWindow.setBackgroundDrawable(new BitmapDrawable()); popupWindow.setFocusable(true); popupWindow.setOutsideTouchable(true); ToggleButton togglePwd = (ToggleButton) popupView.findViewById(R.id.togglePwd); etPayPwd = (EditText) popupView.findViewById(R.id.etPayPwd); togglePwd.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() &#123; @Override public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) &#123; if (isChecked) &#123; //如果选中，显示密码 etPayPwd.setTransformationMethod(HideReturnsTransformationMethod.getInstance()); &#125; else &#123; //否则隐藏密码 etPayPwd.setTransformationMethod(PasswordTransformationMethod.getInstance()); &#125; &#125; &#125;); popupView.findViewById(R.id.tvCancel).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; popupWindow.dismiss(); BrightnessManager.lightOn(MainActivity.this); &#125; &#125;); popupView.findViewById(R.id.tvConfirm).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; String payPwd = etPayPwd.getText().toString(); popupWindow.dismiss(); BrightnessManager.lightOn(MainActivity.this); if (!TextUtils.isEmpty(payPwd)) &#123; Toast.makeText(MainActivity.this, &quot;提现请求提交成功！&quot;, Toast.LENGTH_SHORT).show(); &#125; &#125; &#125;); &#125; if (popupWindow.isShowing()) &#123; popupWindow.dismiss(); BrightnessManager.lightOn(MainActivity.this); &#125; popupWindow.showAtLocation(MainActivity.this.findViewById(R.id.activity_main), Gravity.BOTTOM | Gravity.CENTER_HORIZONTAL, 0, 0); &#125;&#125; OK！今天双11，马云硬是将光棍节过成了购物狂欢节，你让我们这些光棍儿们怎么想？好吧，与我们没关系，咱们继续撸咱们的代码，为了早日迎娶白富美，走向人生巅峰，继续撸不要停！！！]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Android</tag>
        <tag>popupwindow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 截屏的几种实现]]></title>
    <url>%2F2017%2F09%2F24%2FAndroid%E6%88%AA%E5%B1%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[##方式一 12345public static Bitmap capture(Activity activity) &#123; activity.getWindow().getDecorView().setDrawingCacheEnabled(true); Bitmap bmp = activity.getWindow().getDecorView().getDrawingCache(); return bmp; &#125; 此种方式比较简单只需传入当前要截取屏幕的Activity对象即可，不需要添加任何权限，后续可将截图的bitmap保存到本地即可； 缺点：无法截取WebView页面，截屏后是白屏！ ##方式二 使用adb Shell命令截屏 例如： shell screencap -plink12345678910命令格式：adb shell screencap -p + 文件路径 + 文件名##方式三从Android 5.0开始 Google开放了截屏的api截取方式如下：1.在Activity中开启截屏服务 if (Build.VERSION.SDK_INT &gt;= 21) { startActivityForResult( ((MediaProjectionManager) getSystemService(&quot;media_projection&quot;)).createScreenCaptureIntent(),1); } else { Log.e(&quot;TAG&quot;, &quot;版本过低,无法截屏&quot;); } 122.重写**onActivityResult**方法 @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { super.onActivityResult(requestCode, resultCode, data); switch (requestCode) { case REQUEST_MEDIA_PROJECTION: { if (resultCode == -1 &amp;&amp; data != null) { parseData(data); } } } } private void parseData(Intent data){ MediaProjection mMediaProjection = (MediaProjectionManager).getSystemService( Context.MEDIA_PROJECTION_SERVICE).getMediaProjection(Activity.RESULT_OK,data); ImageReader mImageReader = ImageReader.newInstance( getScreenWidth(), getScreenHeight(), PixelFormat.RGBA_8888,1); VirtualDisplay mVirtualDisplay = mMediaProjection.createVirtualDisplay(&quot;screen-mirror&quot;, getScreenWidth(), getScreenHeight(), Resources.getSystem().getDisplayMetrics().densityDpi, DisplayManager.VIRTUAL_DISPLAY_FLAG_AUTO_MIRROR, mImageReader.getSurface(), null, null); Handler handler = new Handler(); handler.postDelayed(new Runnable() { @Override public void run() { Image image = mImageReader.acquireLatestImage(); // TODO 将image保存到本地即可 } }, 300); mVirtualDisplay.release(); mVirtualDisplay = null; } ` 更多参考文章： http://www.jb51.net/article/119881.htm https://www.2cto.com/kf/201602/488933.html http://blog.csdn.net/buptgshengod/article/details/39155979 下面这个库封装了cmd截屏和5.0以上的截屏： https://github.com/Android-ScreenShot/AndroidScreenShotService]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Android</tag>
        <tag>截屏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 实现多语言 so easy]]></title>
    <url>%2F2017%2F09%2F24%2FAndroid%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%AF%AD%E8%A8%80so%20easy%2F</url>
    <content type="text"><![CDATA[微信公众号：CodingAndroidCSDN：http://blog.csdn.net/xinpengfei521声明：本文由CodingAndroid原创，未经授权，不可随意转载！ &#160; &#160;&#160; &#160;最近，我们公司的业务已经拓展到了香港，我们都知道香港使用的是繁体中文，因此，我们的 APP 要可以设置繁体语言，这不我们要紧跟国际的步伐，实现多语言，产品定给我们的需求主要以实现简体中文、繁体中文、英文三种语言切换即可，具体的业务逻辑是：当用户第一次进入 APP 时，App 的语言跟随当前系统语言，当用户设置了某种语言之后就切换为用户设置的语言，不管系统之后设置成哪种语言，都不会影响用户设置的语言，如果用户一直没有设置语言选项，只要系统语言改变时，APP 的语言也要跟随系统语言设置改变。 &#160; &#160;&#160; &#160;说明：本文以实现简体中文、繁体中文和英语为例进行简要讲解。 ##1.实现思路 &#160; &#160;&#160; &#160;我们可以预先使用SharedPreference 来保存一个语言类型的值，当用户第一次进入 APP 时，我们通过 Key 取出这个值，第一次肯定是取不到的，这时我们将 App 的语言设置为当前系统默认值即可；当用户通设置多语言时，我们将这个语言对应的值通过SharedPreference 保存到本地即可，然后此时重启 APP，设置为用户设置的语言即可，以后每次进入 App 时只需取出保存用户设置的语言设置即可，一般设置语言写在程序的入口 Application 的 onCreate() 方法里。 ##2.自定义SharedPreference工具类 &#160; &#160;&#160; &#160;作用：用于保存当前设置语言的类型，此文以 SharedPreference 保存为例，当然使用数据库或者其他保存方式也是可以的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/** * Created by xpf on 2017/03/25 :) * Function: sp存储的工具类 */public class SpUtil &#123; private static final String APP_SP = &quot;app_sp&quot;; private static final String TAG = SpUtil.class.getSimpleName(); private SpUtil() &#123; &#125; private static SpUtil instance = new SpUtil(); private static SharedPreferences mSp = null; public static SpUtil getInstance() &#123; if (mSp == null) &#123; mSp = MyApplication.getContext().getSharedPreferences(APP_SP, Context.MODE_PRIVATE); &#125; return instance; &#125; /** * 保存数据 * * @param key 键 * @param value 值 */ public void save(String key, Object value) &#123; if (value == null) &#123; Log.e(TAG, &quot;value==null保存失败&quot;); return; &#125; if (value instanceof String) &#123; mSp.edit().putString(key, (String) value).commit(); &#125; else if (value instanceof Boolean) &#123; mSp.edit().putBoolean(key, (Boolean) value).commit(); &#125; else if (value instanceof Integer) &#123; mSp.edit().putInt(key, (Integer) value).commit(); &#125; &#125; /** * 读取String类型数据 * * @param key * @param defValue * @return */ public String getString(String key, String defValue) &#123; return mSp.getString(key, defValue); &#125; /** * 读取boolean类型数据 * * @param key * @param defValue * @return */ public boolean getBoolean(String key, boolean defValue) &#123; return mSp.getBoolean(key, defValue); &#125; /** * 读取boolean类型数据 * * @param key * @param defValue * @return */ public int getInt(String key, int defValue) &#123; return mSp.getInt(key, defValue); &#125; /** * 清除所有保存的数据(xxx.xml仍然存在，但是内部没有数据) */ public void clearAll() &#123; mSp.edit().clear().commit(); &#125;&#125; ##3.自定义LocaleUtil工具类 &#160; &#160;&#160; &#160;作用：用于设置保存语言及获取当前语言，重启 APP 等操作 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180public class LocaleUtil &#123; /** * 获取用户设置的Locale * * @return Locale */ public static Locale getUserLocale() &#123; int currentLanguage = SpUtil.getInstance().getInt(&quot;currentLanguage&quot;, 0); Locale myLocale = Locale.SIMPLIFIED_CHINESE; switch (currentLanguage) &#123; case 0: myLocale = Locale.SIMPLIFIED_CHINESE; break; case 1: myLocale = Locale.ENGLISH; break; case 2: myLocale = Locale.TRADITIONAL_CHINESE; break; &#125; return myLocale; &#125; /** * 设置语言：如果之前有设置就遵循设置如果没设置过就跟随系统语言 */ public static void changeAppLanguage(Context context) &#123; if (context == null) return; Context appContext = context.getApplicationContext(); int currentLanguage = SpUtil.getInstance().getInt(&quot;currentLanguage&quot;, -1); Locale myLocale; // 0 简体中文 1 繁体中文 2 English switch (currentLanguage) &#123; case 0: myLocale = Locale.SIMPLIFIED_CHINESE; break; case 1: myLocale = Locale.TRADITIONAL_CHINESE; break; case 2: myLocale = Locale.ENGLISH; break; default: myLocale = appContext.getResources().getConfiguration().locale; &#125; // 本地语言设置 if (needUpdateLocale(appContext, myLocale)) &#123; updateLocale(appContext, myLocale); &#125; &#125; /** * 保存设置的语言 * * @param currentLanguage index */ public static void changeAppLanguage(Context context, int currentLanguage) &#123; if (context == null) return; Context appContext = context.getApplicationContext(); SpUtil.getInstance().save(&quot;currentLanguage&quot;, currentLanguage); Locale myLocale = Locale.SIMPLIFIED_CHINESE; // 0 简体中文 1 繁体中文 2 English switch (currentLanguage) &#123; case 0: myLocale = Locale.SIMPLIFIED_CHINESE; break; case 1: myLocale = Locale.TRADITIONAL_CHINESE; break; case 2: myLocale = Locale.ENGLISH; break; &#125; // 本地语言设置 if (LocaleUtil.needUpdateLocale(appContext, myLocale)) &#123; LocaleUtil.updateLocale(appContext, myLocale); &#125; Toast.makeText(appContext, appContext.getString(R.string.set_success), Toast.LENGTH_SHORT).show(); restartApp(appContext); &#125; /** * 重启app生效 * * @param context */ public static void restartApp(Context context) &#123; Intent intent = new Intent(context, MainActivity.class); intent.setAction(Intent.ACTION_MAIN); intent.addCategory(Intent.CATEGORY_LAUNCHER); intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK | Intent.FLAG_ACTIVITY_NEW_TASK); context.startActivity(intent); &#125; /** * 获取当前的Locale * * @param context Context * @return Locale */ public static Locale getCurrentLocale(Context context) &#123; Locale locale; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123; //7.0有多语言设置获取顶部的语言 locale = context.getResources().getConfiguration().getLocales().get(0); &#125; else &#123; locale = context.getResources().getConfiguration().locale; &#125; return locale; &#125; /** * 更新Locale * * @param context Context * @param locale New User Locale */ public static void updateLocale(Context context, Locale locale) &#123; if (needUpdateLocale(context, locale)) &#123; Configuration configuration = context.getResources().getConfiguration(); if (Build.VERSION.SDK_INT &gt;= 19) &#123; configuration.setLocale(locale); &#125; else &#123; configuration.locale = locale; &#125; DisplayMetrics displayMetrics = context.getResources().getDisplayMetrics(); context.getResources().updateConfiguration(configuration, displayMetrics); &#125; &#125; /** * 判断需不需要更新 * * @param context Context * @param locale New User Locale * @return true / false */ public static boolean needUpdateLocale(Context context, Locale locale) &#123; return locale != null &amp;&amp; !getCurrentLocale(context).equals(locale); &#125; /** * 当系统语言发生改变的时候还是继续遵循用户设置的语言 * * @param context * @param newConfig */ public static void setLanguage(Context context, Configuration newConfig) &#123; if (context == null) return; Context appContext = context.getApplicationContext(); int currentLanguage = SpUtil.getInstance().getInt(&quot;currentLanguage&quot;, -1); Locale locale; // 0 简体中文 1 繁体中文 2 English switch (currentLanguage) &#123; case 0: locale = Locale.SIMPLIFIED_CHINESE; break; case 1: locale = Locale.TRADITIONAL_CHINESE; break; case 2: locale = Locale.ENGLISH; break; default: locale = appContext.getResources().getConfiguration().locale; &#125; // 系统语言改变了应用保持之前设置的语言 if (locale != null) &#123; Locale.setDefault(locale); Configuration configuration = new Configuration(newConfig); if (Build.VERSION.SDK_INT &gt;= 19) &#123; configuration.setLocale(locale); &#125; else &#123; configuration.locale = locale; &#125; appContext.getResources().updateConfiguration(configuration, appContext.getResources().getDisplayMetrics()); &#125; &#125;&#125; ###3.1Application 中调用，用于初始化语言设置 12345@Override public void onCreate() &#123; super.onCreate(); LocaleUtil.changeAppLanguage(this); &#125; ###3.2在Application 中重写如下方法：用于当系统设置语言变化时进行语言设置 123456@Override public void onConfigurationChanged(Configuration newConfig) &#123; super.onConfigurationChanged(newConfig); Log.e(&quot;TAG&quot;, &quot;onConfigurationChanged&quot;); LocaleUtil.setLanguage(mContext, newConfig); &#125; ###3.3在多语言设置界面设置APP语言 &#160; &#160;&#160; &#160;当用户点击保存时传入当前语言对应的 Index 值即可，我这里使用的是保存一个 Int 类型的值，每一个 Int 类型的值对应一种语言的类型，当然你可以根据自己的实现保存为 String 类型也是可以的。 1LocaleUtil.changeAppLanguage(mContext, currentLanguage); ##4.多国语言文件夹命名对应表如下： &#160; &#160;&#160; &#160;本文只以简体中文、繁体中文和英语为例，要想实现更多语言设置，请参考下表： 国家 Folder Name 中文（中国） values-zh-rCN 中文（台湾） values-zh-rTW 中文（香港） values-zh-rHK 英语（美国） values-en-rUS 英语（英国） values-en-rGB 英文（澳大利亚） values-en-rAU 英文（加拿大） values-en-rCA 英文（爱尔兰） values-en-rIE 英文（印度） values-en-rIN 英文（新西兰） values-en-rNZ 英文（新加坡） values-en-rSG 英文（南非） values-en-rZA 阿拉伯文（埃及） values-ar-rEG 阿拉伯文（以色列） values-ar-rIL 保加利亚文 values-bg-rBG 加泰罗尼亚文 values-ca-rES 捷克文 values-cs-rCZ 丹麦文 values-da-rDK 德文（奥地利） values-de-rAT 德文（瑞士） values-de-rCH 德文（德国） values-de-rDE 德文（列支敦士登） values-de-rLI 希腊文 values-el-rGR 西班牙文（西班牙） values-es-rES 西班牙文（美国） values-es-rUS 芬兰文（芬兰） values-fi-rFI 法文（比利时） values-fr-rBE 法文（加拿大） values-fr-rCA 法文（瑞士） values-fr-rCH 法文（法国） values-fr-rFR 希伯来文 values-iw-rIL 印地文 values-hi-rIN 克罗里亚文 values-hr-rHR 匈牙利文 values-hu-rHU 印度尼西亚文 values-in-rID 意大利文（瑞士） values-it-rCH 意大利文（意大利） values-it-rIT 日文 values-ja-rJP 韩文 values-ko-rKR 立陶宛文 valueslt-rLT 拉脱维亚文 values-lv-rLV 挪威博克马尔文 values-nb-rNO 荷兰文(比利时) values-nl-BE 荷兰文（荷兰） values-nl-rNL 波兰文 values-pl-rPL 葡萄牙文（巴西） values-pt-rBR 葡萄牙文（葡萄牙） values-pt-rPT 罗马尼亚文 values-ro-rRO 俄文 values-ru-rRU 斯洛伐克文 values-sk-rSK 斯洛文尼亚文 values-sl-rSI 塞尔维亚文 values-sr-rRS 瑞典文 values-sv-rSE 泰文 values-th-rTH 塔加洛语 values-tl-rPH 土耳其文 values–r-rTR 乌克兰文 values-uk-rUA 越南文 values-vi-rVN ##5.常见的一些坑 设置英文语言时在有些手机上不起作用在开发过程中我们试过在 Redmi Note 4手机上设置英语语言不起作用，这是由于有些手机厂商的默认英语设置的是英式英语，而我们只使用了美式英语的缘故，此时处理方式为：①设置两种英语的设置选项，即美式英语和英式英语；②可将 res 的文件夹命名为values-en即可，不区分英式英语和美式英语即可； 在 Android Studio3.0 之前，如果有些 strings 没有对应到其他的语种，即有些字段没有翻译过来，打包时会 报警告，可以打成包，而 3.0 之后是不可以的，会打包失败，所以每个 Strings 必须对应一套完整的翻译！ ##6.相关权限 1&lt;uses-permission android:name=&quot;android.permission.CHANGE_CONFIGURATION&quot;/&gt; ##7.更多探讨 &#160; &#160;&#160; &#160;在实现APP种切换语言时，试了试微信的多语言设置页面是在 4 级页面，当它设置完语言之后先是跳转到我 界面（一级页面），然后紧接着跳到设置界面（二级页面），貌似微信没有重启 App，它只是管理保存了 Activity 任务栈，最后跳转到设置界面，而我的例子只是重启了 App 没有跳转回到设置界面，当然这要看具体的需求了，我个人感觉，设置完就没有必要再跳转回去了。 最后附上Demo:https://github.com/xinpengfei520/Multi-Language 如果你觉得不错可以帮我点个 star,3Q~ 若在使用过程中遇到什么问题，或有好提议，欢迎在公众号 “CodingAndroid” 中提出]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Android</tag>
        <tag>多语言</tag>
        <tag>SharedPreference</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 实现帧动画]]></title>
    <url>%2F2017%2F09%2F24%2FAndroid%E5%AE%9E%E7%8E%B0%E5%B8%A7%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[1.在res的drawable下新建一个布局animation.xml*文件version123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:oneshot=&quot;true&quot;&gt; &lt;item android:drawable=&quot;@drawable/image1&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image2&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image3&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image4&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image5&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image6&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image7&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image8&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image9&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image10&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image11&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image12&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image13&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image14&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image15&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image16&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image17&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image18&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image19&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image20&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image21&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image22&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image23&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image24&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image25&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image26&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image27&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image28&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image29&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image30&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image31&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image32&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image33&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image34&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image35&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image36&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image37&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image38&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image39&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image40&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image41&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image42&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image43&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image44&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image45&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image46&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image47&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image48&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image49&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image50&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image51&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image52&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image53&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image54&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image55&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image56&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image57&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image58&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image59&quot; android:duration=&quot;32&quot; /&gt; &lt;item android:drawable=&quot;@drawable/image60&quot; android:duration=&quot;32&quot; /&gt;&lt;/animation-list&gt; android:oneshot=”true”当为true时表示只播放一次，为false时表示循环播放； 2.给ImageView设置帧动画的src1234567&lt;ImageView android:id=&quot;@+id/ivLoading&quot; android:layout_width=&quot;300dp&quot; android:layout_height=&quot;300dp&quot; android:layout_centerInParent=&quot;true&quot; android:src=&quot;@drawable/animation&quot; android:visibility=&quot;gone&quot; /&gt; 3.播放帧动画123ivLoading.setImageResource(R.drawable.animation);drawable = (AnimationDrawable) ivLoading.getDrawable();drawable.start(); 4.以上播放默认是没有监听的，所以我们这里提供一种自定义View，可以监听帧动画播完的监听12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * 自定义可以播放动态图片的ImageView */public class AnimationImageView extends ImageView &#123; public AnimationImageView(Context context) &#123; super(context); &#125; public AnimationImageView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public AnimationImageView(Context context, AttributeSet attrs, int defStyle) &#123; super(context, attrs, defStyle); &#125; public interface OnFrameAnimationListener&#123; /** * 动画开始播放后调用 */ void onStart(); /** * 动画结束播放后调用 */ void onEnd(); &#125; /** * 不带动画监听的播放 * @param resId */ public void loadAnimation(int resId)&#123; setImageResource(resId); AnimationDrawable anim = (AnimationDrawable)getDrawable(); anim.start(); &#125; /** * 带动画监听的播放 * @param resId * @param listener */ public void loadAnimation(int resId, final OnFrameAnimationListener listener) &#123; setImageResource(resId); AnimationDrawable anim = (AnimationDrawable)getDrawable(); anim.start(); if(listener != null)&#123; // 调用回调函数onStart listener.onStart(); &#125; // 计算动态图片所花费的事件 int durationTime = 0; for (int i = 0; i &lt; anim.getNumberOfFrames(); i++) &#123; durationTime += anim.getDuration(i); &#125; // 动画结束后 new Handler().postDelayed(new Runnable() &#123; @Override public void run() &#123; if(listener != null)&#123; // 调用回调函数onEnd listener.onEnd(); &#125; &#125; &#125;, durationTime); &#125;&#125; 5.代码中加载并设置监听1234567891011121314// 加载带监听的帧动画anim_view.loadAnimation(R.drawable.anim_defense, new OnFrameAnimationListener() &#123; @Override public void onStart() &#123; // 动画刚播放时 &#125; @Override public void onEnd() &#123; // 动画结束播放时 &#125; &#125;); 参考文章： http://blog.csdn.net/zuozuoshenghen/article/details/50249569 http://blog.csdn.net/u012975705/article/details/48717391 http://www.cnblogs.com/net168/p/4204797.html]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 手把手撸一个 CustomProgressDialog]]></title>
    <url>%2F2017%2F09%2F24%2FAndroid%E6%89%8B%E6%8A%8A%E6%89%8B%E6%92%B8%E4%B8%80%E4%B8%AACustomProgressDialog%2F</url>
    <content type="text"><![CDATA[1.自定义LoadingView1234567891011121314151617181920212223242526272829303132333435363738394041/** * Created by xpf on 2017/8/28 :) * Function:自定义加载中的Dialog */public class LoadingView extends ProgressDialog &#123; public LoadingView(Context context) &#123; super(context); &#125; public LoadingView(Context context, int theme) &#123; super(context, theme); &#125; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); init(getContext()); &#125; private void init(Context context) &#123; setCancelable(true); setCanceledOnTouchOutside(false); setContentView(R.layout.loading_view);//loading的xml文件 WindowManager.LayoutParams params = getWindow().getAttributes(); params.width = WindowManager.LayoutParams.WRAP_CONTENT; params.height = WindowManager.LayoutParams.WRAP_CONTENT; getWindow().setAttributes(params); &#125; @Override public void show() &#123; // 显示Dialog super.show(); &#125; @Override public void dismiss() &#123; // 关闭Dialog super.dismiss(); &#125;&#125; 2.LoadingView的布局文件123456789101112131415161718192021222324252627282930&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;200dp&quot; android:layout_height=&quot;200dp&quot; android:layout_centerInParent=&quot;true&quot; android:layout_gravity=&quot;center_horizontal&quot; android:background=&quot;@drawable/shape_dialog_bg&quot; android:orientation=&quot;vertical&quot;&gt; &lt;RelativeLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;20dp&quot;&gt; &lt;ProgressBar android:id=&quot;@+id/pb_load&quot; android:layout_width=&quot;130dp&quot; android:layout_height=&quot;130dp&quot; android:layout_centerInParent=&quot;true&quot; android:indeterminateDrawable=&quot;@drawable/progressbar&quot; /&gt; &lt;/RelativeLayout&gt; &lt;TextView android:id=&quot;@+id/tv_load_dialog&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center_horizontal&quot; android:text=&quot;加载中...&quot; android:textColor=&quot;#9a9b98&quot; android:textSize=&quot;24sp&quot; /&gt;&lt;/LinearLayout&gt; 3.dialog圆角的shape12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;corners android:radius=&quot;16dp&quot; /&gt; &lt;solid android:color=&quot;#88000000&quot; /&gt;&lt;/shape&gt; 4.定义drawable旋转动画12345678910111213141516171819&lt;animated-rotate xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:fromDegrees=&quot;0&quot; android:pivotX=&quot;50%&quot; android:pivotY=&quot;50%&quot; android:toDegrees=&quot;720&quot;&gt; &lt;shape android:innerRadiusRatio=&quot;3&quot; android:shape=&quot;ring&quot; android:thicknessRatio=&quot;15&quot; android:useLevel=&quot;false&quot;&gt; &lt;gradient android:centerColor=&quot;#c6c6c6&quot; android:centerY=&quot;0.50&quot; android:endColor=&quot;#c6c6c6&quot; android:startColor=&quot;#55c6c6c6&quot; android:type=&quot;sweep&quot; android:useLevel=&quot;false&quot; /&gt; &lt;/shape&gt;&lt;/animated-rotate&gt; 5.定义一个Style1234&lt;style name=&quot;CustomDialog&quot; parent=&quot;Theme.AppCompat.Dialog&quot;&gt; &lt;item name=&quot;android:backgroundDimEnabled&quot;&gt;false&lt;/item&gt; &lt;item name=&quot;android:windowBackground&quot;&gt;@android:color/transparent&lt;/item&gt; &lt;/style&gt; 6.代码中使用1234if (loading == null) &#123; loading = new LoadingView(this, R.style.CustomDialog); loading.show(); // 显示 &#125; 取消显示：loading.dismiss(); ok~终于完了…]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>ProgressDialog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Expected resource of type id [ResourceType]]]></title>
    <url>%2F2017%2F09%2F24%2FAndroid%E6%89%93%E5%8C%85%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[今天刚升级完 Android Studio 到3.0.1版本，装完之后，遇到一堆问题，改了一大堆问题，终于改完了，就想打包apk试试，没想到打包时报了如下错误： Expected resource of type id [ResourceType]```12345678910点击到报错的地方，原来是依赖的一个开源库一个**if**判断处报错了，如下图：但是点击进去之后看了一下也是返回的**Int**类型的值，我就郁闷了，为什么不能比较了？有哪位大神可以解释一下是为什么吗？解决办法：后来在网上搜了一下，只要在这个报错代码所在方法的头上加入如下代码即可：```@SuppressWarnings(&quot;ResourceType&quot;) 试了试，果然好使，但还是不知道为什么？ 大神求解释！！！]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 最新手机号正则判断]]></title>
    <url>%2F2017%2F09%2F24%2FAndroid%E6%9C%80%E6%96%B0%E6%89%8B%E6%9C%BA%E5%8F%B7%E6%AD%A3%E5%88%99%E5%88%A4%E6%96%AD%2F</url>
    <content type="text"><![CDATA[/** * 匹配手机号的规则：[3578]是手机号第二位可能出现的数字 */ public static final String REGEX_MOBILE = &quot;^[1][3578][0-9]{9}$&quot;; /** * 校验手机号 * @param mobile * @return 校验通过返回true，否则返回false */ public static boolean isMobile(String mobile) { return Pattern.matches(REGEX_MOBILE, mobile); } 1、手机号开头集合 176，177，178, 180，181，182,183,184,185，186，187,188。，189。 145，147 130，131，132，133，134,135,136,137, 138,139 150,151, 152,153，155，156，157,158,159, 2、正则表达式 public static boolean isChinaPhoneLegal(String str) throws PatternSyntaxException { String regExp = &quot;^((13[0-9])|(15[^4])|(18[0-9])|(17[0-8])|(147,145))\\d{8}$&quot;; Pattern p = Pattern.compile(regExp); Matcher m = p.matcher(str); return m.matches(); } 13开头的后面跟0-9的任意8位数； 15开头的后面跟除了4以外的0-9的任意8位数； 18开头的后面跟0-9的任意8位数； 17开头的后面跟0-8的任意8位数，或者17[^9]； 147，145开头后面跟任意8位数；]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>REGEX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 点亮屏幕并解锁]]></title>
    <url>%2F2017%2F09%2F24%2FAndroid%E7%82%B9%E4%BA%AE%E5%B1%8F%E5%B9%95%E5%B9%B6%E8%A7%A3%E9%94%81%2F</url>
    <content type="text"><![CDATA[需求：现在在做一个app要求有唤醒屏幕并解锁的需求，参考了网上的许多的博客，感觉前篇一律，有的手机上好使，在有的手机上不好使，参考了微信的视频呼叫唤醒屏幕，可以点亮手机屏幕，对于有上滑手势解锁的手机只能点亮屏幕不能解锁屏幕，后来经过尝试，当前应用中有一个锁屏弹起界面 的权限，默认是关闭的，打开这个权限之后就可以点亮屏幕并弹出界面了(有上滑手势解锁的手机)，后台经过尝试现在可以点亮屏幕并解锁了… ##代码如下： 123456789101112131415161718192021222324/** * 唤醒手机屏幕并解锁 */ public static void wakeUpAndUnlock() &#123; // 获取电源管理器对象 PowerManager pm = (PowerManager) MyApplication.getContext() .getSystemService(Context.POWER_SERVICE); boolean screenOn = pm.isScreenOn(); if (!screenOn) &#123; // 获取PowerManager.WakeLock对象,后面的参数|表示同时传入两个值,最后的是LogCat里用的Tag PowerManager.WakeLock wl = pm.newWakeLock( PowerManager.ACQUIRE_CAUSES_WAKEUP | PowerManager.SCREEN_BRIGHT_WAKE_LOCK, &quot;bright&quot;); wl.acquire(10000); // 点亮屏幕 wl.release(); // 释放 &#125; // 屏幕解锁 KeyguardManager keyguardManager = (KeyguardManager) MyApplication.getContext() .getSystemService(KEYGUARD_SERVICE); KeyguardManager.KeyguardLock keyguardLock = keyguardManager.newKeyguardLock(&quot;unLock&quot;); // 屏幕锁定 keyguardLock.reenableKeyguard(); keyguardLock.disableKeyguard(); // 解锁 &#125; 注意：好多写法都是这样写的，在有的手机上不好使，后来我这样写```wl.acquire(10000);点亮屏幕```然后就好使了，我的理解是这样的：是不是时间太短了，刚唤醒屏幕就释放掉了会有问题，由于水平有限不对的地方请指出。1234567测试机型：xiaomi 5, OPPO R9s plus.其他机型请自测。 ##不要忘了添加如下权限 &lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot; /&gt; &lt;uses-permission android:name=&quot;android.permission.DISABLE_KEYGUARD&quot; /&gt; ` Thanks. 参考文章：http://blog.csdn.net/glen1943/article/details/8671793]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Base64 和 Bitmap 相互转换类]]></title>
    <url>%2F2017%2F09%2F24%2FAndroid%20Base64%E5%92%8CBitmap%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.util.Base64;import java.io.ByteArrayOutputStream;import java.io.IOException;/** * Created by xpf on 2017/4/7 :) * Function:Base64和Bitmap相互转换类 */public class Base64BitmapUtil &#123; /** * bitmap转为base64 * * @param bitmap * @return */ public static String bitmapToBase64(Bitmap bitmap) &#123; String result = null; ByteArrayOutputStream baos = null; try &#123; if (bitmap != null) &#123; baos = new ByteArrayOutputStream(); bitmap.compress(Bitmap.CompressFormat.JPEG, 100, baos); baos.flush(); baos.close(); byte[] bitmapBytes = baos.toByteArray(); result = Base64.encodeToString(bitmapBytes, Base64.DEFAULT); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (baos != null) &#123; baos.flush(); baos.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; return result; &#125; /** * base64转为bitmap * * @param base64Data * @return */ public static Bitmap base64ToBitmap(String base64Data) &#123; byte[] bytes = Base64.decode(base64Data, Base64.DEFAULT); return BitmapFactory.decodeByteArray(bytes, 0, bytes.length); &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Base64</tag>
        <tag>Bitmap</tag>
        <tag>utils</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 检测 Activity 或者 Service 是否运行]]></title>
    <url>%2F2017%2F09%2F24%2FAndroid%E6%A3%80%E6%B5%8BActivity%E6%88%96%E8%80%85Service%E6%98%AF%E5%90%A6%E8%BF%90%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[需求：假设我们的APP有3个页面AActivity,BActivity,CActivity,我们的APP需要一直运行在前台（特殊设备），要求实现一个监控服务，来监视APP是否运行，如果有3个页面都不运行了就说明这个APP已经挂掉了，否则说明APP在运行状态，不做处理，挂掉之后，我们需要重新启动App来让它继续处理运行状态，对外暴露一个来停止监控服务的广播，这样我们想停止监控服务时，发送一个广播即可。 思路：实现一个双进程的监控服务，服务中写一个定时器 Timer 来重复进行检测是否正在运行，如果否就直接重新启动APP。 ##1.定义一个监控服务 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124package com.anloq.nfcservice;import android.app.Service;import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;import android.content.IntentFilter;import android.os.IBinder;import android.util.Log;import com.anloq.MyApplication;import com.anloq.activity.AdActivity;import com.anloq.utils.DetectionASUtils;import java.text.SimpleDateFormat;import java.util.Date;import java.util.Locale;import java.util.Timer;import java.util.TimerTask;/** * Created by xpf on 2017/6/3 :) * 检测APP页面是否一直运行,不运行就直接启动 */public class MonitoringService extends Service &#123; private final static String TAG = &quot;MonitoringService&quot;; private BroadcastReceiver broadcastReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; if (&quot;kill_self&quot;.equals(intent.getAction())) &#123; Log.e(TAG, &quot;onReceive:杀死自己的进程！&quot;); killMyselfPid(); // 杀死自己的进程 &#125; &#125; &#125;; private Timer timer = new Timer(); private TimerTask task = new TimerTask() &#123; @Override public void run() &#123; checkIsAlive(); &#125; &#125;; /** * 检测应用是否活着 */ private void checkIsAlive() &#123; String format = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;, Locale.CHINA).format(new Date()); Log.e(TAG, &quot;CustodyService Run: &quot; + format); boolean AIsRunning = CheckUtil.isClsRunning( MonitoringService.this, &quot;com.xpf.monitor&quot;, &quot;com.xpf.monitor.activity.AActivity&quot;); boolean BIsRunning = CheckUtil.isClsRunning( MonitoringService.this, &quot;com.xpf.monitor&quot;, &quot;com.xpf.monitor.activity.BActivity&quot;); boolean b = (AIsRunning || BIsRunning); boolean CIsRunning = CheckUtil.isClsRunning( MonitoringService.this, &quot;com.xpf.monitor&quot;, &quot;com.xpf.monitor.activity.CActivity&quot;); Log.e(TAG, &quot;AIsRunning || BIsRunning is running:&quot; + b + &quot;,CIsRunning:&quot; + CIsRunning); if (!CIsRunning) &#123; if (!b) &#123; //如果界面挂掉直接启动AActivity Intent intent = new Intent(); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); intent.setClass(MonitoringService.this, AActivity.class); startActivity(intent); &#125; &#125; &#125; @Override public void onCreate() &#123; super.onCreate(); Log.e(TAG, &quot;onCreate: 启动监控服务! &quot;); IntentFilter intentFilter = new IntentFilter(); intentFilter.addAction(&quot;kill_self&quot;); registerReceiver(broadcastReceiver, intentFilter); timer.schedule(task, 0, 10000);// 设置检测的时间周期(毫秒数) &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; return START_STICKY; &#125; @Override public IBinder onBind(Intent arg0) &#123; return null; &#125; /** * 杀死自身的进程 */ private void killMyselfPid() &#123; int pid = android.os.Process.myPid(); String command = &quot;kill -9 &quot; + pid; Log.e(TAG, &quot;killMyselfPid: &quot; + command); stopService(new Intent(MonitoringService.this, MonitoringService.class)); try &#123; Runtime.getRuntime().exec(command); System.exit(0); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; @Override public void onDestroy() &#123; super.onDestroy(); unregisterReceiver(broadcastReceiver); if (task != null) &#123; task.cancel(); &#125; if (timer != null) &#123; timer.cancel(); &#125; &#125;&#125; ##2.注册双进程Service 123456789&lt;service android:name=&quot;com.xpf.monitor.MonitoringService&quot; android:enabled=&quot;true&quot; android:label=&quot;MonitoringService&quot; android:process=&quot;:gray&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.RESPOND_VIA_MESSAGE&quot; /&gt; &lt;/intent-filter&gt; &lt;/service&gt; ##3.检测是否活着的工具类CheckUtil 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class CheckUtil &#123; //检测service是否在运行 public static boolean isServiceWorked(Context context, String serviceName) &#123; ActivityManager myManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE); ArrayList&lt;ActivityManager.RunningServiceInfo&gt; runningService = (ArrayList&lt;ActivityManager.RunningServiceInfo&gt;) myManager.getRunningServices(Integer.MAX_VALUE); for (int i = 0; i &lt; runningService.size(); i++) &#123; if (runningService.get(i).service.getClassName().toString().equals(serviceName)) &#123; return true; &#125; &#125; return false; &#125; //检测activity是否存在再栈顶 public static boolean isForeground(Context context, String PackageName) &#123; ActivityManager myManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE); List&lt;ActivityManager.RunningTaskInfo&gt; task = myManager.getRunningTasks(1); ComponentName componentInfo = task.get(0).topActivity; if (componentInfo.getPackageName().equals(PackageName)) return true; return false; &#125; /** * 判断某个app进程是否在运行 * * @param context * @param appInfo * @return */ public static boolean isRunningProcess(Context context, String appInfo) &#123; ActivityManager myManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE); List&lt;ActivityManager.RunningAppProcessInfo&gt; runningAppPs = myManager.getRunningAppProcesses(); if (runningAppPs != null &amp;&amp; runningAppPs.size() &gt; 0) &#123; if (runningAppPs.contains(appInfo)) &#123; return true; &#125; &#125; return false; &#125; /** * 判断一个Activity是否正在运行 * * @param pkg pkg为应用包名 * @param cls cls为类名eg * @param context * @return */ public static boolean isClsRunning(Context context, String pkg, String cls) &#123; ActivityManager am = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE); List&lt;ActivityManager.RunningTaskInfo&gt; tasks = am.getRunningTasks(1); ActivityManager.RunningTaskInfo task = tasks.get(0); if (task != null) &#123; return TextUtils.equals(task.topActivity.getPackageName(), pkg) &amp;&amp; TextUtils.equals(task.topActivity.getClassName(), cls); &#125; return false; &#125;&#125; ##4.MainActivity中启动监控服务 123Intent intent = new Intent(MainActivity.this, MonitoringService.class); intent.setAction(&quot;android.intent.action.RESPOND_VIA_MESSAGE&quot;); startService(intent); ##5.停止监控服务 发送一个杀死进程广播即可，action值如下 123Intent intent = new Intent(); intent.setAction(&quot;kill_self&quot;); sendOrderedBroadcast(intent, null); 好了，今天就分享到这里了。。。 欢迎评论和点赞！！！]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Activity</tag>
        <tag>Service</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 点击其他地方隐藏软键盘]]></title>
    <url>%2F2017%2F09%2F24%2FAndroid%E7%82%B9%E5%87%BB%E5%85%B6%E4%BB%96%E5%9C%B0%E6%96%B9%E9%9A%90%E8%97%8F%E9%94%AE%E7%9B%98%2F</url>
    <content type="text"><![CDATA[##1.第一种：隐藏页面一进来EditText获取焦点就弹出软键盘 在oncreate()里调用如下方法即可 1234567/** * 隐藏软键盘 */ private void hideSoftKeyBoard() &#123; getWindow().setSoftInputMode( WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN); &#125; ##2.第二种：如果EditText获取焦点已经弹起软键盘，点击其他空白区域隐藏软键盘 此方法可以写到BaseActivity中其他Activity就相应的也会继承 1234567891011121314151617181920212223242526272829303132333435363738394041424344@Override public boolean dispatchTouchEvent(MotionEvent ev) &#123; if (ev.getAction() == MotionEvent.ACTION_DOWN) &#123; View v = getCurrentFocus(); if (isShouldHideKeyboard(v, ev)) &#123; hideKeyboard(v.getWindowToken()); &#125; &#125; return super.dispatchTouchEvent(ev); &#125; /** * 根据EditText所在坐标和用户点击的坐标相对比， * 来判断是否隐藏键盘，因为当用户点击EditText时则不能隐藏 */ private boolean isShouldHideKeyboard(View v, MotionEvent event) &#123; if (v != null &amp;&amp; (v instanceof EditText)) &#123; int[] l = &#123;0, 0&#125;; v.getLocationInWindow(l); int left = l[0], top = l[1], bottom = top + v.getHeight(), right = left + v.getWidth(); if (event.getX() &gt; left &amp;&amp; event.getX() &lt; right &amp;&amp; event.getY() &gt; top &amp;&amp; event.getY() &lt; bottom) &#123; // 点击EditText的事件，忽略它。 return false; &#125; else &#123; return true; &#125; &#125; // 如果焦点不是EditText则忽略，这个发生在视图刚绘制完，第一个焦点不在EditText上，和用户用轨迹球选择其他的焦点 return false; &#125; /** * 获取InputMethodManager，隐藏软键盘 */ private void hideKeyboard(IBinder token) &#123; if (token != null) &#123; InputMethodManager im = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE); im.hideSoftInputFromWindow(token, InputMethodManager.HIDE_NOT_ALWAYS); &#125; &#125; Thanks all. 2017.6.21 beijing 雨]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Android</tag>
        <tag>软键盘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 打开系统拍照和相册获取头像]]></title>
    <url>%2F2017%2F09%2F24%2FAndroid%E6%89%93%E5%BC%80%E7%B3%BB%E7%BB%9F%E6%8B%8D%E7%85%A7%E5%92%8C%E7%9B%B8%E5%86%8C%E8%8E%B7%E5%8F%96%E5%A4%B4%E5%83%8F%2F</url>
    <content type="text"><![CDATA[现在许多应用都有上传头像的功能，再次奉上代开系统相册或打开系统相机拍照的实现，有的同学在测试小米手机上打开选择相册有奔溃，此代码已完美解决此问题… 楼主，做的头像需要经过裁剪之后和圆形处理… 1.设置点击打开相机&amp;打开系统图库1234567891011121314@Override public void onClick(View v) &#123; // 打开系统拍照程 Intent camera = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); startActivityForResult(camera, CAMERA); &#125; @Override public void onClick(View v) &#123; // 打开系统图库选择图片 Intent picture = new Intent(Intent.ACTION_PICK, MediaStore.Images.Media.EXTERNAL_CONTENT_URI); startActivityForResult(picture, PICTURE); &#125; 2.重写带结果启动的回调onActivityResult1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859@Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); if (requestCode == CAMERA &amp;&amp; resultCode == RESULT_OK &amp;&amp; data != null) &#123; // 拍照 Bundle bundle = data.getExtras(); // 获取相机返回的数据，并转换为图片格式 Bitmap bitmap = (Bitmap) bundle.get(&quot;data&quot;); // bitmap圆形裁剪// bitmap = BitmapUtils.zoom(bitmap, DensityUtil.dp2px(this, 62), DensityUtil.dp2px(this, 62)); bitmap = BitmapUtils.zoom(bitmap, DensityUtil.dp2px(this, 20), DensityUtil.dp2px(this, 20)); Bitmap circleBitmap = BitmapUtils.circleBitmap(bitmap); //TODO 将图片上传到服务器// ivIcon.setImageBitmap(circleBitmap); uploadHeadpic(bitmap); // 将图片保存在本地 try &#123; saveImage(circleBitmap); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; else if (requestCode == PICTURE &amp;&amp; resultCode == RESULT_OK &amp;&amp; data != null) &#123; //图库 String pathResult = null; // 获取图片路径的方法调用 try &#123; Uri uri = data.getData(); pathResult = getPath(uri); Log.e(&quot;TAG&quot;, &quot;图片路径===&quot; + pathResult); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; //这里返回的uri情况就有点多了 //**:在4.4.2之前返回的uri是:content://media/external/images/media/3951或者file://....在4.4.2返回的是content://com.android.providers.media.documents/document/image:3951或者 //总结：uri的组成，eg:content://com.example.project:200/folder/subfolder/etc //content:---&gt;&quot;scheme&quot; //com.example.project:200--&gt;&quot;host&quot;:&quot;port&quot;---&gt;&quot;authority&quot;[主机地址+端口(省略) =authority] //folder/subfolder/etc--&gt;&quot;path&quot; 路径部分 //android各个不同的系统版本,对于获取外部存储上的资源，返回的Uri对象都可能各不一样,所以要保证无论是哪个系统版本都能正确获取到图片资源的话 //就需要针对各种情况进行一个处理了 Bitmap decodeFile = BitmapFactory.decodeFile(pathResult); Bitmap zoomBitmap = BitmapUtils.zoom(decodeFile, DensityUtil.dp2px(this, 20), DensityUtil.dp2px(this, 20)); // bitmap圆形裁剪p Bitmap circleImage = BitmapUtils.circleBitmap(zoomBitmap); // 真实项目当中，是需要上传到服务器的..这步我们就不做了。 uploadHeadpic(zoomBitmap); try &#123; // 保存图片到本地 saveImage(circleImage); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 3.获取图片路径12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697// 根据系统相册选择的文件获取路径 @SuppressLint(&quot;NewApi&quot;) private String getPath(Uri uri) &#123;// int sdkVersion = Build.VERSION.SDK_INT; final boolean isKitKat = Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT; // 高于4.4.2的版本// if (sdkVersion &gt;= 19) &#123; if (isKitKat &amp;&amp; DocumentsContract.isDocumentUri(mContext, uri)) &#123; Log.e(&quot;TAG&quot;, &quot;uri auth: &quot; + uri.getAuthority()); if (isExternalStorageDocument(uri)) &#123; String docId = DocumentsContract.getDocumentId(uri); String[] split = docId.split(&quot;:&quot;); String type = split[0]; if (&quot;primary&quot;.equalsIgnoreCase(type)) &#123; return Environment.getExternalStorageDirectory() + &quot;/&quot; + split[1]; &#125; &#125; else if (isDownloadsDocument(uri)) &#123; final String id = DocumentsContract.getDocumentId(uri); final Uri contentUri = ContentUris.withAppendedId(Uri.parse(&quot;content://downloads/public_downloads&quot;), Long.valueOf(id)); return getDataColumn(this, contentUri, null, null); &#125; else if (isMediaDocument(uri)) &#123; final String docId = DocumentsContract.getDocumentId(uri); final String[] split = docId.split(&quot;:&quot;); final String type = split[0]; Uri contentUri = null; if (&quot;image&quot;.equals(type)) &#123; contentUri = MediaStore.Images.Media.EXTERNAL_CONTENT_URI; &#125; else if (&quot;video&quot;.equals(type)) &#123; contentUri = MediaStore.Video.Media.EXTERNAL_CONTENT_URI; &#125; else if (&quot;audio&quot;.equals(type)) &#123; contentUri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI; &#125; final String selection = &quot;_id=?&quot;; final String[] selectionArgs = new String[]&#123;split[1]&#125;; return getDataColumn(this, contentUri, selection, selectionArgs); &#125; else if (isMedia(uri)) &#123; String[] proj = &#123;MediaStore.Images.Media.DATA&#125;; Cursor actualimagecursor = this.managedQuery(uri, proj, null, null, null); int actual_image_column_index = actualimagecursor.getColumnIndexOrThrow(MediaStore.Images.Media.DATA); actualimagecursor.moveToFirst(); return actualimagecursor.getString(actual_image_column_index); &#125; &#125; else if (&quot;content&quot;.equalsIgnoreCase(uri.getScheme())) &#123; // Return the remote address if (isGooglePhotosUri(uri)) return uri.getLastPathSegment(); return getDataColumn(this, uri, null, null); &#125; else if (&quot;file&quot;.equalsIgnoreCase(uri.getScheme())) &#123; // File return uri.getPath(); &#125; return null; &#125;private String getDataColumn(Context context, Uri uri, String selection, String[] selectionArgs) &#123; Cursor cursor = null; final String column = &quot;_data&quot;; final String[] projection = &#123;column&#125;; try &#123; cursor = context.getContentResolver().query(uri, projection, selection, selectionArgs, null); if (cursor != null &amp;&amp; cursor.moveToFirst()) &#123; final int index = cursor.getColumnIndexOrThrow(column); return cursor.getString(index); &#125; &#125; finally &#123; if (cursor != null) cursor.close(); &#125; return null; &#125; private boolean isExternalStorageDocument(Uri uri) &#123; return &quot;com.android.externalstorage.documents&quot;.equals(uri.getAuthority()); &#125; public static boolean isDownloadsDocument(Uri uri) &#123; return &quot;com.android.providers.downloads.documents&quot;.equals(uri.getAuthority()); &#125; public static boolean isMediaDocument(Uri uri) &#123; return &quot;com.android.providers.media.documents&quot;.equals(uri.getAuthority()); &#125; public static boolean isMedia(Uri uri) &#123; return &quot;media&quot;.equals(uri.getAuthority()); &#125; /** * @param uri The Uri to check. * @return Whether the Uri authority is Google Photos. */ public static boolean isGooglePhotosUri(Uri uri) &#123; return &quot;com.google.android.apps.photos.content&quot;.equals(uri.getAuthority()); &#125; 以上就是比较完整的代码了… 最后附上2篇参考文章： http://blog.csdn.net/iamwutianbao/article/details/52459509 http://blog.csdn.net/coderinchina/article/details/50799501 Thanks all.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>相机</tag>
        <tag>相册</tag>
        <tag>拍照</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 设置 gif 只播放一次]]></title>
    <url>%2F2017%2F09%2F24%2FAndroid%E8%AE%BE%E7%BD%AEgif%E5%8F%AA%E6%92%AD%E6%94%BE%E4%B8%80%E6%AC%A1%2F</url>
    <content type="text"><![CDATA[第一种写法：123456789101112131415161718192021222324Glide.with(mContext).load(R.drawable.open_door_fail) .diskCacheStrategy(DiskCacheStrategy.SOURCE) .listener(new RequestListener&lt;Integer, GlideDrawable&gt;() &#123; @Override public boolean onException(Exception e, Integer model, Target&lt;GlideDrawable&gt; target, boolean isFirstResource) &#123; return false; &#125; @Override public boolean onResourceReady(GlideDrawable resource, Integer model, Target&lt;GlideDrawable&gt; target, boolean isFromMemoryCache, boolean isFirstResource) &#123; int duration = 0; // 计算动画时长 GifDrawable drawable = (GifDrawable) resource; GifDecoder decoder = drawable.getDecoder(); for (int i = 0; i &lt; drawable.getFrameCount(); i++) &#123; duration += decoder.getDelay(i); &#125; //发送延时消息，通知动画结束 handler.sendEmptyMessageDelayed(ANIMDISMISS, duration); return false; &#125; &#125;) .into(new GlideDrawableImageViewTarget(ivOpenDoor, 1)); &#125; 另外一种写法1234567891011121314151617181920212223Glide.with(mContext).load(R.drawable.loading) .diskCacheStrategy(DiskCacheStrategy.SOURCE) .listener(new RequestListener&lt;Integer, GlideDrawable&gt;() &#123; @Override public boolean onException(Exception e, Integer model, Target&lt;GlideDrawable&gt; target, boolean isFirstResource) &#123; return false; &#125; @Override public boolean onResourceReady(GlideDrawable resource, Integer model, Target&lt;GlideDrawable&gt; target, boolean isFromMemoryCache, boolean isFirstResource) &#123; int duration = 0; // 计算动画时长 GifDrawable drawable = (GifDrawable) resource; GifDecoder decoder = drawable.getDecoder(); for (int i = 0; i &lt; drawable.getFrameCount(); i++) &#123; duration += decoder.getDelay(i); &#125; //发送延时消息，通知动画结束 handler.sendEmptyMessageDelayed(3, duration); return false; &#125; &#125;) .into(ivLoading); Thanks all.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>gif</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 设置屏幕亮度及 Alpha 值]]></title>
    <url>%2F2017%2F09%2F24%2FAndroid%E8%AE%BE%E7%BD%AE%E5%B1%8F%E5%B9%95%E4%BA%AE%E5%BA%A6%E5%8F%8AAlpha%E5%80%BC%2F</url>
    <content type="text"><![CDATA[直接看代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package com.xpf.someexamples;import android.app.Activity;import android.content.Context;import android.view.Window;import android.view.WindowManager;/** * Created by xpf on 2017/5/14 :) * GitHub:xinpengfei520 * Function:设置屏幕亮度及Alpha值 */public class BrightnessManager &#123; /** * 设置当前activity的屏幕亮度 * * @param paramFloat 0-1.0f * @param context 需要调整亮度的activity context */ public static void setBrightness(float paramFloat, Context context) &#123; Activity activity = (Activity) context; Window localWindow = activity.getWindow(); WindowManager.LayoutParams params = localWindow.getAttributes(); params.screenBrightness = paramFloat; localWindow.setAttributes(params); &#125; /** * 获取当前activity的屏幕亮度 * * @param context 当前activity context对象 * @return 亮度值范围为0-0.1f，如果为-1.0，则亮度与全局同步 */ public static float getBrightness(Context context) &#123; Activity activity = (Activity) context; Window localWindow = activity.getWindow(); WindowManager.LayoutParams params = localWindow.getAttributes(); return params.screenBrightness; &#125; /** * 设置手机屏幕透明度0-1.0f */ public static void setAlpha(float light, Context context) &#123; Activity activity = (Activity) context; Window window = activity.getWindow(); WindowManager.LayoutParams lp = window.getAttributes(); lp.alpha = light; window.setAttributes(lp); &#125; /** * 设置手机屏幕透明度变暗 */ public static void lightoff(Context context) &#123; Activity activity = (Activity) context; Window window = activity.getWindow(); WindowManager.LayoutParams lp = window.getAttributes(); lp.alpha = 0.3f; window.setAttributes(lp); &#125; /** * 设置手机屏幕透明度显示正常 */ public static void lighton(Context context) &#123; Activity activity = (Activity) context; Window window = activity.getWindow(); WindowManager.LayoutParams lp = window.getAttributes(); lp.alpha = 1.0f; window.setAttributes(lp); &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Android</tag>
        <tag>Alpha</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 追加换行写入内容到 txt 文件中]]></title>
    <url>%2F2017%2F09%2F24%2FAndroid%E8%BF%BD%E5%8A%A0%E6%8D%A2%E8%A1%8C%E5%86%99%E5%85%A5%E5%86%85%E5%AE%B9%E5%88%B0txt%E6%96%87%E4%BB%B6%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[实现思路为：使用 Context.MODE_APPEND 属性将每次内容的写入到上次内容的尾部，然后在每次写入内容完成之后写入一个回车换行符fos.write(“\r\n”.getBytes());即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * Created by xpf on 2017/10/31 :) * Function: */public class FileHelper &#123; private Context mContext; public FileHelper(Context mContext) &#123; this.mContext = mContext; &#125; /** * 定义文件保存的方法，写入到文件中，所以是输出流 */ public void save(String adNum, String time) &#123; String content = &quot;广告位编号：&quot; + adNum + &quot;，播放时长：&quot; + time; FileOutputStream fos = null; try &#123; // Context.MODE_PRIVATE私有权限，Context.MODE_APPEND追加写入到已有内容的后面 fos = mContext.openFileOutput(getFileName(), Context.MODE_APPEND); fos.write(content.getBytes()); fos.write(&quot;\r\n&quot;.getBytes());//写入换行 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (fos != null) &#123; try &#123; fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; /** * 定义文件读取的方法 */ public String read(String filename) throws IOException &#123; FileInputStream fis = mContext.openFileInput(filename); byte[] buff = new byte[1024]; StringBuilder sb = new StringBuilder(&quot;&quot;); int len = 0; while ((len = fis.read(buff)) &gt; 0) &#123; sb.append(new String(buff, 0, len)); &#125; fis.close(); return sb.toString(); &#125; /** * get file name such as 20171031.txt * * @return */ private String getFileName() &#123; return TimeUtil.getCurrentDay() + &quot;.txt&quot;; &#125;&#125; 转载请注明出处，谢谢！]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>txt</tag>
        <tag>文件读写</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 跳转到其他 APP]]></title>
    <url>%2F2017%2F09%2F24%2FAndroid%E8%B7%B3%E8%BD%AC%E5%88%B0%E5%85%B6%E4%BB%96APP%2F</url>
    <content type="text"><![CDATA[从APP A 中打开B APP ，注意 B APP的包名和MainActivity 的全类名 12345Intent intent = new Intent(Intent.ACTION_MAIN);intent.addCategory(Intent.CATEGORY_LAUNCHER);ComponentName cn = new ComponentName(&quot;com.xpf.keyboardtest&quot;, &quot;com.xpf.keyboardtest.MainActivity&quot;);intent.setComponent(cn);startActivity(intent);]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Intent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android MD5 加密工具类]]></title>
    <url>%2F2017%2F09%2F24%2FAndroid%20MD5%E5%8A%A0%E5%AF%86%E5%B7%A5%E5%85%B7%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[直接看代码： 1234567891011121314151617181920212223242526public class MD5Utils &#123; public static String MD5(String sourceStr) &#123; String result = &quot;&quot;; try &#123; MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;); md.update(sourceStr.getBytes()); byte b[] = md.digest(); int i; StringBuffer buf = new StringBuffer(&quot;&quot;); for (int offset = 0; offset &lt; b.length; offset++) &#123; i = b[offset]; if (i &lt; 0) i += 256; if (i &lt; 16) buf.append(&quot;0&quot;); buf.append(Integer.toHexString(i)); &#125; result = buf.toString(); &#125; catch (NoSuchAlgorithmException e) &#123; System.out.println(e); &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>utils</tag>
        <tag>MD5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 透明度换算]]></title>
    <url>%2F2017%2F09%2F24%2FAndroid%E9%80%8F%E6%98%8E%E5%BA%A6%E6%8D%A2%E7%AE%97%2F</url>
    <content type="text"><![CDATA[Android布局中颜色表示都是使用十六进制来表示的，使用RGB和ARGB,后者多了一个透明度，而UI设计师通常在标注图中标注的透明度通常为百分比，这就需要我们做一些转换才能使用，透明度从0（透明）到1（不透明）对应的透明度为0%–100%，对应的十六进制为00–FF,对应的十进制为0–255，所以转换公式为：255 x 透明百分比，再将其转换为16进制即可，下面列出了常用的透明度百分比对应的十六进制。 透明度 透明度值 100% FF 95% F2 90% E6 85% D9 80% CC 75% BF 70% B3 65% A6 60% 99 55% 8C 50% 80 45% 73 40% 66 35% 59 30% 4D 25% 40 20% 33 15% 26 10% 1A 5% 0D 0% 00 ###Thanks all.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>RGB</tag>
        <tag>ARGB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android EasyPermission 优雅地实现动态权限申请]]></title>
    <url>%2F2017%2F09%2F24%2FAndroid%20EasyPermission%E4%BC%98%E9%9B%85%E5%9C%B0%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E6%9D%83%E9%99%90%E7%94%B3%E8%AF%B7%2F</url>
    <content type="text"><![CDATA[Google开源的动态权限适配库，用起来比较简洁和清晰，总体还不错，如果喜欢链式调用的就用 RxPermission 或者 AndPermission 都是不错的选择。 ##一、权限等级和权限组介绍 权限主要分为 normal 、dangerous、signature 和 signatureOrSystem四个等级，一般情况下，我们只需要了解前两种权限的使用就可以了，后面的是属于系统级签名的权限。 ##二、普通权限和危险权限 普通权限只需要在AndroidMenifest.xml文件中申请即可，危险权限需要到代码中进行动态申请一般是成对成组地去申请，所以叫权限组 普通权限对应表： Name Permission ACCESS_LOCATION_EXTRA_COMMANDS ACCESS_NETWORK_STATE ACCESS_NOTIFICATION_POLICY ACCESS_WIFI_STATE BLUETOOTH BLUETOOTH_ADMIN BROADCAST_STICKY CHANGE_NETWORK_STATE CHANGE_WIFI_MULTICAST_STATE CHANGE_WIFI_STATE DISABLE_KEYGUARD EXPAND_STATUS_BAR GET_PACKAGE_SIZE INSTALL_SHORTCUT INTERNET KILL_BACKGROUND_PROCESSES MODIFY_AUDIO_SETTINGS NFC READ_SYNC_SETTINGS READ_SYNC_STATS RECEIVE_BOOT_COMPLETED REORDER_TASKS REQUEST_IGNORE_BATTERY_OPTIMIZATIONS REQUEST_INSTALL_PACKAGES SET_ALARM SET_TIME_ZONE SET_WALLPAPER SET_WALLPAPER_HINTS TRANSMIT_IR UNINSTALL_SHORTCUT USE_FINGERPRINT VIBRATE WAKE_LOCK WRITE_SYNC_SETTINGS 危险权限对应表： 权限组 权限 CALENDAR READ_CALENDAR WRITE_CALENDAR CAMERA CAMERA CONTACTS READ_CONTACTS WRITE_CONTACTS GET_ACCOUNTS LOCATION ACCESS_FINE_LOCATION ACCESS_COARSE_LOCATION MICROPHONE RECORD_AUDIO PHONE READ_PHONE_STATE CALL_PHONE READ_CALL_LOG WRITE_CALL_LOG ADD_VOICEMAIL USE_SIP PROCESS_OUTGOING_CALLS SENSORS BODY_SENSORS SMS SEND_SMS RECEIVE_SMS READ_SMS RECEIVE_WAP_PUSH RECEIVE_MMS STORAGE READ_EXTERNAL_STORAGE WRITE_EXTERNAL_STORAGE 下面简单介绍一下EasyPermission的简单使用，更多详细使用请参考：https://github.com/googlesamples/easypermissions ##1.添加依赖库 1compile &apos;pub.devrel:easypermissions:1.0.1&apos; ##2.定义需要动态申请的权限集合 1234567/** * 需要申请的权限数组 */ protected String[] needPermissions = &#123; Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.READ_EXTERNAL_STORAGE, &#125;; ##3.重写回调方法 1234567@Override public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); // Forward results to EasyPermissions EasyPermissions.onRequestPermissionsResult(requestCode, permissions, grantResults, this); &#125; ##4.授权成功和失败的回调 123456789101112@AfterPermissionGranted(RC_CAMERA_AND_LOCATION)private void methodRequiresTwoPermission() &#123; String[] perms = &#123;Manifest.permission.CAMERA, Manifest.permission.ACCESS_FINE_LOCATION&#125;; if (EasyPermissions.hasPermissions(this, perms)) &#123; // Already have permission, do the thing // ... &#125; else &#123; // Do not have permissions, request them now EasyPermissions.requestPermissions(this, getString(R.string.camera_and_location_rationale), RC_CAMERA_AND_LOCATION, perms); &#125;&#125; ##第二种写法： 1234567EasyPermissions.requestPermissions( new PermissionRequest.Builder(this, RC_CAMERA_AND_LOCATION, perms) .setRationale(R.string.camera_and_location_rationale) .setPositiveButtonText(R.string.rationale_ask_ok) .setNegativeButtonText(R.string.rationale_ask_cancel) .setTheme(R.style.my_fancy_style) .build()); 重写授权成功和失败的回调 12345678910111213141516171819@Override public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) &#123; super.onRequestPermissionsResult(requestCode, permissions, grantResults); // Forward results to EasyPermissions EasyPermissions.onRequestPermissionsResult(requestCode, permissions, grantResults, this); &#125; @Override public void onPermissionsGranted(int requestCode, List&lt;String&gt; list) &#123; // Some permissions have been granted // ... &#125; @Override public void onPermissionsDenied(int requestCode, List&lt;String&gt; list) &#123; // Some permissions have been denied // ... &#125; ##更多使用请参考： https://github.com/googlesamples/easypermissions ##另外再推荐几个不错的处理动态权限的开源库： 前面的star基本都是几k,后面的都是几百的star https://github.com/tbruyelle/RxPermissions https://github.com/hongyangAndroid/MPermissions https://github.com/yanzhenjie/AndPermission https://github.com/permissions-dispatcher/PermissionsDispatcher https://github.com/jokermonn/permissions4m https://github.com/lovedise/PermissionGen https://github.com/k0shk0sh/PermissionHelper 支持Kotlin:https://github.com/googlesamples/android-RuntimePermissions https://github.com/mylhyl/AndroidAcp https://github.com/ParkSangGwon/TedPermission https://github.com/yewei02538/HiPermission https://github.com/PEXPlugins/PermissionsEx https://github.com/dfqin/PermissionGrantor ##更多Google官网文档关于动态权限的说明 https://developer.android.com/guide/topics/security/permissions.html https://developer.android.com/training/permissions/requesting.html https://developer.android.com/training/permissions/best-practices.html]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>EasyPermission</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7.x 搭建 GitLab 教程]]></title>
    <url>%2F2017%2F09%2F24%2FCentOS7.x%20%E6%90%AD%E5%BB%BA%20GitLab%20%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[今天闲来无事，想起之前买了一个阿里云 ECS，一直闲置着没用，一时兴起就想搭个自己的 GitLab 玩玩，GitLab 官网也提供了安装教程，很简单，照着步骤一步步基本没什么问题，可能安装的过程中有一些坑需要自己去解决。 1.安装 GitLab打开 GitLab 官网 https://www.gitlab.com.cn/installation/#centos-7 根据自己的系统选择，我们选择 CentOS7 首先，安装并配置必要的依赖关系，确保打开防火墙的 SSH 和 HTTP 的访问，如果没有，需要您输入下面命令打开 12345sudo yum install -y curl policycoreutils-python openssh-serversudo systemctl enable sshdsudo systemctl start sshdsudo firewall-cmd --permanent --add-service=httpsudo systemctl reload firewalld 接下来安装 Postfix 发送邮件通知服务，或者如果您想使用其他方式（SMTP）来发送电子邮件，请跳过此步骤，并在安装了 GitLab 之后配置一个外部SMTP服务器。 123sudo yum install postfixsudo systemctl enable postfixsudo systemctl start postfix 添加 GitLab 包仓库并安装包 1curl https://packages.gitlab.com/install/repositories/gitlab/gitlab-ee/script.rpm.sh | sudo bash 接下来，安装 GitLab 包，将 “http://gitlab.example.com” 更改为您想要访问 GitLab 的URL，安装将自动配置并在使用该 URL 来访问 GitLab，HTTPS 需要安装完成后来配置。 温馨提示：此处如果设置为域名访问，如果域名没有备案就会出现无法访问，如果不想备案网站域名，那么此处直接配置为服务器的公网 IP 即可。 因为我配置的是域名，因为我的域名没有备案，所以我访问的时候提示我备案域名，如下图： 配置完成后就开始下载并安装，过程大概会持续一个小时左右，视服务器具体带宽而定。 如果 GitLab 已经安装完成，并且你已经配置了域名想要修改配置变成 ip，按如下步骤执行命令： 1vim /etc/gitlab/gitlab.rb 找到 external_url 设置为你的 IP + 端口即可，注意这里设置的端口不能被占用，默认是 8080 端口，如果 8080 已经使用，请自定义其它端口，并在防火墙设置开放相对应的端口。 然后重置并启动 GitLab 执行： 12gitlab-ctl reconfiguregitlab-ctl restart 然后执行： 1gitlab-ctl status 查看 GitLab 运行状态是否正常 访问 GitLab 页面： 输入你配置的ip或者域名来访问 GitLab，如果没有什么异常，会出现如下页面 第一次访问会提示修改密码，你需要按提示修改即可，默认账户名是 12345678至此，GitLab 的安装就算完啦。## 2.配置 postfix 邮件服务发邮件系统我们用 Postfix，SMTP 系统默认是开启的，我们先设置关闭 SMTP，开启 Postfix关闭 SMTP： vim /etc/gitlab/gitlab.rb12找到 #gitlab_rails[‘smtp_enable’] = true12改为 gitlab_rails[‘smtp_enable’] = false12修改后执行 gitlab-ctl reconfigure123456另一种是关闭 Postfix，设置开启 SMTP，相关教程请参考官网[https://doc.gitlab.cc/omnibus/settings/smtp.html](https://doc.gitlab.cc/omnibus/settings/smtp.html)此处以配置 163 邮箱为例： gitlab_rails[‘smtp_enable’] = truegitlab_rails[‘smtp_address’] = “smtp.163.com”gitlab_rails[‘smtp_port’] = 25gitlab_rails[‘smtp_user_name’] = “xxx@163.com”gitlab_rails[‘smtp_password’] = “xxx”gitlab_rails[‘smtp_domain’] = “163.com”gitlab_rails[‘smtp_authentication’] = :logingitlab_rails[‘smtp_enable_starttls_auto’] = truegitlab_rails[‘gitlab_email_from’] = “xxx@163.com”user[“git_user_email”] = “xxx@163.com”12345678910111213登录到 GitLab 并添加一个 GitLab 账户，并添加设置用户的邮箱地址，测试是否可以收到邮件通知，如果创建完成，设置的邮箱收到邮件说明邮件服务没有问题，注意如果没有收到邮件，有时候邮箱会拦截邮件，你在垃圾邮件中看看是否邮件被拦截，如果被拦截，你可以将此邮件添加到白名单中。## 3.其他异常情况处理另外，如果 访问 GitLab 时的速度非常慢，或者报 502 错误，如下图![图4](https://img-blog.csdn.net/20180519142248145?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbnBlbmdmZWk1MjE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)可能是你的服务器配置太低，GitLab 官方建议装 GitLab 的服务器的配置最低要求为：CPU 2核心 + 4GB可用内存(RAM + Swap)。 如果服务器配置过低，可能导致您访问 GitLab的速度过慢，甚至会出现无响应等状况。提示 FirewallD is not running1234说明防火墙未开启！执行 systemctl status firewalld12如果出现 Active: inactive (dead)1234表示防火墙未开启。开启防火墙： systemctl start firewalld12再次查看防火墙状态，如果出现 Active: active (running)` 表示防火墙开启成功。 至此，GitLab的安装、配置就完了。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
        <tag>GitLab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elinker dataapp...-1libarmlibserial_port.so has tex]]></title>
    <url>%2F2017%2F09%2F24%2FElinker%20dataapp...-1libarmlibserial_port.so%20has%20tex%2F</url>
    <content type="text"><![CDATA[如题，今天开发Android串口时的使用android-serialport-api开源库，集成到项目中，然后就崩了，出现了下面的错误： java.lang.UnsatisfiedLinkError: dlopen failed: /data/app/com.../lib/arm/libavcodec.so: has text relocations 从字面的意思大概看出来是：.so库找不到了重定向了 解决方法： 参考： https://stackoverflow.com/questions/32346402/libavcodec-so-has-text-relocations https://stackoverflow.com/questions/22577315/warning-linker-app-process-has-text-relocations-this-is-wasting-memory-and-is https://stackoverflow.com/questions/44870554/ndk-15-breaks-serial-port-library Thanks.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>串口</tag>
        <tag>NDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用起来贼爽的 Android Studio 插件推荐]]></title>
    <url>%2F2017%2F09%2F24%2F%E7%94%A8%E8%B5%B7%E6%9D%A5%E8%B4%BC%E7%88%BD%E7%9A%84Android%20Studio%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90%2F</url>
    <content type="text"><![CDATA[自从从Eclipse转到Android Studio之后，就越来越感觉用的越来越喜欢越来越爽，因为Android Studio支持很多很强大功能的各种插件，除此之外还有Android Studio本身的一些强大功能，而Eclipse是与之不能媲美的，今天的主题是主要给大家介绍一些好用、常用、实用的一些Android Studio插件，接下来我就给大家挨个介绍一下把。 ##1.Android ButterKnife Zelezny 用过的同志肯定知道使用的酸爽了吧，配合ButterKnife实现注解，自动初始化控件，从此就不用写findViewById了，想着就很爽啊，在Activity，Fragment，Adapter中实现布局xml一键自动生成butterknife注解。 使用步骤：1.Android Studio中点击File -&gt; Setting -&gt; Plugin搜索 Android ButterKnife Zelezny 点击安装，完成后重启Android Studio; 2.在工程的build.gradle中的dependencies节点中添加 ‘com.neenbedankt.gradle.plugins:android-apt:1.8’依赖；3.在app的build.gradle中的顶部第二行添加这句apply plugin: ‘com.neenbedankt.android-apt’；4.然后在dependencies节点中添加两个依赖库： 1234compile &apos;com.jakewharton:butterknife:8.4.0&apos; // 添加依赖 apt &apos;com.jakewharton:butterknife-compiler:8.4.0&apos; // 添加apt 5.将鼠标光标放在要生成初始化控件的布局处，然后使用Ctrl+Shift+B选择生成Butterknife注解（每个人的快捷键可能不一样），详情见下图↓ 生成完后的代码效果如下： ##2.GsonFormat GsonFormat是一个快速将json字符串生成一个JavaBean的插件，免去我们根据json字符串手动写对应JavaBean的过程，而且还支持序列化自动生成。 使用方法：1.安装插件，和之前的安装方法一样，搜索安装即可；2.新建一个实体类，然后使用快捷键Alt+Shift+S弹出选择菜单，选择GsonFormat,然后会弹出一个窗口，如下图： 将json串复制到下图框内： 最后点击ok即可，当然我们一般显示点击fromat格式化一下，方便查看，如果有错误或者说少花括号就很容易看出来，json格式错误也会有提示，另外还可以设置使用那种解析json的库比如Gson、Jackson、FastJson等。 ##3.ADB WIFI ADB WIFI是一款使用wifi无线调试你的app的插件，手机无需root权限，就可以很方便地进行无线调试你的应用了，前提是手机和电脑要连接到同一个局域网内。 使用步骤：1.安装插件，和之前的安装方法一样，搜索安装即可；2.先用数据线连接到你要调试应用的手机，然后点击Android Studio导航栏的Tools具体操作如下图↓ 3.拔掉数据线，点击运行，你就会看到你的手机了，然后你就可以尽情的无线调试应用了，是不是很爽？ ##4.FindBugs-IDEA FindBugs-IDEA是一款查找代码中bug的代码审查插件，它可以找出你代码中的一些缺陷和有问题的地方，进而你可以进行代码的优化处理。 使用方法：1.安装插件，和之前的安装方法一样，搜索安装即可；2.选中你想要审查的代码的文件名或者包名，然鼠标点击右键，我们可以选择整个包，单个类文件或者真个module去进行分析； 3.静静地等一会，分析完之后我们就可以看到有bug的地方就会标注出来，接下来我们就去改这些地方就可以了，当然有些也算不算bug，影响不大我们可以不用改了，但是我们尽量在写代码的时候尽量养成一个良好的编码习惯，这样我们就可以提高编码的质量和效率。 下图就是分析完之后的效果： ##5.ETCTranslation ETCTranslation是一个可以对Android Studio中的英文进行翻译的插件，我们在看源码及英文注释的时候，就不用再去查字典了，可以设置鼠标悬停翻译，也可自定义快捷键，这样方便多了。下载地址：https://github.com/Skykai521/ECTranslation安装的时候可以将jar包下载下来导入安装即可。 使用效果如下图： ##6.Android Parcelable Code Generator Android中的序列化有两种方式，分别是实现Serializable接口和Parcelable接口，一般推荐使用Parcelable，只不过我们这种方式要比Serializable方式要繁琐，因此，这个插件就很轻松地帮你实现了。 使用效果如下： ##7.SelectorChapek for Android 这是一个非常酷炫的插件，它可以根据一定命名规则的图片来生成出对应空间的选择器的xml，比如点击按钮的选择器以及按下等效果，有了它从此你的生活就可以自理了。 ##8.AndroidProguardPlugin AndroidProguardPlugin是一个一键生成项目混淆规则代码的插件，它可以很方便的进行个各种开源库及常用混淆配置，安装方法及下载地址如下：下载地址：https://github.com/zhonghanwen/AndroidProguardPlugin 使用步骤：安装完插件之后点击Android Studio导航栏的Edit -&gt; AndroidProGuard即可，弹出对话框后点击ok,如下图： 然后打开混淆文件的proguard-rules.pro，然后Ctrl + V粘贴即可，最后根据你的项目具体修改文件中报红的地方即可。 ##9.Android Postfix completion Android Postfix completion是一个可以自动根据后缀快速完成代码的插件，它强大的自动预览及补全，从此可以很快速、很愉快的coding了… 插件下载地址：https://plugins.jetbrains.com/plugin/7775?pr= 插件教程地址：http://blog.jetbrains.com/idea/2014/03/postfix-completion/ 下图为弹出一个Toast内容为“hello”,你只需输入“hello”.to就会弹出提示，然后选中后回车即可。 ##10.codota codota是一个强大的搜索开源库及代码的插件，它搜集了大量的代码，据说有超过700W的代码实例，另外还提供了Chrome和As插件可供下载。 插件下载地址：https://plugins.jetbrains.com/plugin/7638?pr= 插件官方网址：https://www.codota.com/ 好了，今天的推荐就到这里了，如果你觉得本文对你有帮助，欢迎收藏，欢迎点赞，码字不易，且行且珍惜！ 注：本文为作者原创，转载请注明出处，谢谢！]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Android Studio</tag>
        <tag>Plugin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android OTG 之 USB 转串口模块通讯]]></title>
    <url>%2F2017%2F09%2F24%2FAndroid%20OTG%E4%B9%8BUSB%E8%BD%AC%E4%B8%B2%E5%8F%A3%E6%A8%A1%E5%9D%97%E9%80%9A%E8%AE%AF%2F</url>
    <content type="text"><![CDATA[微信公众号：CodingAndroidCSDN：http://blog.csdn.net/xinpengfei521 1.背景简介我们公司开发了一款室内机平板APP应用，要求平板能去控制智能门锁、等其他智能设备，智能门锁不是我们公司开发的，与我们公司属于合作关系。 2.分析及实现思路 智能门锁的控制是通过使用 433射频（不了解的请百度）来进行通讯的； 平板是没法与智能门锁直接进行通讯，但是厂家提供了一个433通讯模块（支持串口）； 而平板（支持OTG）是支持USB转串口模块的，所以整个流程是可以走通的，如下图 3.主要代码实现3.1初始化USB转串口模块由于我们选用的是CH340模块，我们先导入ch340的 jar 包，然后在代码中检查手机/平板是否支持USB HOST模式，如果支持我们就初始化通讯时的相关参数：波特率、数据位、停止位等，具体的参数看你们之间通讯的协议。初始化完成之后，我们就可以打开USB进行通讯了，同时初始化完成之后我们需要开启一个读取数据的线程，这样，一旦收到数据或者相应的响应包（一般也叫ACK）我们就可以进行相应的处理了。 下面贴上初始化、及开启读取数据线程的代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/** * initialize ch340 parameters. * * @param context Application context. */ public static void initCH340(Context context) &#123; if (context == null) return; Context appContext = context.getApplicationContext(); mUsbManager = (UsbManager) appContext.getSystemService(Context.USB_SERVICE); if (mUsbManager != null) &#123; HashMap&lt;String, UsbDevice&gt; deviceHashMap = mUsbManager.getDeviceList(); for (UsbDevice device : deviceHashMap.values()) &#123; if (device.getProductId() == 29987 &amp;&amp; device.getVendorId() == 6790) &#123; mUsbDevice = device; if (mUsbManager.hasPermission(device)) &#123; loadDriver(appContext, mUsbManager); &#125; else &#123; if (listener != null) &#123; listener.result(false); &#125; &#125; break; &#125; &#125; &#125; &#125; /** * load ch340 driver. * * @param appContext * @param usbManager */ public static void loadDriver(Context appContext, UsbManager usbManager) &#123; driver = new CH34xUARTDriver(usbManager, appContext, ACTION_USB_PERMISSION); // 判断系统是否支持USB HOST if (!driver.UsbFeatureSupported()) &#123; InLog.e(TAG, &quot;Your mobile phone does not support USB HOST, please change other phones to try again!&quot;); &#125; else &#123; openCH340(); &#125; &#125; /** * config and open ch340. */ private static void openCH340() &#123; int ret_val = driver.ResumeUsbList(); InLog.d(TAG, ret_val + &quot;&quot;); // ResumeUsbList方法用于枚举CH34X设备以及打开相关设备 if (ret_val == -1) &#123; InLog.d(TAG, ret_val + &quot;Failed to open device!&quot;); driver.CloseDevice(); &#125; else if (ret_val == 0) &#123; if (!driver.UartInit()) &#123; //对串口设备进行初始化操作 InLog.d(TAG, ret_val + &quot;Failed device initialization!&quot;); InLog.d(TAG, ret_val + &quot;Failed to open device!&quot;); return; &#125; InLog.d(TAG, ret_val + &quot;Open device successfully!&quot;); if (!isOpenDeviceCH340) &#123; isOpenDeviceCH340 = true; configParameters();//配置ch340的参数、需要先配置参数 &#125; &#125; else &#123; InLog.d(TAG, &quot;The phone couldn&apos;t find the device！&quot;); &#125; &#125; /** * config ch340 parameters. * 配置串口波特率，函数说明可参照编程手册 */ private static void configParameters() &#123; if (driver.SetConfig(baudRate, dataBit, stopBit, parity, flowControl)) &#123; InLog.d(TAG, &quot;Successful serial port Settings！&quot;); if (readDataRunnable == null) &#123; readDataRunnable = new ReadDataRunnable(); &#125; mThreadPool.execute(readDataRunnable); &#125; else &#123; InLog.d(TAG, &quot;Serial port Settings failed！&quot;); &#125; &#125; 3.2发送和接收数据发送和接收数据都是按16进制进行发送和处理的，所以我们写了一个工具类方便发送，如下： 1234567891011121314151617181920212223242526272829303132333435363738/** * Created by xpf on 2018/2/6 :) * Function:CH340数据处理工具类 */public class CH340Util &#123; /** * write data in ch340. * * @param byteArray 字节数组 * @return 返回写入的结果，-1表示写入失败！ */ public static int writeData(@NonNull byte[] byteArray) &#123; // 将此处收到的数组转化为HexString String hexString = bytesToHexString(byteArray, byteArray.length); InLog.i(&quot;TAG&quot;, &quot;WriteHexString===&quot; + hexString); return InitCH340.getDriver().WriteData(byteArray, byteArray.length); &#125; /** * byte[]转换为hexString * * @param buffer 数据 * @param size 字符数 * @return 返回转换后的十六进制字符串 */ public static String bytesToHexString(byte[] buffer, final int size) &#123; StringBuilder stringBuilder = new StringBuilder(&quot;&quot;); if (buffer == null || size &lt;= 0) return null; for (int i = 0; i &lt; size; i++) &#123; String hex = Integer.toHexString(buffer[i] &amp; 0xff); if (hex.length() &lt; 2) stringBuilder.append(0); stringBuilder.append(hex); &#125; return stringBuilder.toString(); &#125;&#125; 然后基本的发送和接收数据就写完了，发送数据时调用 writeData() 方法就可以了，接收数据也类似，具体的业务及通讯的协议、加密规则等都需要你和硬件提供方进行协商对接制定，由于涉及到公司机密，此处我就不进行说明了，只说一下最基本的发送和接收数据。 4.插入模块实现自动打开APPAndroid中USB的插拔都会发送一个广播，我们只需要在AndroidMenifest.xml文件中接收这个广播就可以了，当我们入模块的时候就会启动我们的APP,第一次会弹出一个对话框询问我们是否打开xxx应用，我们点击确认即可，另外不是我们插入任何USB设备都打开我们的应用，所以我们需要过滤掉对我们没有用的设备，在res下建一个xml目录，新建usb_filter.xml文件，配置好我们这个USB设备模块的product-id和vendor-id，每个模块厂家这个值都是不一样的，有两种获取方式，一个是代码中枚举USB设备然后打印出来，另外一种方法是打开Logcat观察，然后插入USB设备，你会发现系统会打印出来这个USB设备等信息。 最后不要忘了添加权限： 12345&lt;uses-feature android:name=&quot;android.hardware.usb.host&quot; android:required=&quot;true&quot; /&gt; &lt;uses-permission android:name=&quot;android.hardware.usb.host&quot; /&gt; 此处由于篇幅原因就不具体展开讲解更多细节了，核心的代码和实现我都已经贴出来了，要想查看更具体的实现，请下载我的demo: https://github.com/xinpengfei520/USB-OTG-CH340-UART-interface 若在阅读过程中遇到什么问题，或有好提议，欢迎在公众号“CodingAndroid”中提出 长按后点击扫一扫关注！]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>OTG</tag>
        <tag>USB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Picasso 不缓存图片]]></title>
    <url>%2F2017%2F09%2F24%2FAndroid%20Picasso%E4%B8%8D%E7%BC%93%E5%AD%98%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[问题描述：大多APP都有更换个人头像的功能，楼主在开发中遇到了当更换头像时，头像没有更换过来的问题，我用的是Picasso图片请求框架，而这些加载图片的框架一般都会有三级缓存策略，当我们去加载一张图片的时候就会优先查找本地有没有，当一张图片已经加载过了之后就会缓存到本地，虽然我们更换了头像，但是图片的url没有变，所以再次加载的时候还是原来本地缓存的图片，而不是新的图片，所以我们在加载图片的时候可以设置不进行缓存即可，这样每次修改完头像就加载的是新的头像了… 写法如下： Picasso.with(mContext).load(&quot;http://&quot; + headpic).memoryPolicy(MemoryPolicy.NO_CACHE).transform(new CircleTransform(mContext)).into(ivIcon); 其中.memoryPolicy(MemoryPolicy.NO_CACHE)这句的意思就是不进行缓存。 最后，感谢参考了下面的文章： thanks all.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Picasso</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 中 equals 与 == 区别]]></title>
    <url>%2F2017%2F09%2F24%2FJava%E4%B8%ADequals%E4%B8%8E%3D%3D%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[==是运算符而equals是比较方法。 ##1、==运算符 （1）基本数据类型比较值:只要两个变量的值相等，即为true注意：当基本数据类型使用“==”进行比较时，符号两边的数据必须类型兼容（类型相同或可自动类型转换），否则编译出错； （2）引用类型比较引用：比较两个对象的地址值，两个引用变量指向同一个对象的堆空间时，才为true 1234Person p1=new Person(); Person p2=new Person();if(p1==p2) //falsep1=p2;//如果有这样的赋值语句后 if(p1==p2) //true 注意：当引用类型使用“==”进行比较时，符号两边的数据类型必须兼容（类型相同或有父子类关系），否则编译出错； 12345Person p=new Person();String str=&quot;hello&quot;;if(p==str)//错误，p和String类型不兼容，Person和String类型无父子类关系Student stu = new Student();//Student extends Personif(p==stu)//编译通过 ##2、equals方法 （1）equals()：所有类都继承了Object，也就获得了equals()方法。（2）自定义类可以重写equals方法注意：如果一个类型没有重写过equals方法，那么调用equals等价于== 123456789101112131415public class Test &#123; public static void main(String[] args) &#123; Person p1=new Person(); Person p2=new Person(); if(p1==p2)&#123; &#125; if(p1.equals(p2))&#123; //因为这里Person类没重写equals方法，那么p1.equals(p2)等价于p1==p2 &#125; &#125;&#125;class Person&#123; &#125; （3）类String及包装类（Wrapper Class）等来说，JDK已经重写过equals方法，重写过的equals方法比较的是两个对象的类型及内容String str1=new String(“hello”);String str2=new String(“hello”);if(str1.equals(str2))//true，比较的是字符串的内容。 ##3、常量值 （1）字符串常量值 12345String str1=&quot;hello&quot;;String str2=&quot;hello&quot;;String str3=new String(&quot;hello&quot;);System.out.println(str1==str2);//trueSystem.out.println(str1==str3);//false]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>equals</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Failed to resolve com.android.support]]></title>
    <url>%2F2017%2F09%2F24%2FFailed%20to%20resolve%20com.android.support%2F</url>
    <content type="text"><![CDATA[楼主在编译一个 module 时，遇到了如下错误一直编译不过去 报错如下： 1Failed to resolve com.android.support 刚开始自己写了一个 module demo 编译、运行都没有问题，然后又新建了一个 module，因为在新建之前看到编译好的 module 中有个 xml 文件，感觉命名不好，就 Refactor -&gt; Rename 了一下，重命名了一下文件，一般在重命名的时候 AS 会弹出提示你是否在调用的地方也进行重命名，结果我就直接一路Refactor了，因为之前也是这样修改的，没有出过问题，然后在编译的时候就出现了上面的错误，然后定位到这一行依赖这里： 1implementation &apos;com.android.support:appcompat-v7:27.1.1&apos; 我看了一下，毛线，这是系统生成的还能写错?为了不打脸，我还是复制了一行好的比对了一下，没有问题的，我看了一下网络，网络也没有问题啊，这不科学呀，懵逼中… 于是乎，打开百度，输入如上错误，点击搜索，看到了一篇博主的文章： https://blog.csdn.net/mhl18820672087/article/details/78385361 我看了一下，我的构建版本的工具是没有任何问题的，因为其他 module 都能编译过，就这一个 module 编译不通过，任然没有解决我的问题，打开我编译不过的 module 的 build.gradle 文件，细心的我发现了一个问题，看下图标红的地方： test_page 这尼玛是什么鬼？这不是我刚才重命名的名字么？它竟然给我把这个地方的 test 重命名成了 test_page，真是无语了，第一次见这种错，我都没调用，你给我乱重命名，有点说不过去了哦，胸die! 至此，问题算是解决完了… 我发现新版本的 Android Studio 是越来越好用，但是会频繁的出现一些莫名奇葩的问题，大家遇到过吗？]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Failed</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Runtime(ART) 介绍]]></title>
    <url>%2F2017%2F09%2F24%2FAndroid%20Runtime(ART)%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[1.English原版https://www.anandtech.com/print/8231/a-closer-look-at-android-runtime-art-in-android-l 2.翻译版本http://tieba.baidu.com/p/3149769993 感谢贴吧的楼主翻译，很详细、很标准，大赞！！!]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Runtime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ListView 设置分割线]]></title>
    <url>%2F2017%2F09%2F24%2FListView%E8%AE%BE%E7%BD%AE%E5%88%86%E5%89%B2%E7%BA%BF%2F</url>
    <content type="text"><![CDATA[##1.设置分割的颜色和高度 divider设置分割线的颜色属性； dividerHeight设置分割线的高度； 123456789&lt;ListView android:id=&quot;@+id/listView&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;@dimen/margin_14dp&quot; android:layout_marginRight=&quot;@dimen/margin_14dp&quot; android:layout_marginTop=&quot;@dimen/margin_8dp&quot; android:divider=&quot;@color/transparent&quot; android:dividerHeight=&quot;8dp&quot; /&gt; ##2.去掉分割线 1.在代码中设置：setDriver(null)； 2.或者在布局文件中设置：android:divider=”@null”； 3.如果没有背景也可将divider设置为透明也可以实现隐藏分割线的效果，但是这种方式分割线还是存在的，并且占了一定的高度，只是隐藏显示了而已； 更多关于ListView的文章请参考： http://blog.csdn.net/bdmh/article/details/39522071 http://blog.csdn.net/fly_yuge/article/details/52473978 http://blog.csdn.net/lovexieyuan520/article/details/50846569 http://blog.csdn.net/zhangphil/article/details/48948217 http://www.cnblogs.com/SZ2015/p/4558462.html http://flycatdeng.iteye.com/blog/2273790 http://www.cnblogs.com/zhujiabin/p/5818091.html http://blog.csdn.net/world_kun/article/details/51545234]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>ListView</tag>
        <tag>widget</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java输入日期计算是这年的第几天]]></title>
    <url>%2F2017%2F09%2F24%2FJava%E8%BE%93%E5%85%A5%E6%97%A5%E6%9C%9F%E8%AE%A1%E7%AE%97%E6%98%AF%E8%BF%99%E5%B9%B4%E7%9A%84%E7%AC%AC%E5%87%A0%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[1.思路 通过年份区分出是闰年还是平年，平年 2 月 28 年，闰年 2 月 29 天； 1、3、5、7、8、10、12 月份 31 天其余月份均为 30 天； 然后将每个月的天数相加即可，注意如果输入的是 12 月份，则是从 11 月份往前累加到1月份，1月份加的是输入的天数； 2.实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.util.Scanner;/** * Created by xpf on 2018/6/22 :) * GitHub:xinpengfei520 * Function: */public class CalculateUtils &#123; /*平年二月28天*/ private static final int DAYS_28 = 28; /*闰年二月29天*/ private static final int DAYS_29 = 29; /*除了31天的月份其他均为30天*/ private static final int DAYS_30 = 30; /*1、3、5、7、8、10、12月份31天*/ private static final int DAYS_31 = 31; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); System.out.println(&quot;Please input year:&quot;); int year = input.nextInt(); System.out.println(&quot;Please input month:&quot;); int month = input.nextInt(); System.out.println(&quot;Please input day:&quot;); int day = input.nextInt(); int daysInYear = getDaysInYear(year, month, day); System.out.println(&quot;daysInYear:&quot; + daysInYear); &#125; /** * get days in this year * * @param year * @param month * @param day * @return */ public static int getDaysInYear(int year, int month, int day) &#123; int totalDays = 0; switch (month) &#123; // 12 月份加的是11月份的天数，依次类推 case 12: totalDays += DAYS_30; case 11: totalDays += DAYS_31; case 10: totalDays += DAYS_30; case 9: totalDays += DAYS_31; case 8: totalDays += DAYS_31; case 7: totalDays += DAYS_30; case 6: totalDays += DAYS_31; case 5: totalDays += DAYS_30; case 4: totalDays += DAYS_31; case 3: // 判断是否是闰年 if (((year / 4 == 0) &amp;&amp; (year / 100 != 0)) || (year / 400 == 0)) &#123; totalDays += DAYS_29; &#125; else &#123; totalDays += DAYS_28; &#125; case 2: totalDays += DAYS_31; case 1: // 如果是1月份就加上输入的天数 totalDays += day; &#125; return totalDays; &#125;&#125; 3.思考因为只有2月份的天数和输入的 day 天数是不固定的，其他月份的天数是固定的，而固定的天数是可以通过输入的月份算出来，这样我们就可以这样计算： 12 月份的天数 + 输入的天数 + 计算出来的固定天数 如果大家还有其他的更好的优化的都可以在下面评论。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java内存管理与垃圾回收]]></title>
    <url>%2F2017%2F09%2F24%2FJava%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%2F</url>
    <content type="text"><![CDATA[一、内存简介根据《Java虚拟机规范（第2版）》的规定，Java虚拟机所管理的内存将会包括以下几个运行时数据区域，如下图所示： 经常人把Java内存区分为堆内存（Heap）和栈内存（Stack），这种分法比较粗糙，Java内存区域的划分实际上远比这复杂。这种划分方式的流行是因为大多数程序员最关注的、与对象内存分配关系最密切的内存区域是这两块。通常所说的堆（Heap），此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配。通常所说的栈（Stack），是指虚拟机栈。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。局部变量表存放了编译期可知长度的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不等同于对象本身，是对象在堆内存的首地址）。因此局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。 方法执行完，自动释放。方法区（Method Area）用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 二、垃圾回收机制垃圾回收（Garbage Collection，GC）：在程序的运行环境中，JVM（Java虚拟机）提供了一个系统级的垃圾回收器线程，它负责自动回收那些无用对象所占用的堆内存。这种内存回收的过程被称为垃圾回收。 Java语言中，内存回收任务由JVM来担当。Java的垃圾回收机制是JVM提供的能力，由单独的系统级垃圾回收线程在空闲时间以不定时的方式动态回收无任何引用的对象占据的堆内存空间。 （1）程序只能决定一个对象不再被任何引用变量引用，使得它成为可以被回收的垃圾。类比：决定什么样的东西扔掉 （2）不能决定垃圾回收的时间。垃圾回收器作为低优先级线程独立运行。在任何时候，程序都无法迫使垃圾回收器立即执行垃圾会后操作。类比：居民把无用物品放在指定的地方，清洁工人会把它收拾走。但垃圾被收走的时间，居民是不知道的，也无需了解。 （3）程序中可调用System.gc()或Runtime.gc()方法提示垃圾回收器尽快执行垃圾回收操作，但是不能保证调用后垃圾回收器会立即执行垃圾回收。类比：小区垃圾成堆时，居民打电话给环保局，催促清洁工尽快来处理垃圾。但是清洁工不一定立即就来了，也有可能很长时间后再来。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>内存管理</tag>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Multiple dex files define Lokhttp3/internal/wsWebSocketProtocol]]></title>
    <url>%2F2017%2F09%2F24%2FMultiple%20dex%20files%20define%20Lokhttp3internalwsWebSocketProtocol%2F</url>
    <content type="text"><![CDATA[##老套路，先晒图 图一：如题，在编译打包时遇到了如上错误，很明显这是一个依赖库冲突的问题，我的app下依赖一个 ad library,而 ad library有依赖了一个 http library,这是一个我用okhttp封装的网络请求库，而 ad library 又依赖了 compile ‘com.squareup.okhttp3:okhttp:3.9.1’ 这依赖关系确实有点混乱，那这时候有人说了，你的 ad library为什么不用 http library里面的okhttp呢？自从AS3.0 gradle4.0开始依赖使用 implementation 代替了 compile 关键字，因此 compile 就被过期了，http 虽然依赖了 okhttp ，但是 ad library要想使用 okhttp 是不可以的，因为使用implementation 对于ad library 是不可见的，所以ad library又依赖了一次 compile ‘com.squareup.okhttp3:okhttp:3.9.1’ 因为 ad library需要单独的进行定制化的网络请求配置，所以 ad library中的网络请求是没有封装进http library中的，所以导致了重复依赖的问题，使用 implementation 关键字虽然可以屏蔽ad library访问 http library中 okhttp 的api,但是依赖冲突的问题确实还是存在的… 于是乎，网上搜了一篇帖子： https://stackoverflow.com/questions/45111497/android-gradle-failed-multiple-dex-files-define-okhttp 看来一下和我的情况一毛一样，报的错误也一样，直接戳到Answer处，解决方式如下 图二： 然后直接去除掉重复的依赖，修改如下后，再rebuild 图三： 心里想着，这个问题终于解决了，喝了口水，长呼了一口气。。。 我擦，竟然又爆红了，我勒个去，什么情况？这不科学啊，什么鬼？心里很郁闷，这是为什么呢？ 不行啊，看来我必须要放大招了，心里开始仔细揣摩了，认真想想，绝逼哪里肯定是有问题的，start thinking… 认真起来的男人是最帅的 0.0~ 仔细看了看http library中的 okhttp 是3.3.1,而 ad library中的 okhttp 3.9.1,忽然想起来之前遇到过同时依赖两个不同版本的库也会出现这样的问题，于是，灵光一现，立马把版本号改一样试试，修改后如下: 图四： 然后再rebuild… oh yeah ~ 搞定，就是这么6… 怎一个爽快了得？ 好了，今天就分享这么多吧，一来呢总结一下自己遇到的一些问题及解决办法，如果你也遇到，希望能帮助到你们，二来呢，希望大家如果真的帮助到你们了，麻烦你们给我点个赞或者在文章底部给我评论，或者你有什么意见或者意见都可以相互交流，谢谢你们！ --------一个逗比的码农和一个逗比的故事，如果想看到更多的文章，请点左侧头像下面的关注！]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Excepiton</tag>
        <tag>okhttp3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出 Retrofit2.x (一)]]></title>
    <url>%2F2017%2F09%2F24%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BARetrofit2.x(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[点击上面蓝色字体关注“IT大飞说” 在 Android 开发中，从最原生的 HttpClient 和后来的 HttpUrlConnection，再到Volley、AsyncHttpClient 等网络请求框架，最后到 Square 公司开源的 okhttp，一时间 okhttp 风靡整个开发圈，进而衍生了好多大牛对 okhttp 的封装开源库，像鸿洋大神封装的 okhttputils，还有 Okgo … 然后就是 Retrofit 了，其实它也是对 okhttp 的封装，Retrofit 使得网络请求更优雅，灵活性更高，支持各种适配器和转换器，可以搭配 RxJava 一起使用，一度后来基于 RxJava + Retrofit + MVP 这种架构设计非常流行，网上关于这种的文章也更是层出不穷，目前 retrofit 在 GitHub 上有将近 3w 的 Star，目前可以说是非常稳定了。 1.初识 Retrofit简单说，Retrofit 是一个支持 RESTful api 架构的 http 网络请求框架的封装库，Retrofit 封装了许多自定义的注解，大大方便和简化了使用，另外灵活性也更高，底层采用 okhttp 实现真正的网络请求，他们的关系可以说是分工协作吧，总结一成一句话就是：Retrofit 让 okhttp 网络请求更优雅！ 他们的关系可以看下图可能更容易理解： 2.小牛试刀2.1我们先来个简单的 GET 请求首先在 Gradle 中添加 Retrofit 的依赖： 'com.squareup.retrofit2:retrofit:2.3.0'```12然后我们定义一个接口： public interface GithubService { @GET(&quot;/users/xinpengfei520&quot;) Call&lt;ResponseBody&gt; getUserString(); }1234解释一下上面接口中的注解 **@GET**，这个代表 **HTTP** 的请求类型，同理 **@POST，@PUT，@DELETE,@HEAD,@PATCH** 分别代表 POST、PUT 和 DELETE、HEAD、PATCH 请求；括号中的字符串 **&quot;/users/xinpengfei520&quot;** 代表注解 **@GET** 的值，这里指的是 URL 中的 Path，请求的时候会拼接到BASE_URL 后面，BASE_URL 在构建 Retrofit 的时候设置，**Call&lt;ResponseBody&gt;** 中的 Call 为方法的返回值类型，ResponseBody 为方法的返回值类型的泛型。接下来，我们构建一个 Retrofit 对象： Retrofit retrofit = new Retrofit.Builder() .baseUrl(“https://api.github.com&quot;) .build();1234非常简单吧，这里使用了构建者模式，方便我们动态的配置各种参数，baseUrl 就是服务器的 HOST，一般是域名或者 ip，通常都带有端口，baseUrl 是一定要设置的，否则会抛异常 ```throw new IllegalStateException(&quot;Base URL required.&quot;)```。然后，我们来进行一个异步请求： GithubService service = retrofit.create(GithubService.class); Call&lt;ResponseBody&gt; call = service.getUserString(); call.enqueue(new Callback&lt;ResponseBody&gt;() { @Override public void onResponse(Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response) { String json = response.body().string(); } @Override public void onFailure(Call&lt;ResponseBody&gt; call, Throwable t) { } }); 1234上面的代码中先调用 Retrofit 的 create() 方法，方法的参数就是我们定义的接口的 class，create 的内部实现是使用了 Java 中的动态代理模式，考虑到一些基础比较差的同学，关于动态代理，我这里简单的解释一下：代理类在程序运行时创建的代理方式被成为动态代理，代理类并不是在Java代码中定义的，而是在运行时在 Java 代码中动态生成的，当我们使用代理对象执行代理对象的方法时，都会被替换成执行invoke方法，在 invoke 方法中可以拿到代理对象，代理对象的方法及参数，当然这里也涉及到一些反射相关的知识，这里就不详细展开了；结合上面的代码，service 就是代理对象，当 service 调用 getUserString() 方法时，就会触发 invoke 方法，进而通过反射可以拿到代理对象，方法及参数，具体的细节就不详细讲了，感兴趣的同学可以读 Retrofit 的源码进行理解；上面代码中拿到call 后就是网络请求了，一个成功和一个失败的回调方法，这样一次完整的Retrofit的网络请求就算完了。另外我们还可以使用Retrofit的同步请求接口(注意要放在子线程中请求)： Response response = call.execute();1234### 2.2 优化接口定义在上面的请求中，很明显我们定义的 GitHubService 接口中的方法的注解的值是写死的，假如我们有另一个请求的接口是 ```https://api.github.com/users/zhangsan``` 也就是说 Path 是 ```/users/zhangsan```，要想请求的话，有两种方式，在之前定义的接口中再增加一个方法，或者另外再重新定义一个接口，这样比较比较麻烦了，通用性和扩展性都不好，和之前定义的接口比较一下，只有 **users/** 后面的内容不同，我们想如果这个可以动态作为传入就好了？当然是可以的，我们可以这样写： public interface GitHubService { @GET(“/users/{user}”) Call getUserString(@Path(“user”) String user);}123456789101112131415161718192021222324252627上面代码中的user作为方法的参数传进来，并且我们使用了@Path注解，然后我们在@GET注解的值中使用 **&#123;user&#125;** 动态获取传进来的 user 的值，这样就达到了动态替换的效果，好了我们又学会了使用**@Path** 注解了，好棒棒！不过在使用 **@Path** 注解时应该注意一下几点:- 使用@Path时，Path对应的路径不能包含”/”，否则会将其转化为 %2F，在遇到想动态的拼接多节url时，还是使用@Url；- @Path只是用来做一层路径，如果路经是多层的，可以用多个@Path，或者用@Url；- 如果非要使用 @Path 注解来传入多层路径，那就必须指定 @Path的 encoded = true；### 2.3 进一步优化通过上面的网络请求测试，感觉和其他网络请求也没什么两样啊，除了使用了 @Path 注解外，好像发现没什么好用的地方？跟你说 Retrofit 能着呢，别人能干的它都能干，别人不能干的它也能干！先别急，我们先慢慢一步一步来了解她，慢慢的你就会发现她的美！就和有的妹子一样，见第一眼觉得不怎么样，但是处的时间长了，你就会发现她越来越漂亮，越看越美...Retrofit 可以灵活的配置各种转换器，转换器什么鬼？通俗地讲，转换器的意思就是把一种数据类型解析并转换成另一种数据类型，现在不理解没关系，往后面看你就会明白，Retrofit支持的转换器有：1. Gson: com.squareup.retrofit2:converter-gson2. Jackson: com.squareup.retrofit2:converter-jackson3. Moshi: com.squareup.retrofit2:converter-moshi4. Protobuf: com.squareup.retrofit2:converter-protobuf5. Wire: com.squareup.retrofit2:converter-wire6. Simple XML: com.squareup.retrofit2:converter-simplexml7. Scalars (primitives, boxed, and String): com.squareup.retrofit2:converter-scalars一般情况下，我们使用 Gson 转换器比较多一些，现在我们就来试试转换器的威力吧。首先在 Gradle 中添加依赖:```implementation &apos;com.squareup.retrofit2:converter-gson:2.3.0&apos; 接下来我们在创建Retrofit 对象的时候设置它的转换器，代码如下： 1234Retrofit retrofit = new Retrofit.Builder() .baseUrl(&quot;https://api.github.com&quot;) .addConverterFactory(GsonConverterFactory.create()) .build(); 然后我们创建一个实体类 GithubUserBean，这个类其实就是上面接口返回数据对应的实体类，我们直接用 GsonFormat 插件自动生成即可。 下一步，我们再修改接口中返回值类型的泛型，修改后如下： 12345public interface GithubService &#123; @GET(&quot;/users/&#123;user&#125;&quot;) Call&lt;GithubUserBean&gt; getUserString(@Path(&quot;user&quot;) String user);&#125; 最后，我们再来发起一个异步请求： 12345678910111213GithubService service = retrofit.create(GithubService.class); Call&lt;GithubUserBean&gt; call = service.getUserString(&quot;xinpengfei520&quot;); call.enqueue(new Callback&lt;GithubUserBean&gt;() &#123; @Override public void onResponse(Call&lt;GithubUserBean&gt; call, Response&lt;GithubUserBean&gt; response) &#123; GithubUserBean userBean = response.body(); &#125; @Override public void onFailure(Call&lt;GithubUserBean&gt; call, Throwable t) &#123; &#125; &#125;); 看上面的代码，仔细的你可能已经发现了，当请求接口成功时，我们拿到的直接就是对应的实体类了，不需要再解析了，这是因为 Retrofit 内部会根据这个转换工厂及返回数据所指定的泛型自动帮你直接转换成Bean了，就问你爽不爽？怎一个爽字了得？简直帅呆了！有木有？ 注意：接口中返回值类型Call的泛型要么是 ResponseBody，要么是实体类，不支持其他类型！ResponseBody 的子类也不行！ 本来打算写一两篇文章来介绍 Retrofit 的，结果发现一两篇文章的根本讲不清楚，因为涉及的知识比较多，另一方面如果是一两篇文章的话，可能篇幅比较长，读者很难坚持读下去，还有我写的时候考虑的东西也比较多，我觉得我的文章应该是面向大众的，尽可能覆盖到大多数的读者，包括一些初学者，由浅入深，由粗到细，这样才能便于大家更好的学习理解，文章中一些东西比较基础，对于觉得会的简单的直接跳过即可，后面的系列文章，我会写一些比较进阶的用法，从源码角度进行分析，便于大家更好的理解。 好了，今天的分享就到这里，我还是你们的大飞哥，一个不止会敲代码的厨师！ 推荐阅读：给大家推荐一个神器MySQL8.0设置远程访问权限不得不会的10点Java基础知识CentOS7 重置 MySQL 8.0 密码 大飞哥，带你飞，关注大飞不迷路!可能不是最好的公众号，但肯定是最良心的公众号!]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Retrofit2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Picasso 实现圆形图片和圆角图片]]></title>
    <url>%2F2017%2F09%2F24%2FAndroid%20Picasso%E5%AE%9E%E7%8E%B0%E5%9C%86%E5%BD%A2%E5%9B%BE%E7%89%87%E5%92%8C%E5%9C%86%E8%A7%92%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[##1.实现圆形图片 ###1.1代码调用如下 12Picasso.with(mContext).load(headpic).memoryPolicy(MemoryPolicy.NO_CACHE) .transform(new CircleTransform(mContext)).into(ivIcon); ###1.2自定义圆形图片处理工具类(可以修改圆形图片的半径) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import android.content.Context;import android.graphics.Bitmap;import android.graphics.BitmapShader;import android.graphics.Canvas;import android.graphics.Paint;import com.squareup.picasso.Transformation;/** * Created by xpf on 2017/4/8 :) * Function:Picasso Transformation 实现圆形图片 */public class CircleTransform implements Transformation &#123; private Context mContext; private int radius; // 圆形图片半径 public CircleTransform(Context context) &#123; mContext = context; radius = DensityUtil.dp2px(mContext, 10); &#125; @Override public Bitmap transform(Bitmap source) &#123; int size = Math.min(source.getWidth(), source.getHeight()); int x = (source.getWidth() - size) / 2; int y = (source.getHeight() - size) / 2; Bitmap squaredBitmap = Bitmap.createBitmap(source, x, y, size, size); if (squaredBitmap != source) &#123; source.recycle(); &#125; Bitmap bitmap = Bitmap.createBitmap(size, size, source.getConfig()); Canvas canvas = new Canvas(bitmap); Paint paint = new Paint(); BitmapShader shader = new BitmapShader(squaredBitmap, BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP); paint.setShader(shader); paint.setAntiAlias(true); float r = size / 2f;// float r = radius; canvas.drawCircle(r, r, r, paint); squaredBitmap.recycle(); return bitmap; &#125; @Override public String key() &#123; return &quot;circle&quot;; &#125;&#125; ##2.实现圆角图片 ###2.1代码调用如下 12Picasso.with(mContext).load(headpic).memoryPolicy(MemoryPolicy.NO_CACHE) .transform(new RoundTransform(mContext)).into(ivIcon); ###2.2自定义圆角图片处理工具类(可以修改图片圆角的半径) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import android.content.Context;import android.graphics.Bitmap;import android.graphics.Canvas;import android.graphics.Paint;import android.graphics.PorterDuff;import android.graphics.PorterDuffXfermode;import android.graphics.Rect;import android.graphics.RectF;import com.squareup.picasso.Transformation;/** * Created by xpf on 2017/4/8 :) * Function:Picasso Transformation 实现圆角图片 */public class RoundTransform implements Transformation &#123; private Context mContext; public RoundTransform(Context context) &#123; mContext = context; &#125; @Override public Bitmap transform(Bitmap source) &#123; int widthLight = source.getWidth(); int heightLight = source.getHeight(); int radius = DensityUtil.dp2px(mContext, 8); // 圆角半径 Bitmap output = Bitmap.createBitmap(source.getWidth(), source.getHeight(), Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(output); Paint paintColor = new Paint(); paintColor.setFlags(Paint.ANTI_ALIAS_FLAG); RectF rectF = new RectF(new Rect(0, 0, widthLight, heightLight)); canvas.drawRoundRect(rectF, radius, radius, paintColor);// canvas.drawRoundRect(rectF, widthLight / 5, heightLight / 5, paintColor); Paint paintImage = new Paint(); paintImage.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_ATOP)); canvas.drawBitmap(source, 0, 0, paintImage); source.recycle(); return output; &#125; @Override public String key() &#123; return &quot;roundcorner&quot;; &#125;&#125; 今天就到这里吧… 下篇预告：Android Glide实现圆形图片和圆角图片 敬请期待…]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Picasso</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Service 启动到 Activity]]></title>
    <url>%2F2017%2F09%2F24%2FAndroid%20Service%E5%90%AF%E5%8A%A8%E5%88%B0Activity%2F</url>
    <content type="text"><![CDATA[从Service启动到Activity基本可以分为两类：1.从自己应用的Service启动自己应用的Activity,即显式意图；2.从自己应用的Service启动到其他应用的Activity,或者从别的应用的Service启动到自己应用的Activity，即隐式意图； ##1.显式意图启动 下面为示例写法： 123Intent intent = new Intent(EmqttService.this, CallingActivity.class); intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); startActivity(intent); ##2.隐式意图启动 需要在manifest.xml中为该Activity配置12 &lt;activity android:name=&quot;.CallingActivity&quot; &gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.call&quot;&gt;&lt;/action&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 12在要启动的Service里这样写： Intent i = new Intent(&quot;com.call&quot;); i.addCategory(Intent.CATEGORY_DEFAULT); i.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); startActivity(i); ` 注意“com.call”为要启动Activity的Action. ##3.为什么Android在Service 里面启动Activity要强制规定使用参数FLAG_ACTIVITY_NEW_TASK呢？ 我们可以来做这样一个假设，我们有这样一个需求：我们在电话本里面启动一个Service，然后它执行5分钟后，启动一个Activity那么很有可能用户在5分钟后已经不在电话本程序里面操作了，有可能去上网，打开浏览器程序了。5分钟后，此时当前的Task是浏览器的task，那么弹出Activity，如果这个Activity在当前Task的话，也就是浏览器的Task；那么用户就会觉得莫名其妙；因为弹出的Activity和浏览器在一个Task，本来这个Activity应该属于电话本的。所以，对于Service而言，干脆强制定义启动的Activity要创建一个新的Task.这种设计，我觉得还是比较合理的。 最后感谢参考文章： Thanks all.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Activity</tag>
        <tag>Service</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android SharedPreferences 工具类]]></title>
    <url>%2F2017%2F09%2F24%2FAndroid%20SharedPreference%E5%B7%A5%E5%85%B7%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[###新建一个SpUtil工具类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * Created by xpf on 2017/03/25 :) * Function: sp存储的工具类 */public class SpUtil &#123; private static final String ANLEKE = &quot;anleke&quot;; private SpUtil() &#123; &#125; private static SpUtil instace = new SpUtil(); private static SharedPreferences mSp = null; public static SpUtil getInstace() &#123; if (mSp == null) &#123; mSp = MyApplication.getContext().getSharedPreferences(ANLEKE, Context.MODE_PRIVATE); &#125; return instace; &#125; /** * 保存数据 * * @param key 键 * @param value 值 */ public void save(String key, Object value) &#123; if (value instanceof String) &#123; mSp.edit().putString(key, (String) value).commit(); &#125; else if (value instanceof Boolean) &#123; mSp.edit().putBoolean(key, (Boolean) value).commit(); &#125; else if (value instanceof Integer) &#123; mSp.edit().putInt(key, (Integer) value).commit(); &#125; &#125; // 读取String类型数据 public String getString(String key, String defValue) &#123; return mSp.getString(key, defValue); &#125; // 读取boolean类型数据 public boolean getBoolean(String key, boolean defValue) &#123; return mSp.getBoolean(key, defValue); &#125; // 读取int类型数据 public int getInt(String key, int defValue) &#123; return mSp.getInt(key, defValue); &#125;&#125; ###注：在MyApplication中获取上下文 123456789101112private static Context mContext; @Override public void onCreate() &#123; super.onCreate(); mContext = this; &#125; // 获取全局上下文 public static Context getContext() &#123; return mContext; &#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>SharedPreferences</tag>
        <tag>工具类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio 3.1.0 升级问题记录]]></title>
    <url>%2F2017%2F09%2F24%2FAndroid%20Studio3.1.0%E5%8D%87%E7%BA%A7%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[每次升级Android Studio时，一般情况下 Gradle 版本的也会相应的升级，我之前Android Studio 3.0.1、Gradle 是 4.1 升级后为：Android Studio 3.1.0、Gradle 为4.4。 升级完成后先是报一堆错（每次都升级都是-。-） ##第一个错如下： 1The SourceSet &apos;instrumentTest&apos; is not recognized by the Android Gradle Plugin. Perhaps you misspelled something? 翻译过来就是： 1“SourceSet” 的&apos;instrumentTest&apos; 没有被Android Gradle插件识别。也许你拼错吗? 猜想可能Gradle移除了’instrumentTest’关键字，网上搜了一下，博客地址如下：http://www.it1352.com/139247.html 新版本Gradle对其做了重命名 即： 旧版本 - &gt; 新版本 instrumentTestCompile - &gt; androidTestCompile instrumentTest - &gt; androidTest 然后查看了自己所有module的Gradle，发现有一个地方用到了 instrumentTest ，将其改为 androidTest ，然后继续同步Gradle，然后编译，这个错误不报了。 ##第二个错误如下： 12Configuration &apos;compile&apos; is obsolete and has been replaced with &apos;implementation&apos;.It will be removed at the end of 2018 翻译过来就是： 1配置“编译”已经过时，取而代之的是“实现”。它将在2018年底被移除。 我们知道，在Android Studio3.0开始的时候就将 compile 改为 implementation 关键字了，当时，项目中大部分的compile改为了implementation，但是还有一部分没有改过来，但是仍然可以使用，但是现在呢？尼玛直接给编译就报错！这不是强制性的让使用 implementation 么？报的错中提示2018年底才移除，这还没到年底呢，就不能用了？ 还是乖乖的改吧，由于是我们的依赖的library中使用了compile，相当于是library依赖了一个第三方库，直接改为implementation就相当于屏蔽掉了app对library依赖的第三方库api的访问权限，而我们的app刚好用到了library依赖的第三方库的api，所以直接改为implementation是不行的，要想让app能访问到就将其改为 api就可以了，其实这不是一个好的解决办法，最好的解决办法是，library中封装一层app访问library依赖的第三方库api的方法，这样的话app是和library依赖的第三方库是没有任何关系的，这样就降低了app与library依赖的第三方库的耦合性，这样也体现了“第三方库隔离”的原则，如果以后依赖的库变了，你只需要修改library中依赖的库及app调用的方法即可，不用动app里面的代码了~ ##第三个错误如下 1Duplicate zip entry [com/c/a/a/a/a.class == 69.jar:com/ta/utdid2/b/a/a.class] 翻译过来如下： 1重复的类，即类所在的包名和类名都相等 一般情况下不会写包名和类名相同的类，我猜测一定是Jar包重了，仔细找了一下，发现两个library中都使用了阿里的httpdns的jar包，只不过是Jar包的版本不一样，旧版本中其中一个library中使用了 provided 编译，所以没有报冲突，现在新版本推荐使用 compileOnly 关键字，替换为compileOnly关键字后还是报一样的错，哎呦！这就纳闷了，compileOnly的意思不就是编译时依赖，不打紧包中的意思吗？怎么还冲突？仔细查找了一下，发现其中一个library中多了一个混淆规则的jar包（utdid4all-1.1.5.3_proguard.jar），而另外一个没有，但是旧版本是没有问题的，我猜测可能是编译混淆后发现两个类是一样的所以就报错了… ###解决办法一: 两个library中都添加 utdid4all-1.1.5.3_proguard.jar 使用 compileOnly 关键字编译； ###解决办法二： 两个library中都不添加 utdid4all-1.1.5.3_proguard.jar； ###解决办法三： 在app中添加一个 utdid4all-1.1.5.3_proguard.jar 进行编译即可； 至此，以上几个错误都解决完了~ ##总结 我们应该理解implementation、api、compileOnly等几个关键字的区别，具体见下图： 最后附上几个参考链接： https://docs.gradle.org/current/userguide/java_library_plugin.html#sec:java_library_configurations_graph https://stackoverflow.com/questions/44413952/gradle-implementation-vs-api-configuration]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio 打 JAR 包]]></title>
    <url>%2F2017%2F09%2F24%2FAndroid%20Studio%E6%89%93JAR%E5%8C%85%2F</url>
    <content type="text"><![CDATA[Android Studio 新增了依赖library的方式，有时候我们需要将一个 library 打成 jar 包供其他人使用下面就是具体打成的方法： ##1.在library的buildgradle中添加如下代码 1234567task makeJar(type: Copy) &#123; delete &apos;build/libs/myjar.jar&apos; from(&apos;build/intermediates/bundles/release/&apos;) into(&apos;build/libs/&apos;) include(&apos;classes.jar&apos;) rename(&apos;classes.jar&apos;, &apos;myjar.jar&apos;)&#125; 其实，当你编译完整个工程后，所有library库都已经生成了对应的包含class的classes.jar包，复制出这个jar包，修改名字后也可以使用了，默认生成的路径为：build/intermediates/bundles/release下面就可以看到生成的classes.jar文件了。 ##2.如果你不想使用如上编译时生成的Jar包，你可以再Android Studio自带的Terminal中输入如下命令生成jar包在终端执行生成JAR包build```12或者在buildgradle中再添加如下两行代码即可 makeJar.dependsOn(build)//build.finalizedBy makeJar` Android Studio新增了@arr的依赖方式，它的好处是可以将资源文件也可以打进去，所以，我更推荐大家使用这种依赖方式。 最后他特别感谢如下博主的文章： 参考：blog:http://blog.csdn.net/ta893115871/article/details/46955791]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>JAR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出 Retrofit2.x (二)]]></title>
    <url>%2F2017%2F09%2F24%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BARetrofit2.x(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[点击上面蓝色字体关注“IT大飞说”置顶公众号（ID：ITBigFly）第一时间收到推送&gt;上一篇文章深入浅出Retrofit2.x(一)中，我们讲解了 Retrofit 的最基本用法，以及 GET 请求示例，非常简单，相信大家都已经会使用了，本篇文章将继续介绍 Retrofit 的一些其他的一些常用用法，主要围绕如何使用 POST 请求提交表单数据，提交 json 字符串作为请求体，还有一些 Retrofit 的相关注解介绍等。## 1.POST 请求我最行大家在和服务交互的时候，大多情况下都应该使用的是 GET、POST 请求吧，下面我们就对 POST 各种数据类型及如何定义接口进行说明。### 1.1 POST 提交表单数据首先定义一个如下接口，如果是单参数或者是双参数的话可以这么写：12345@FormUrlEncoded@POST(&quot;/&quot;)Call&lt;ResponseBody&gt; postFormData( @Field(&quot;name&quot;) String name, @Field(&quot;occupation&quot;) String occupation);如果参数较多的话可以使用 @FieldMap 注解123456// 提交 FORM 表单数据@FormUrlEncoded@POST(&quot;&#123;url&#125;&quot;)Call&lt;ResponseBody&gt; postFormData( @Path(&quot;url&quot;) String url, @FieldMap Map&lt;String, String&gt; params);另外 @Field 和 @FieldMap 也可以结合在一起使用。### 1.2 POST 提交 Json 数据我们大多数情况下，发送 POST 请求都是提交 Json 数据和服务器进行交互，而 Json 数据的序列化方式也有多种，我们可以先把对象序列化成 Json 再提交，也可以直接传入一个 Map 参数集合等等都是可以的，看似我们没有序列化，其实内部已经帮我自动实现了序列化的过程，对于不同的参数类型，我们索性就定义一个比较通用的 ApiService 接口，然后把常用的各种请求方式、文件的上传下载等，以及不同参数类型的方法进行封装，把动态变化的参数暴露给外面，让外部传入即可，接口定义如下，每个方法我都加了注释，看注释就好。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * Created by x-sir on 2018/8/1 :) * Function: */public interface ApiService &#123; // GET 无参数请求 @GET(&quot;&#123;url&#125;&quot;) Call&lt;ResponseBody&gt; getRequest( @Path(&quot;url&quot;) String url); // GET 带参数请求 @GET(&quot;&#123;url&#125;&quot;) Call&lt;ResponseBody&gt; getMapParam( @Path(&quot;url&quot;) String url, @QueryMap Map&lt;String, String&gt; maps); // POST Map body 请求 @Headers(&#123;&quot;Content-Type: application/json&quot;, &quot;Accept: application/json&quot;&#125;) @POST(&quot;&#123;url&#125;&quot;) Call&lt;ResponseBody&gt; postMapBody( @Path(value = &quot;url&quot;, encoded = true) String url, @Body Map&lt;String, String&gt; maps); // POST RequestBody 必须要设置 encoded = true, 否则 url 有编码问题 // 使用@Path时，path对应的路径不能包含”/”，否则会将其转化为%2F，在遇到想动态的拼接多节url时，还是使用@Url吧 @Headers(&#123;&quot;Content-Type:application/json&quot;, &quot;Accept:application/json&quot;&#125;) @POST(&quot;&#123;url&#125;&quot;) Call&lt;ResponseBody&gt; postRequestBody( @Path(value = &quot;url&quot;, encoded = true) String url, @Body RequestBody body); // POST Url body 请求(适用于动态域名访问，当url为全域名时，会使用url的全域访问，当为非全域时，会拼接到BASE_URL的后面) @Headers(&#123;&quot;Content-Type: application/json&quot;, &quot;Accept: application/json&quot;&#125;) @POST Call&lt;ResponseBody&gt; postUrlBody( @Url String url, @Body Map&lt;String, String&gt; maps); // 提交 FORM 表单数据 @FormUrlEncoded @POST(&quot;&#123;url&#125;&quot;) Call&lt;ResponseBody&gt; postFormData( @Path(&quot;url&quot;) String url, @FieldMap Map&lt;String, String&gt; params); // 单文件/图片上传 @Multipart @POST(&quot;&#123;url&#125;&quot;) Observable&lt;ResponseBody&gt; upLoadFile( @Path(&quot;url&quot;) String url, @Part(&quot;image\&quot;; filename=\&quot;image.jpg&quot;) RequestBody requestBody); // 多文件/图片上传 @POST(&quot;&#123;url&#125;&quot;) Call&lt;ResponseBody&gt; uploadFiles( @Path(&quot;url&quot;) String url, @Path(&quot;headers&quot;) Map&lt;String, String&gt; headers, @Part(&quot;filename&quot;) String description, @PartMap() Map&lt;String, RequestBody&gt; maps); // 文件下载 @Streaming @GET Observable&lt;ResponseBody&gt; downloadFile( @Url String fileUrl);&#125;然后我们先发送一个 POST 请求，是将 json 串作为请求体，接口的参数类型是一个 Map 集合：123456789101112131415161718Retrofit retrofit = new Retrofit.Builder() .baseUrl(&quot;https://api.example.com&quot;) .addConverterFactory(GsonConverterFactory.create()) .build();ApiService service = retrofit.create(ApiService.class); Call&lt;ResponseBody&gt; call = service.postMapBody(url, map); call.enqueue(new Callback&lt;ResponseBody&gt;() &#123; @Override public void onResponse(Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response) &#123; String json = response.body().string(); &#125; @Override public void onFailure(Call&lt;ResponseBody&gt; call, Throwable t) &#123; &#125; &#125;);同样的我们想使用 Post 提交 Form 表单数据，就只需要调用 ApiService 的 postFormData 方法即可，其他不用变，这样做的好处是不用定义多个 Service 了，只需要定义一个 ApiService 就可以满足了所有参数类型的请求了，另外 POST 还可以支持直接传入一个 RequestBody 类型的参数，我们可以直接将对象转换为 RequestBody 对象，然后再请求即可，转化的话我们可以定义一个工具类来实现：1234567891011/** * Created by x-sir on 2018/8/3 :) * Function: */public class Converter &#123; public static RequestBody toBody(Object object) &#123; return RequestBody.create(MediaType.parse(&quot;application/json; charset=utf-8&quot;), new Gson().toJson(object)); &#125;&#125;我们来个请求的示例：123456789101112131415161718Retrofit retrofit = new Retrofit.Builder() .baseUrl(&quot;https://api.example.com&quot;) .addConverterFactory(GsonConverterFactory.create()) .build();ApiService service = retrofit.create(ApiService.class); Call&lt;ResponseBody&gt; call = service.postRequestBody(url, Converter.toBody(map)); call.enqueue(new Callback&lt;ResponseBody&gt;() &#123; @Override public void onResponse(Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response) &#123; String json = response.body().string(); &#125; @Override public void onFailure(Call&lt;ResponseBody&gt; call, Throwable t) &#123; &#125; &#125;);## 2.GET 请求之 @Query 和 @QueryMap 注解@Query 其实相当于我们在请求时 Url 中 ‘?’ 后面的 key-value，例如：1http://api.github.com/?page=1我们就可以这样来定义接口了12@GET(&quot;/list&quot;)Call&lt;ResponseBody&gt; getPageData(@Query(&quot;page&quot;) int page);这里的 page=1 就是一个 @Query，如果我有多个 @Query，我们可以使用 @QueryMap 使用方法很简单，我就不多说了。## 3.Retrofit 注解我们都知道，在 Retrofit 中，大量使用了注解，这样做的好处是可以简化请求，通过各种不同的注解来进行灵活的配置，另外也可以达到解耦的目的，所以说 Retrofit 的设计很美很优雅， Retrofit 的注解大体分为以下几类：1. 用于标注请求方式的注解；2. 用于标记请求头的注解；3. 用于标记请求参数的注解；4. 用于标记请求和响应格式的注解；### 3.1 请求方法注解|注解|说明|| —— | —— ||@GET|GET 请求||@POST|POST 请求||@PUT|PUT 请求||@DELETE|DELETE 请求||@PATCH|PATCH 请求，对 PUT 请求的补充，用于更新局部资源||@HEAD|HEAD 请求||@OPTION|OPTION 请求||@HTTP|通用注解，可以替换以上所有的注解，其拥有三个属性：method、path、hasBody|### 3.2 请求头注解|注解|说明|| —— | —— ||@Headers|添加固定请求头，可以同时添加多个并且不会相互覆盖原有的请求头，而是共同存在||@Header|作为方法的参数传入，用于添加不固定值的 Header，该注解会更新覆盖已有的请求头|### 3.3 请求参数注解|注解|说明|| —— | —— ||@Body|多用于 POST 请求发送非表单数据,比如想要以 POST 方式传递 json 格式数据||@Filed|多用于 POST 请求中表单字段，@Filed 和 @FieldMap 需要与 @FormUrlEncoded 注解结合使用||@FiledMap|和 @Filed 作用一致，用于不确定表单参数||@Part|用于表单字段,@Part 和 @PartMap 与 @Multipart 注解结合使用,适合文件上传的情况||@PartMap|用于表单字段,默认接受的类型是 Map，可用于实现多文件上传||@Path|用于 url 中的占位符||@Query|用于 GET 请求的 url 中指定 key=value 参数||@QueryMap|和 @Query 使用类似||@Url|指定请求路径，可以是全路径和相对路径|### 3.4 请求和响应格式注解|注解|说明|| —— | —— ||@FormUrlEncoded|表示请求发送编码表单数据，每个键值对需要使用 @Field 注解||@Multipart|表示请求发送 Multipart 数据，需要配合使用 @Part||@Streaming|表示响应用字节流的形式返回，如果没使用该注解，默认会把数据全部载入到内存中，该注解在在下载大文件的特别有用|好了，前两篇的分享已经完了，主要是围绕 Retrofit 最常用最基本的用法来展开讲解的，相信大部分读者看完都已经会用了，大家可能已经看出来这样的代码还是不太好用，没有一些设计的思想，代码比较冗余，下一篇文章将开始讲解如何进行封装一个通用的 Retrofit，这样我们就可以进行方便的进行使用了，提高了代码的复用性和封装性，以及通用性，敬请期待吧！猜你喜欢：给大家推荐一个神器深入浅出Retrofit2.x(一)不得不会的10点Java基础知识Android 最全 Intent 传递数据姿势欢迎扫码关注我的公众号]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Retrofit 2.x</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio 曲折更新之路]]></title>
    <url>%2F2017%2F09%2F24%2FAndroid%20Studio%E6%9B%B2%E6%8A%98%E6%9B%B4%E6%96%B0%E4%B9%8B%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[Android studio 3.0 版本出来也好长时间了，自己的电脑每次有更新我就立马回更新成最新的，公司的电脑自从装上AS就没有更新过，主要是工作比较忙没有时间去更新，这不周末把电脑带回来想着更新成最新的版本… ##1.开始更新 打开AS 点击Help –&gt; Check for Updates… 等了一小会后弹出的是Download而不是Update and Restart安装更新并重启的按钮，点击Download按钮之后，跳转到浏览器，让下载新版本，纳尼？这是什么鬼？我自己的电脑每次更新都是自己下载安装完补丁之后自动安装并重启的，下载完再安装也是可以的，就是比较麻烦而已，而我不想使用这种方式去安装，最后搜了一下大概的意思就是Android Studio的版本太低了不支持使用更新补丁的方式升级到最新的版本，我现在的版本是2.2.3想升级到最新的3.0.1版本，而Google不提供补丁包，可能是版本跨度太大了吧，我想着肯定是有办法的，最后在CSDN上找到一篇博客，和我的情况一样，使用手动更新Android Studio到最新版本，按照他的办法步骤如下： ###1.1找到最新的版本号对应的串号 https://dl.google.com/Android/studio/patches/updates.xml 如下图所示： ###1.2下载你对应版本的到最新版本的补丁包 点开AS的Setting-&gt;在点开Update就可以看到当前版本的串号，如下图： 然后拼接出一个下载补丁包的url:如下 12345678这样就可以下载对应的版本的补丁包，我第一次拼接时，没有自动下载，然后响应超时了，估计是版本太旧的缘故，刚才在https://dl.google.com/Android/studio/patches/updates.xml网页中看到了许多版本更新到最新版本的更新包，仔细看了看，确实没有我这个版本的更新补丁包，找到最低的版本的补丁包是2.3.3，也就是2.3.3肯定是可以更新到3.0.1的，所有有个折中的办法是先更新到2.3.3，再更新到3.0.1，于是从上面的网页中找到2.3.3对应的版本串口，拼接出一个下载的url,复制到浏览器中，点击回车... WC！！！FUCK!居然可以下载了，太爽了，马上就下载完成了。###1.3手动安装AS补丁包打开CMD，切换到AS安装的更目录，输入一下命令后回车：```java -classpath E:\AI-145.3537739-162.4069837-patch-win.jar com.intellij.updater.Runner install . 命令格式格式：java -classpath + 更新包的路径 + com.intellij.updater.Runner install . 稍等一会更新包就安装完成了 然后打开AS，会提示AS已经更新，提示你是否导入之前版本的设置，说明AS已经更新，进去之后再查看版本已经更新到2.3.3了，至此更新的第一步已经完成，接下来就简单了，点击Check for Updates…弹出窗口中终于出现了Update and Restart按钮，点击该按钮即可自动下载并更新… 最后附上2.2.3-2.3.3的更新包，需要的可自行下载。 http://download.csdn.net/download/xinpengfei521/10133487 另外，感谢下面博主的博客： http://blog.csdn.net/u010798604/article/details/52838030]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Android Studio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Studio 添加 arr 依赖]]></title>
    <url>%2F2017%2F09%2F24%2FAndroid%20Studio%E6%B7%BB%E5%8A%A0arr%E4%BE%9D%E8%B5%96%2F</url>
    <content type="text"><![CDATA[##1.将arr库放到libs下面 ##2.在app的buildgradle的android节点中添加如下代码 &#123;1234 flatDir &#123; dirs &apos;libs&apos; //this way we can find the .aar file in libs folder &#125;&#125; ##3.在dependencies中添加如下依赖 compile(name: &#39;com.datescroller.lib-release&#39;, ext: &#39;aar&#39;) name后面就是arr的库名，不带后缀。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>arr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android.view.ViewRootImpl$CalledFromWrongThreadException]]></title>
    <url>%2F2017%2F09%2F24%2Fandroid.view.ViewRootImpl%24CalledFromWrongThreadException%2F</url>
    <content type="text"><![CDATA[在使用EventBus时报如下异常： 1234E/EventBus: Could not dispatch event: class com.model.EventBusMsg to subscribing class class com.anloq.activity.SettingActivity android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views. at android.view.ViewRootImpl.checkThread(ViewRootImpl.java:6096) at android.view.ViewRootImpl.requestLayout(ViewRootImpl.java:824) 上面大致说的意思是EventBus再设置处理UI时只能在UI线程中，我使用的是 BACKGROUND 解决办法：1.改为 MAIN； 2.处理UI时加上runOnUiThread即可；]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Exception</tag>
        <tag>EventBus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[error please select android sdk]]></title>
    <url>%2F2017%2F09%2F24%2Ferror%20please%20select%20android%20sdk%2F</url>
    <content type="text"><![CDATA[点app运行时报如下错： 1Error:please select android sdk 且app module上打了个红叉，无法点击运行 提示找不到SDK 打开app.iml文件修改如下：删除旧的，添加新的一行： 为方便大家直接复制下面的： 1&lt;orderEntry type=&quot;jdk&quot; jdkName=&quot;Android API 27 Platform&quot; jdkType=&quot;Android SDK&quot; /&gt; 修改完成后rebuild app 上的红叉消失，显示正常，点击运行，ok 更多参考文章： https://blog.csdn.net/CHITTY1993/article/details/78779125 https://blog.csdn.net/BruceHurrican/article/details/51755512 https://blog.csdn.net/aqi00/article/details/78858336/]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>SDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android TextView 实现跑马灯]]></title>
    <url>%2F2017%2F09%2F24%2FAndroid%20TextView%E5%AE%9E%E7%8E%B0%E8%B7%91%E9%A9%AC%E7%81%AF%2F</url>
    <content type="text"><![CDATA[##一、使用TextView属性来实现 1.布局文件 1234567891011121314&lt;TextView android:id=&quot;@+id/tvNotice&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:drawableLeft=&quot;@drawable/ico_tongzhi&quot; android:drawablePadding=&quot;12dp&quot; android:ellipsize=&quot;marquee&quot; android:gravity=&quot;center_vertical&quot; android:marqueeRepeatLimit=&quot;marquee_forever&quot; android:singleLine=&quot;true&quot; android:text=&quot;@string/notice_content&quot; android:textColor=&quot;@color/white&quot; android:textSize=&quot;24sp&quot; android:visibility=&quot;visible&quot; /&gt; 2.代码中 1234tvContent.setText(&quot;xxxx...&quot;);tvContent.setFocusable(true); // 获取焦点tvContent.setFocusableInTouchMode(true);tvContent.requestFocus(); ##二、使用自定义View实现 1.继承TextView并重写isFocused方法，返回true，让其获取焦点 123456789101112131415161718192021222324/** * Created by xpf on 2016/11/19 :) * Function:自定义Marquee textView */public class MyTextView extends TextView &#123; public MyTextView(Context context) &#123; super(context); &#125; public MyTextView(Context context, AttributeSet attrs) &#123; super(context, attrs); &#125; public MyTextView(Context context, AttributeSet attrs, int defStyleAttr) &#123; super(context, attrs, defStyleAttr); &#125; @Override public boolean isFocused() &#123; return true; &#125;&#125; 2.布局文件中使用 123456789101112131415&lt;com.anloq.ui.MyTextView android:id=&quot;@+id/tvNotice&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:drawableLeft=&quot;@drawable/ico_tongzhi&quot; android:drawablePadding=&quot;12dp&quot; android:ellipsize=&quot;marquee&quot; android:gravity=&quot;center_vertical&quot; android:scrollHorizontally=“true” android:marqueeRepeatLimit=&quot;marquee_forever&quot; android:singleLine=&quot;true&quot; android:text=&quot;@string/notice_content&quot; android:textColor=&quot;@color/white&quot; android:textSize=&quot;24sp&quot; android:visibility=&quot;visible&quot; /&gt; 3.属性介绍 marqueeRepeatLimit 表示跑马灯循环的次数，marquee_forever表示一直循环，也可以写个数字表示次数然后Activity中可以使设置其settext就ok了；scrollHorizontally 表示滚动的方向是否为水平方向； ##三、总结 关于这两种实现的的方式评价： 第一种方式采用原生控件来实现，但是存在要在Activity中要获取焦点，我们知道Activity中当前只有一个View控件能获取焦点，这样存在的问题是如果我们的页面中有一个默认要获取焦点的EditText控件时，这样就有问题了，但是方法二就不存在这样的问题，因此，个人偏向于第二种实现的方式，更加灵活，后续也可增加速度等实现个性化的定制。 最后感谢参考文章： http://www.cnblogs.com/over140/p/3687952.html]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>TextView</tag>
        <tag>跑马灯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android adb 命令]]></title>
    <url>%2F2017%2F09%2F24%2FAndroid%20adb%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[1.查看当前adb版本123$adb versionAndroid Debug Bridge version 1.0.36Revision 0e9850346394-android 2.查看当前已连接的设备123$adb devicesf414ec93 device20080411 device ##3.安装apk文件 直接安装：1$adb install + apk文件的路径 一般在安装的时候先敲出adb install然后直接将apk文件拖到MS Dos窗口中即可,然后点击回车即可自动安装。 提示：有时候有的安装时会失败，因为有可能包含中文路径，建议最好不要包含中文路径！ 保留数据和缓存文件，重新安装apk：install -r hello.apk```123安装apk到sd卡：```adb install -s hello.apk 4.拉取文件到电脑123$adb pull +手机文件路径/目录 + 空格 + 电脑目录 adb pull /data/data/com.xpf.demo/files/20171031.txt c:/Users/xin/[100%] /data/data/com.xpf.demo/files/20171031.txt 5.从电脑复制文件到手机12$adb push + 电脑文件路径 + 空格 + 手机文件路径/目录$adb push hello.txt /sdcard/mydir/ 6.卸载已安装的app直接卸载：uninstall ```123卸载App但保留数据和缓存文件：```adb uninstall -k com.xpf.demo 7.adb Server我们在调试的时候，偶尔也会遇到手机adb连接不上的情况，我们先kill掉server在start server就好了启动adb server ：start-server```12停止adb server ：```adb kill-server 8.查看手机屏幕分辨率12adb shell wm sizePhysical size: 1080x1920 9.查看adb命令帮助信息help```1234## 10.在命令行中查看LOG日志```adb logcat -s 标签名 温馨提示：加入标签名可以进行log打印过滤，不然打印出来的日志太多不方便查看 11.发布端口可以设置任意的端口号作为主机向模拟器或设备的请求端口。 forward tcp:5555 tcp:8000```1234## 12.查看bug报告```adb bugreport 13.屏幕录像例如，开始录制屏幕并储存到/sdcard根目录，同时名字为video.mp4 shell screenrecordlink12## 14.关闭设备请求，开启设备 adb shell stopadb shell start12## 15.设备关机以及重启 adb rebootadb shutdown1234## 16.获取已连接的手机序列号```adb get-serialno 17.获取设备的连接状态-s f414ec93 get-state```123456其中**f414ec93**为手机序列号（获取序列号参考16）## 18.查看目录下的所有文件及文件夹```adb shell ls ##19.查看文件夹内容 shell cd ```1234## 20.新建文件夹（目录）```adb shell mkdir path/floldername ##21.发送文件内容 shell input text ```1234## 22.通过adb命令发送键盘按键事件```adb shell input keyevent &lt;keycode&gt; 23.获取设备参数信息shell getprop ```1234## 24.设置设备的参数信息```adb shell setprop &lt;key&gt; &lt;value&gt; 25.使用adb命令进行截屏操作shell screencap -p ```1234## 26.查看内存情况，如果有number表示查看多少条数据```adb shell top [-m &lt;number&gt;] 27.查看进程列表数据shell ps```1234## 28.杀死对应pid的进程```adb shell kill &lt;pid&gt; 29.查看指定pid进行的运行状态shell ps -x ```1234## 30.查看后台服务信息```adb shell service list 31.查看当前内存占用情况shell catlink1234## 32.查看io内存分区情况```adb shell cat /proc/iomen 33.将system分区重新挂载为可读写分区remount```1234## 34.列出除了系统应用的第三方应用包名```adb shell pm list packages -3 35.清除应用数据与缓存adb shell pm clear &lt;packagename&gt; 好了，就写到这里吧，其实ADB命令有很多，我只整理了一些大家比较常用的一些命令，当然我们有时候要记忆的东西太多了，记不住有些命令，你需要做的就是点击收藏按钮，当用的时候就可以方便自己查找了，如果你觉得文本不错，请您点个赞，码字不易，且行且珍惜！ 再小的点赞也是对博主的莫大鼓励！]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>adb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java.lang.IllegalStateException commit already called]]></title>
    <url>%2F2017%2F09%2F24%2Fjava.lang.IllegalStateException%20commit%20already%20called%2F</url>
    <content type="text"><![CDATA[今天使用Fragment时报如下图错误： 分析原因之所以报该错误，是因为 Fragment 事务是全局的变量，只能commit一次。 解决方法：将获取Fragment事务定义为局部变量，每次提交时都去获取新的事务去commit即可。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Exception</tag>
        <tag>IllegalStateException</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[51单片机矩阵键盘C程序]]></title>
    <url>%2F2017%2F09%2F24%2F51%E5%8D%95%E7%89%87%E6%9C%BA%E7%9F%A9%E9%98%B5%E9%94%AE%E7%9B%98C%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[主程序1：12345678910111213141516171819202122232425void main()&#123; uchar i,j,k i=0; j=0; while(1) &#123; i=key();//键盘循环扫描，其值赋给变量数组table if(i!=0)//键盘子程序返回值非0，即有按键按下 &#123; table[j]=i;//将值存在变量数组中j++; &#125; if(j==6) &#123; j=0; for(k=0;k&lt;6;k++)//当数组存满6位时核对 &#123; P3=table[k];//P3接有一排指示灯 delay (1000);//延时1S &#125; &#125; &#125;&#125; 主程序2：12345678main()&#123;int i,j,a[2][5]=&#123;10,15,25,15,75,15,45,65,85,95&#125;;for(i=0;i&lt;2;i++)for(j=0;j&lt;5;j++)&#123;printf(&quot;%d &quot;,a[i][j]);&#125;printf(&quot;\n&quot;);&#125; 主程序3：由键盘输入一个3×4矩阵a，选出各列最小的元素组成一个一维数组b并输出由键盘输入一个3×4矩阵a，选出各列最小的元素组成一个一维数组b并输出 1234567891011121314151617 #include &quot;stdio.h&quot; #include &quot;conio.h&quot;void main()&#123;int i,j,a[3][4],b[4],min;for(i=0;i&lt;3;i++)for(j=0;j&lt;4;j++)scanf(&quot;%d&quot;,&amp;a[i][j]);for(i=0;i&lt;4;i++)b[i]=a[0][i];for (i=0;i&lt;4;i++)for(j=1;j&lt;2;j++)if(a[i][j]&lt;b[i]) b[i]=a[i][j];for(i=0;i&lt;4;i++)printf(&quot;%d&quot;,b[i]); getch();&#125; 梦里求她千百度，蓦然回首，那人却在灯火阑珊处。。。]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>51单片机</tag>
        <tag>C语言</tag>
        <tag>矩阵键盘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 基本数据类型转换为 String]]></title>
    <url>%2F2017%2F09%2F24%2Fjava%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%BAString%2F</url>
    <content type="text"><![CDATA[我们都知道把一个基本数据类型转为 String 类型，一般有三种方式，例如：有一个 Integer 型数据 a，可以使用i.toString()、String.valueOf(i)、i+”” 三种方式，三种方式的效率如何，接下来我们做一个小测试： 1.测试代码如下：123456789101112131415161718192021222324252627/** * 把一个基本数据类型转为字符串 */ private void testExecuteTime() &#123; int loopTime = 100000; //Integer i = 0; Long i = 0L; long startTime; startTime = System.currentTimeMillis(); for (int j = 0; j &lt; loopTime; j++) &#123; String str = String.valueOf(i); &#125; Log.e(&quot;TAG&quot;, &quot;String.valueOf()：&quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;); startTime = System.currentTimeMillis(); for (int j = 0; j &lt; loopTime; j++) &#123; String str = i.toString(); &#125; Log.e(&quot;TAG&quot;, &quot;Integer.toString()：&quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;); startTime = System.currentTimeMillis(); for (int j = 0; j &lt; loopTime; j++) &#123; String str = i + &quot;&quot;; &#125; Log.e(&quot;TAG&quot;, &quot;i + \&quot;\&quot;：&quot; + (System.currentTimeMillis() - startTime) + &quot;ms&quot;); &#125; 2.测试结果 3.结论把一个基本数据类型转换为String,使用.toString()是最快的方式、String.valueOf和toString差不多、数据+””的效率最慢，其实这些执行都是毫秒级，现在处理器的性能都比较强悍，其实影响不大，对于用户来说，没有什么感觉，但是我们可以再写代码的时候养成一个良好的习惯，有时候不用抠这么细，毕竟不是底层的代码，应用层，主要先以实现业务功能为主，这样后续有时间可以优化，记住一点：大行不顾细谨，大理不辞小让！]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Android源码设计模式》学习笔记之 ImageLoader]]></title>
    <url>%2F2017%2F09%2F24%2F%E3%80%8AAndroid%E6%BA%90%E7%A0%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BImageLoader%2F</url>
    <content type="text"><![CDATA[需求：设计一个图片加载工具类。要求：职责单一、可扩展性强、实现三级缓存，遵循开闭原则。 1.改造前原始代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package com.anloq.sdk.imageloader;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.util.LruCache;import android.widget.ImageView;import java.net.HttpURLConnection;import java.net.URL;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * Created by xpf on 2017/10/22 :) * Function: */public class ImageLoader &#123; // 图片缓存 LruCache&lt;String, Bitmap&gt; mImageCache; // 线程池，线程池数量为CPU的数量 ExecutorService mExecutorService = Executors.newFixedThreadPool( Runtime.getRuntime().availableProcessors()); public ImageLoader() &#123; initImageCache(); &#125; /** * 初始化图片缓存大小 */ private void initImageCache() &#123; // 计算可使用的最大内存 final int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024); // 取1/4的可用内存作为缓存 final int cacheSize = maxMemory / 4; mImageCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) &#123; @Override protected int sizeOf(String key, Bitmap value) &#123; return value.getRowBytes() * value.getHeight() / 1024; &#125; &#125;; &#125; /** * 加载显示图片 * * @param url * @param imageView */ public void displayImage(final String url, final ImageView imageView) &#123; imageView.setTag(url); mExecutorService.submit(new Runnable() &#123; @Override public void run() &#123; Bitmap bitmap = downloadImage(url); if (bitmap == null) return; if (imageView.getTag().equals(url)) &#123; imageView.setImageBitmap(bitmap); &#125; mImageCache.put(url, bitmap); &#125; &#125;); &#125; /** * 下载图片 * * @param imageUrl * @return */ private Bitmap downloadImage(String imageUrl) &#123; Bitmap bitmap = null; try &#123; URL url = new URL(imageUrl); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); bitmap = BitmapFactory.decodeStream(conn.getInputStream()); conn.disconnect(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 2.遵循单一原则将原始类分为加载和缓存两个类（功能）2.1.图片加载类为：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package com.anloq.sdk.imageloader;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.widget.ImageView;import java.net.HttpURLConnection;import java.net.URL;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * Created by xpf on 2017/10/22 :) * Function: */public class ImageLoader &#123; // 图片缓存 ImageCache mImageCache = new ImageCache(); // 线程池，线程池数量为CPU的数量 ExecutorService mExecutorService = Executors.newFixedThreadPool( Runtime.getRuntime().availableProcessors()); /** * 加载显示图片 * * @param url * @param imageView */ public void displayImage(final String url, final ImageView imageView) &#123; // 优先从缓存中加载 Bitmap bitmap = mImageCache.get(url); if (bitmap != null) &#123; imageView.setImageBitmap(bitmap); return; &#125; imageView.setTag(url); mExecutorService.submit(new Runnable() &#123; @Override public void run() &#123; Bitmap bitmap = downloadImage(url); if (bitmap == null) return; if (imageView.getTag().equals(url)) &#123; imageView.setImageBitmap(bitmap); &#125; mImageCache.put(url, bitmap); &#125; &#125;); &#125; /** * 下载图片 * * @param imageUrl * @return */ private Bitmap downloadImage(String imageUrl) &#123; Bitmap bitmap = null; try &#123; URL url = new URL(imageUrl); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); bitmap = BitmapFactory.decodeStream(conn.getInputStream()); conn.disconnect(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 2.2.缓存类为123456789101112131415161718192021222324252627282930313233343536373839404142package com.anloq.sdk.imageloader;import android.graphics.Bitmap;import android.util.LruCache;/** * Created by xpf on 2017/10/22 :) * Function:图片缓存类 */public class ImageCache &#123; // 图片LRU缓存 LruCache&lt;String, Bitmap&gt; mImageCache; public ImageCache() &#123; initImageCache(); &#125; /** * 初始化图片缓存大小 */ private void initImageCache() &#123; // 计算可使用的最大内存 final int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024); // 取1/4的可用内存作为缓存 final int cacheSize = maxMemory / 4; mImageCache = new LruCache&lt;String, Bitmap&gt;(cacheSize) &#123; @Override protected int sizeOf(String key, Bitmap value) &#123; return value.getRowBytes() * value.getHeight() / 1024; &#125; &#125;; &#125; public void put(String url, Bitmap bitmap) &#123; mImageCache.put(url, bitmap); &#125; public Bitmap get(String url) &#123; return mImageCache.get(url); &#125;&#125; 3.提高扩展性，增加SD卡缓存以上将代码的功能分开了，逻辑更清晰了，职责也单一了，但是可扩展性还是比较差，接下来进行增加SD卡缓存。 3.1增加SD卡缓存类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package com.anloq.sdk.imageloader;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;/** * Created by xpf on 2017/10/22 :) * Function: */public class DiskCache &#123; static String cacheDir = &quot;/sdcard/cache/image/&quot;; /** * 从SD卡中读取 * * @param url * @return */ public Bitmap get(String url) &#123; return BitmapFactory.decodeFile(cacheDir + url); &#125; /** * 缓存到SD卡中 * * @param url * @param bmp */ public void put(String url, Bitmap bmp) &#123; FileOutputStream fos = null; try &#123; fos = new FileOutputStream(cacheDir + url); bmp.compress(Bitmap.CompressFormat.PNG, 100, fos); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; if (fos != null) &#123; try &#123; fos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 3.2ImageLoader中增加一个boolean值来设置使用哪种缓存方式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.anloq.sdk.imageloader;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.widget.ImageView;import java.net.HttpURLConnection;import java.net.URL;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * Created by xpf on 2017/10/22 :) * Function: */public class ImageLoader &#123; // 内存缓存 ImageCache mImageCache = new ImageCache(); // SD卡缓存 DiskCache mDiskCache = new DiskCache(); // 是否使用SD卡缓存 boolean isUseDiskCache = false; // 线程池，线程池数量为CPU的数量 ExecutorService mExecutorService = Executors.newFixedThreadPool( Runtime.getRuntime().availableProcessors()); /** * 加载显示图片 * * @param url * @param imageView */ public void displayImage(final String url, final ImageView imageView) &#123; // 优先从缓存中加载 Bitmap bitmap = isUseDiskCache ? mImageCache.get(url) : mDiskCache.get(url); if (bitmap != null) &#123; imageView.setImageBitmap(bitmap); return; &#125; imageView.setTag(url); mExecutorService.submit(new Runnable() &#123; @Override public void run() &#123; Bitmap bitmap = downloadImage(url); if (bitmap == null) return; if (imageView.getTag().equals(url)) &#123; imageView.setImageBitmap(bitmap); &#125; mImageCache.put(url, bitmap); &#125; &#125;); &#125; /** * 下载图片 * * @param imageUrl * @return */ private Bitmap downloadImage(String imageUrl) &#123; Bitmap bitmap = null; try &#123; URL url = new URL(imageUrl); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); bitmap = BitmapFactory.decodeStream(conn.getInputStream()); conn.disconnect(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; /** * 设置是否使用SD卡缓存 * * @param useDiskCache */ public void setUseDiskCache(boolean useDiskCache) &#123; isUseDiskCache = useDiskCache; &#125;&#125; 4.进一步改造，使用双缓存，优先使用内存加载，如果无再使用SD卡缓存以上代码修改虽然增加了SD卡缓存，但是为了节省用户的流量及加载速度我们应该设计成优先使用内存加载，如果无再使用SD卡缓存。 4.1增加双缓存类123456789101112131415161718192021222324252627282930313233343536373839package com.anloq.sdk.imageloader;import android.graphics.Bitmap;/** * Created by xpf on 2017/10/22 :) * Function: */public class DoubleCache &#123; ImageCache mMemoryCache = new ImageCache(); DiskCache mDiskCache = new DiskCache(); /** * 优先使用内存加载，如果无再使用SD卡缓存 * * @param url * @return */ public Bitmap get(String url) &#123; Bitmap bitmap = mMemoryCache.get(url); if (bitmap == null) &#123; bitmap = mDiskCache.get(url); &#125; return bitmap; &#125; /** * 将图片缓存到内存和SD卡中 * * @param url * @param bitmap */ public void put(String url, Bitmap bitmap) &#123; mMemoryCache.put(url, bitmap); mDiskCache.put(url, bitmap); &#125;&#125; 4.2ImageLoader增加双缓存配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103package com.anloq.sdk.imageloader;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.widget.ImageView;import java.net.HttpURLConnection;import java.net.URL;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * Created by xpf on 2017/10/22 :) * Function: */public class ImageLoader &#123; // 内存缓存 ImageCache mImageCache = new ImageCache(); // SD卡缓存 DiskCache mDiskCache = new DiskCache(); // 双缓存 DoubleCache mDoubleCache = new DoubleCache(); // 是否使用SD卡缓存 boolean isUseDiskCache = false; // 是否使用双缓存 boolean isUseDoubleCache = false; // 线程池，线程池数量为CPU的数量 ExecutorService mExecutorService = Executors.newFixedThreadPool( Runtime.getRuntime().availableProcessors()); /** * 加载显示图片 * * @param url * @param imageView */ public void displayImage(final String url, final ImageView imageView) &#123; // 优先从缓存中加载 Bitmap bitmap = null; if (isUseDoubleCache) &#123; bitmap = mDoubleCache.get(url); &#125; else if (isUseDiskCache) &#123; bitmap = mDiskCache.get(url); &#125; else &#123; bitmap = mImageCache.get(url); &#125; if (bitmap != null) &#123; imageView.setImageBitmap(bitmap); return; &#125; imageView.setTag(url); mExecutorService.submit(new Runnable() &#123; @Override public void run() &#123; Bitmap bitmap = downloadImage(url); if (bitmap == null) return; if (imageView.getTag().equals(url)) &#123; imageView.setImageBitmap(bitmap); &#125; mImageCache.put(url, bitmap); &#125; &#125;); &#125; /** * 下载图片 * * @param imageUrl * @return */ private Bitmap downloadImage(String imageUrl) &#123; Bitmap bitmap = null; try &#123; URL url = new URL(imageUrl); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); bitmap = BitmapFactory.decodeStream(conn.getInputStream()); conn.disconnect(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; /** * 设置是否使用SD卡缓存 * * @param useDiskCache */ public void setUseDiskCache(boolean useDiskCache) &#123; isUseDiskCache = useDiskCache; &#125; /** * 设置是否使用双缓存 * * @param useDoubleCache */ public void setUseDoubleCache(boolean useDoubleCache) &#123; isUseDoubleCache = useDoubleCache; &#125;&#125; 以上改造总算可以了，但是这样每次增加缓存策略都要修改源代码，这样很有可能引入bug,所以我们的原则是要对修改关闭，对扩展开放，这样以后有新需求的时候我们就可以使用扩展的方法来实现。 5.抽象公共方法的接口5.1接口抽取1234567891011121314package com.anloq.sdk.imageloader;import android.graphics.Bitmap;/** * Created by xpf on 2017/10/22 :) * Function: */public interface ImageCache &#123; Bitmap get(String url); void put(String url, Bitmap bitmap);&#125; 5.2ImageLoader注入接口的实现类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384package com.anloq.sdk.imageloader;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.widget.ImageView;import java.net.HttpURLConnection;import java.net.URL;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * Created by xpf on 2017/10/22 :) * Function: */public class ImageLoader &#123; ImageCache mImageCache = new MemoryCache(); // 线程池，线程池数量为CPU的数量 ExecutorService mExecutorService = Executors.newFixedThreadPool( Runtime.getRuntime().availableProcessors()); /** * 注入缓存实现 * * @param mImageCache */ public void setmImageCache(ImageCache mImageCache) &#123; this.mImageCache = mImageCache; &#125; /** * 加载显示图片 * * @param url * @param imageView */ public void displayImage(final String url, final ImageView imageView) &#123; Bitmap bitmap = mImageCache.get(url); if (bitmap != null) &#123; imageView.setImageBitmap(bitmap); return; &#125; // 图片没有缓存提交到线程池中下载 submitLoadRequest(url, imageView); &#125; private void submitLoadRequest(final String url, final ImageView imageView) &#123; imageView.setTag(url); mExecutorService.submit(new Runnable() &#123; @Override public void run() &#123; Bitmap bitmap = downloadImage(url); if (bitmap == null) return; if (imageView.getTag().equals(url)) &#123; imageView.setImageBitmap(bitmap); &#125; mImageCache.put(url, bitmap); &#125; &#125;); &#125; /** * 下载图片 * * @param imageUrl * @return */ private Bitmap downloadImage(String imageUrl) &#123; Bitmap bitmap = null; try &#123; URL url = new URL(imageUrl); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); bitmap = BitmapFactory.decodeStream(conn.getInputStream()); conn.disconnect(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return bitmap; &#125;&#125; 5.3内存缓存、SD卡缓存和双缓存分别实现接口1234567891011121314151617181920212223242526272829303132333435363738394041package com.anloq.sdk.imageloader;import android.graphics.Bitmap;/** * Created by xpf on 2017/10/22 :) * Function: */public class DoubleCache implements ImageCache &#123; ImageCache mMemoryCache = new MemoryCache(); ImageCache mDiskCache = new DiskCache(); /** * 优先使用内存加载，如果无再使用SD卡缓存 * * @param url * @return */ @Override public Bitmap get(String url) &#123; Bitmap bitmap = mMemoryCache.get(url); if (bitmap == null) &#123; bitmap = mDiskCache.get(url); &#125; return bitmap; &#125; /** * 将图片缓存到内存和SD卡中 * * @param url * @param bitmap */ @Override public void put(String url, Bitmap bitmap) &#123; mMemoryCache.put(url, bitmap); mDiskCache.put(url, bitmap); &#125;&#125; 内存缓存、SD卡缓存实现同上。 6.外部调用及设置缓存策略1234567891011121314151617181920212223private void loadImage() &#123; ImageLoader imageLoader = new ImageLoader(); // 使用内存缓存 imageLoader.setmImageCache(new MemoryCache()); // 使用SD卡缓存 imageLoader.setmImageCache(new DiskCache()); // 使用双缓存 imageLoader.setmImageCache(new DoubleCache()); // 使用自定义的图片缓存 imageLoader.setmImageCache(new ImageCache() &#123; @Override public Bitmap get(String url) &#123; return null; &#125; @Override public void put(String url, Bitmap bitmap) &#123; &#125; &#125;); String imageUrl = &quot;http://p1.meituan.net/160.0.80/xianfu/5e369ac9d6aa54125ad1b6562282b2ca36024.jpeg&quot;; imageLoader.displayImage(imageUrl, imageView); &#125; 经过上述代码的重构，我们可以通过setImageCache(ImageCache cache)方法注入不同的缓存实现，来使得ImageLoader更简单、健壮、扩展性好灵活性也更高。以上三种缓存图片的具体实现完全不一样，但是它们都有一个共同的特点是都实现了ImageCache接口。当用户需要增加一种新的缓存策略时，我们只需新建一个实现ImageCache接口等待类就可以了，这样就实现了千变万化的缓存策略，并且新扩展的策略不会影响导致ImageLoader类的修改，这正是体现了“对修改关闭，对扩展开放的”原则，所以，我们在设计写代码的时候应该认真地进行思考，希望大家一起思考，一起学习，有所成长！ 源码下载链接： https://github.com/xinpengfei520/MyImageLoader 如果本文对你有帮助，欢迎大家点赞、评论，码字不易，再小的支持也是对博主的莫大鼓励！ 今天的分享就到这里，如需转载，请注明出处，谢谢！ 声明：文中部分代码摘录自《Android源码设计模式》一书。 注：本文由博主原创，转载请注明出处，谢谢！]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>ImageLoader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不可错过的几款GitHub开源项目]]></title>
    <url>%2F2017%2F09%2F24%2F%E4%B8%8D%E5%8F%AF%E9%94%99%E8%BF%87%E7%9A%84%E5%87%A0%E6%AC%BEGitHub%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[工作之余或者周末感觉无聊？不知道干什么？想继续提高技术，但是不知道做什么的同学，看过来，不妨利用闲暇时间来撸几个 GitHub 上还不错的开源项目，本文推荐的开源项目比较适合新手、及对MVP设计模式不太熟练的同学练习之用，下面逐一进行简单介绍。 1.ZhiHuMVP一款采用 MVP 模式的仿知乎客户端。 本项目包含以下知识点： MVP架构思想 Retrofit RESTful API 框架的配合 RxJava 响应式编程 Butter Knife：通过注解绑定 View 夜间模式切换 效果图： https://github.com/fangx/ZhiHuMVP 2.ColorfulNews一个 Material Design 风格的新闻阅读 App，采用 MVP 模式，基于 Dagger2+RxJava+Retrofit2进行开发。 主要用到的开源库： Dagger2 RxJava Retrofit2 Butterknife Greendao PhotoView Glide Picasso … 效果图： https://github.com/kaku2015/ColorfulNews 3.boxingBilibili 开源的基于MVP模式的 Android 多媒体选择器。 特性： 支持自定义UI 支持多/单图片选择和预览，单图裁剪功能 支持gif 支持视频选择功能 提供图片压缩 多图生成gif（checkout feature/gif-encode) 效果图： https://github.com/Bilibili/boxing 4.MinimalistWeatherMinimalistWeather 是 Android 平台上一款开源天气 App ，目前还在开发中。项目基于 MVP 架构，采用各主流开源库实现。开发此项目主要是为展示各种开源库的使用方式以及 Android 项目的设计方案，并作为团队项目开发规范的一部分。 采用的开源库包括： RxJava Retrofit2 OKHttp3 ORMLite Dagger2 ButterKnife RetroLambda Stetho 本项目还展示了： MVP+RxJava在实际项目中的应用，MVP中RxJava生命周期的管理…； 上述罗列的各种开源框架的使用方法； Java8 Lambda表达式和Stream API的用法； 怎样适配Material Design； ToolBar、RecycleView、CardView、CoordinatorLayout等新控件的用法； Gradle的基本配置（包括签名打包、项目依赖等等）； 如何更好的管理Gradle依赖库的版本； 代码混淆配置； 如何快速开发一款结构清晰、可扩展性强的Android Application。 https://github.com/BaronZ88/MinimalistWeather 5.TranslateApp一个实现 『划词翻译』 功能的 Android 应用 ，可能是目前 Android 市场上翻译效率最高的一款应用。 技术点: 全程使用 Dagger2 对项目进行类依赖管理 项目使用标准的 MVP 架构，关于 MVP 的一篇博客 实现对粘贴板的监听以及访问 无需权限显示悬浮窗（6.0悬浮窗权限适配） 使用 RxJava 探索函数式编程 使用 Retrofit2 进行网络请求 开机自启动 Android 6.0 自定义文本操作栏 效果图： https://github.com/maoruibin/TranslateApp 6.Ghost微影，一款纯粹的在线视频App，基于Material Design + MVP + Dagger2 + RxJava + Retrofit + Realm + Glide。 技术点： 使用RxJava配合Retrofit2做网络请求 使用RxUtil对线程操作和网络请求结果处理做了封装 使用RxPresenter对订阅的生命周期做管理 使用AndroidEventBus来方便组件间的通信 使用Material Design控件和动画 使用MVP架构整个项目，对应于model、ui、presenter三个包 使用Realm做阅读记录和收藏记录的增、删、查、改 使用Glide做图片的处理和加载 使用RecyclerView实现下拉刷新、上拉加载、侧滑删除、长按拖曳 支持主题设置 包含搜索、收藏、历史等功能 效果图： https://github.com/GeekGhost/Ghost 7.GeekNews极客日报，一款纯粹的阅读App，基于Material Design + MVP + RxJava2 + Retrofit + Dagger2 + Realm + Glide。 技术点： 使用RxJava配合Retrofit2做网络请求 使用RxUtil对线程操作和网络请求结果处理做了封装 使用RxPresenter对订阅的生命周期做管理 使用RxBus来方便组件间的通信 使用RxJava其他操作符来做延时、轮询、转化、筛选等操作 使用okhttp3对网络返回内容做缓存，还有日志、超时重连、头部消息的配置 使用Material Design控件和动画 使用MVP架构整个项目，对应于model、ui、presenter三个包 使用Dagger2将M层注入P层，将P层注入V层，无需new，直接调用对象 使用Realm做阅读记录和收藏记录的增、删、查、改 使用Glide做图片的处理和加载 使用Fragmentation简化Fragment的操作和懒加载 使用RecyclerView实现下拉刷新、上拉加载、侧滑删除、长按拖曳 使用x5WebView做阅览页，比原生WebView体验更佳 使用SVG及其动画实现progressbar的效果 使用RxPermissions做6.0+动态权限适配 使用Jsoup解析V2EX站点DOM 使用原生的夜间模式、分享、反馈 包含搜索、收藏、检测更新等功能 所有踩到的坑都在项目里做了注释 效果图： https://github.com/codeestX/GeekNews 8.MovieGuideMovieGuide是一款受欢迎、高级别的电影Android应用，展示了预告片和评论等功能。采用了MVP模式、RxJava、Dagger 2 和 Bob Martin 的 Clean 架构方法，并针对平板电脑进行了优化。 效果图： https://github.com/esoxjem/MovieGuide 9.SimpleNews基于Material Design和MVP的新闻客户端。 效果图： https://github.com/liuling07/SimpleNews 10.Toutiao一款第三方今日头条客户端，遵循材料设计(Material Design), 聚合了新闻/段子/图片/视频/头条号内容, 没有广告, 仅仅只有存粹的阅读, 不断完善中, 采用 MVP + RxJava + Retrofit 架构的项目。 主要功能特性： 首页五大模块: 新闻 / 图片 / 视频 / 头条号 / 问答 实现首页的布局和数据的显示 实现自定义新闻栏目顺序 新闻详情页面支持日夜两种主题 显示新闻评论 头条号订阅 查看头条号历史文章 / 视频 搜索功能 热门搜索推荐 搜索历史记录 自定义主题颜色 无缝切换日夜皮肤 视频播放 内置3款 logo 随意互换 动态切换字体大小 主要技术点： 基本遵循 Material Design 设计风格 抓包获取今日头条API 使用 Google 官方 MVP 架构 DrawerLayout + NavigationView + BottomNavigationView 搭配使用 RxBus 代替 EventBus 进行组件之间通讯 ViewPager 搭配 Fragment 懒加载 SwipeRefreshLayout 搭配 RecyclerView 下拉刷新上拉加载 自定义 BottomNavigationBehavior 实现上滑隐藏下滑显示 RxJava + Retrofit2 + OkHttp3 做网络请求 OkHttp3 对网络返回内容做缓存, 还有日志、超时重连、头部消息的配置 V层基类的构建, 包括 BaseActivity 和 BaseFragment , 对外提供了相同的接口 使用原生的夜间模式 解决侧滑返回与 View 冲突问题 内置 3 款 Logo, 随意切换 使用 CoordinatorLayout 、 AppBarLayout 、 CollapsingToolbarLayout 、 BottomSheetDialog 等新控件 使用 7.0 新工具 DiffUtil , 不再无脑 notifyDataSetChanged 使用 ItemTouchHelper 实现今日头条的频道排序、频道移动, 参考 ItemTouchHelperDemo 使用 RxBinding 优雅实现搜索请求 使用 AutoDispose 绑定 RxJava 生命周期 使用 Travis Cl 持续集成 效果图： https://github.com/iMeiji/Toutiao 11.PhotoNoterMaterial Design风格的开源照片笔记。 主要技术点： 整体项目MVP结构 Dagger2 相机部分，API &gt;= 21使用 Camera2 ，API &lt; 21使用 Camera 相机的状态机，聚焦状态机 照片缓存分为两种，一个是大图，一个是小图，小图是相册界面缩略图的时候加载的，大图是查看图片的时候加载的 图片处理 沙盒 Activity 退出和进入的动画 一些 UI 的动画，比如 “ 意见反馈”、 “ 语音输入” 这里面的动画 主题设置，沉浸式状态栏（Android 5.0） 切换主题 可以滑动 item 和可以拖放 item 的 ListView（SlideAndDragListView） Android 原生平台的 Markdown，支持 EditText 编辑实时预览 （RxMarkdown） RxJava + RxAndroid（RxCategory/ RxPhotoNote/ RxSandBox/ RxFeedBack/ RxUser） dex分包处理 Dex自动分包脚本 使用 AOP 进行 Android 6.0 权限适配 NDK &amp;&amp; AIDL 效果图： https://github.com/yydcdut/PhotoNoter 好了，终于介绍完了，由于本文篇幅比较长，建议 「收藏」，欢迎大家评论点赞或者转发，如有更多想法欢迎在下方留言。 重要声明：本文中介绍的所有开源项目所有权仍归原开源作者所有，本文仅对原作者的开源项目进行介绍、整理说明，供参考、学习交流之用。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Glide</tag>
        <tag>开源项目</tag>
        <tag>MVP</tag>
        <tag>Retrofit 2.x</tag>
        <tag>RxJava 2.x</tag>
        <tag>GreenDao</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[程序猿如何理财]]></title>
    <url>%2F2017%2F09%2F24%2F%E7%A8%8B%E5%BA%8F%E7%8C%BF%E5%A6%82%E4%BD%95%E7%90%86%E8%B4%A2%2F</url>
    <content type="text"><![CDATA[随着社会经济的飞速发展和人们生活水平的日益提高，人们的收入也随着年龄的增长不断提高，人们对于理财的观念也越来越深入人心了，很多人都希望通过 「理财」 来管理和支配自己的财富，进一步来增加自己的收入，合理的分配自己的资产，科学的理财方式能够帮助我们提高生活质量，应急和处理一些未知的风险事件，减少风险事件给我们带来的影响，也更有利于把控自己的资产和更有条理的管理资产，减轻生活的压力。尤其是我们程序员一族，相比其他行业来说，总体的平均收入也不算低，程序员大都生活在北上广深这些大都市，虽说收入也不菲，但是广大程序员生活在这些城市的压力一点也不小，可以这么说，饿又饿不死，买房定居又无望，我想这可能是大多程序员的状态吧，但是不管怎么说，我们还是该挣钱挣钱，想太多也起不了什么作用，我认为最重要的是我们还要提升自身的能力才是最重要的，这样我们在换工作或者面试的时候多要个几 K 也是轻而易举的。 为什么要理财？ 俗话说，人生不如意之事十之八九，惊喜和意外你不知道哪个会先到，我说的意思不是悲观的理解为人生的好多事都是不好的，我想说的是，我们谁也不能预知未来会发生什么，我们可以做的是降低风险的发生的概率以及做好当风险发生之前的准备，这样可以减少风险事件给我们带来的影响。 对于广大程序员来说，加班已经是一种常态，也包括一些大厂在内，据相关数据统计，中国人每年的工作时长一直稳居排列在全世界的前列，可见中国人加班是有多拼，有的公司还给员工宣传什么狗屁加班文化..我就不具体说了，每年都会有报道因为加班猝死的程序员，屡见不鲜。身体是革命的本钱，没有一个好身体，怎样才能好好工作，好好赚钱，实现理想？当然我也不是过激的反对加班，对于加班这种事，我不能一棒子打死，凡事都应该有个度，我的观点是，我可以接受加班，但是不能接受无休止的加班，毕竟身体是自己的，公司是商业机构，都是以赚钱为目的的，就算你加班加到死，到时候公司也是可以立马找一个人来代替你，不要认为加班是理所当然的，你加班领导就会看到，说你愿意为公司付出?我认为这就是狗屁逻辑，我遇到的和我周围的认识的一些程序员都比较老实(我想大多程序员给人的感觉就是不善言谈，老实肯干吧)，我之前也问过我的一些程序员朋友，我说你们怎么老是加班？你们加班都是做什么？他说其实也没有什么事做，因为领导没走，所以他也不好意思走。就这样我们的时间就白白浪费掉了，我感觉没有任何必要，做人嘛，还是真实一点好，该怎样就怎样，完全没必要做哪些虚的，面子上的事情，说小了是浪费时间，说大了简直就是浪费生命！还有一部分人加班可能是真的学习，或者说由于自己的能力比较差，消化一下项目，如果是这样的话，我觉得是可以的，无可反对，因为对于我们这些做技术的来说，技术才是我们的看家本领，所以，我想说的是，我们应该反对无意义的加班！ 如果一个公司大张旗鼓的宣扬加班文化，或者说强制加班，说轻点就是没人性，说重点就是绑架员工，限制自由！一点也不为过，遇到这种公司我还是建议你尽早换地方吧，没人性的地方待久了你就也变的不是人了。也有一些领导给你说加班是为了学习，说的挺好的，没一点毛病，你感觉真的能靠加班学到多少东西，我一直提倡的是，工作时间提高工作效率，反对一切没有意义的加班，偶尔一次，因为项目上线或者紧急情况加班，是可以理解的也是可以接受的。 还有一些公司，加班不仅没有加班费，就连调休都没有，我对这样的公司真的是无语了，至少加班可以当做调休或者提供加班餐，这样员工才有心情给你加班，不然，作为员工，心是拔凉拔凉滴。 上面说了这么多，其实就一个问题，就是我们程序员身体健康问题，因为一旦我们生病的话，不仅要请假去医院看病付医药费，另外还有你的误工费等，都算是一笔不小的是支出，所以我们能做的就是常锻炼，强身健体，减少疾病发生的几率，至少每年体检一次，虽然我们程序员平时也不会出什么大病，但是常年累计下去，因为久坐会导致好多身体疾病，许多大病都是比较隐性的，说不定过年几年才会出现，不要到时候才后悔莫及，所以我们平时上班时最好有意识的注意一下，每隔半小时或者一小时走动一下，或者站着工作一会，然后再坐一会儿，平时多补充一些营养，多运动才是硬道理! 俗话说，你不理财，财不理你！这句话意思很显而易见，所以我们应该合理的分配自己的财产，合理理财，这样才能在用钱的时候不慌张。我觉得应该从以下几方面来理财，我们可以将自己每个月的工资分为几部分，一部分为每月必须支出的费用，例如房租、一日三餐等，另外一方面是不固定支出的，例如生活的一些必需品，衣物等东西，还有一部分就是必须强制存储的资产。我通常情况下，每个月发完工资后先交完房租，然后取出强制存储的钱，比如每月固定存储 2000 块，你可以存到固定的一个银行卡或者一个账户中，一般我是不太建议存到银行卡，因为利率比较低，我一般是将其投入到一些 P2P 理财产品中，一方面这些产品相比银行的利率高，差不多年利率都能达到 10% 左右，另外一方面相比股票等风险较低，属于稳健型投资理财，如果你的承受能力比较强的话，可以再分的细一些，可以将一小部分的比例投资到股票中，如果承受能力比较差，我不建议大家投资股票！另外一部分的工资就是平时吃饭或者购物消费的支出了，我建议可以把这部分的钱放入XX宝，或者XX金库中，因为这部分钱平时我们可以直接拿出来可以直接消费，比较灵活，因为这些都是属于基金的性质，每天还有一些收益，虽然收益不是很多，但是总比没有强吧。 可能对一部分人来说，强制存储比较难，好多生活在大都市的人都有一种感觉就是，每个月发完工资交完房租，在买一些其他的东西，总感觉还没买什么钱就没了，这种情况，我建议前期可以先少存一点，然后每个月逐渐递增，递增的速度你可以根据你收入水平进行合理的控制，其实我们每年的工资都是涨的，所以我们这样做也是合理的，这样看起来每个月没存多少，但是你日积月累个几年后其实也是一笔不菲的资产；另外一个我想说就是复利，为什么有钱人越来越有钱？因为有钱人会用钱生钱，我们可以将存储的资产一年后可以将本利和又作为本金来存储，这样就达到了复利的效果，因为我们的存的钱每年越来越多，利息也在不断的提高，这样我们的钱才能更好的生钱。 另外一方面，我个人的消费观念给大家普及一下，不要去购买自己不需要的廉价打折商品，有的人一看到打折的商品就心动了，然后就是买买买，买回来才发现，不是自己需要的东西，没什么用，这就是不理性的消费，打折商品再好，再便宜，如果不是自己需要的，买回来都是浪费！总结一句话就是：不要多买廉价商品，少买精品！给大家说一个例子，我之前也喜欢买便宜的东西，之前买鞋子，喜欢买一两百块钱的鞋子，买回来后发现穿一段时间不喜欢了，或者说穿一段时间坏了，一年买了好几双这样的鞋子，另外有一次下血本买了一双五六百块的鞋子，买回来中之后穿着很舒服，穿了很长时间也没什么质量问题，后来穿了两年多将近三年，后来觉得一年买几双便宜的还不如下血本买一双贵的，穿的时候也不会太纠结穿哪一双了，不是越贵的东西就越好，我是觉得，贵的东西一定在质量上是没有多大问题的，所以我宁愿花血本少买一些贵的质量好的，也不愿意少花钱买一堆质量不好的东西，这样下去，你会慢慢发现到后来你典藏下来的都是精品！ 好了，今天就说这么多吧，其实关于理财方面的知识还是非常多的，我也不是理财专家，本文只是浅显的对理财方面的知识跟大家普及一下，文中有些观点都是个人理解，如有不同，可以在评论区讨论。本文的写作来源源于最近读的一本书《好好赚钱》，也算是对阅读本书后的一点观后感小结吧，我强烈推荐大家阅读此书，因为有些东西可能是你之前不了解的，可能会对你产生一些影响。 推荐阅读： 不得不会的10点Java基础知识 MySQL8.0设置远程访问权限 更多干货文章请关注：]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>开源项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 使用 Glide 实现圆形和圆角图片]]></title>
    <url>%2F2017%2F09%2F24%2FAndroid%20%E4%BD%BF%E7%94%A8Glide%E5%AE%9E%E7%8E%B0%E5%9C%86%E5%BD%A2%E5%92%8C%E5%9C%86%E8%A7%92%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[1.实现圆形图片1.1自定义圆形处理工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import android.content.Context;import android.graphics.Bitmap;import android.graphics.BitmapShader;import android.graphics.Canvas;import android.graphics.Paint;import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;import com.bumptech.glide.load.resource.bitmap.BitmapTransformation;/** * Created by xpf on 2017/6/17 :) * Function:Glide Transformation 实现圆形图片 */public class GlideCircleTransform extends BitmapTransformation &#123; public GlideCircleTransform(Context context) &#123; super(context); &#125; @Override protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) &#123; return circleCrop(pool, toTransform); &#125; private static Bitmap circleCrop(BitmapPool pool, Bitmap source) &#123; if (source == null) return null; int size = Math.min(source.getWidth(), source.getHeight()); int x = (source.getWidth() - size) / 2; int y = (source.getHeight() - size) / 2; // TODO this could be acquired from the pool too Bitmap squared = Bitmap.createBitmap(source, x, y, size, size); Bitmap result = pool.get(size, size, Bitmap.Config.ARGB_8888); if (result == null) &#123; result = Bitmap.createBitmap(size, size, Bitmap.Config.ARGB_8888); &#125; Canvas canvas = new Canvas(result); Paint paint = new Paint(); paint.setShader(new BitmapShader(squared, BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP)); paint.setAntiAlias(true); float r = size / 2f; canvas.drawCircle(r, r, r, paint); return result; &#125; @Override public String getId() &#123; return getClass().getName(); &#125;&#125; 1.2用法123456Glide.with(mContext) .load(headpic) .diskCacheStrategy(DiskCacheStrategy.NONE) .transform(new GlideCircleTransform(mContext)) .crossFade() .into(ivIcon); 2.实现加载圆角图片2.1自定义圆角处理工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import android.content.Context;import android.content.res.Resources;import android.graphics.Bitmap;import android.graphics.BitmapShader;import android.graphics.Canvas;import android.graphics.Paint;import android.graphics.RectF;import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;import com.bumptech.glide.load.resource.bitmap.BitmapTransformation;/** * Created by xpf on 2017/6/17 :) * Function:Glide Transformation 实现圆角图片 */public class GlideRoundTransform extends BitmapTransformation &#123; private static float radius = 0f; public GlideRoundTransform(Context context) &#123; this(context, 4); &#125; public GlideRoundTransform(Context context, int dp) &#123; super(context); this.radius = Resources.getSystem().getDisplayMetrics().density * dp; &#125; @Override protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) &#123; return roundCrop(pool, toTransform); &#125; private static Bitmap roundCrop(BitmapPool pool, Bitmap source) &#123; if (source == null) return null; Bitmap result = pool.get(source.getWidth(), source.getHeight(), Bitmap.Config.ARGB_8888); if (result == null) &#123; result = Bitmap.createBitmap(source.getWidth(), source.getHeight(), Bitmap.Config.ARGB_8888); &#125; Canvas canvas = new Canvas(result); Paint paint = new Paint(); paint.setShader(new BitmapShader(source, BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP)); paint.setAntiAlias(true); RectF rectF = new RectF(0f, 0f, source.getWidth(), source.getHeight()); canvas.drawRoundRect(rectF, radius, radius, paint); return result; &#125; @Override public String getId() &#123; return getClass().getName() + Math.round(radius); &#125;&#125; 2.1用法示例12345Glide.with(mContext) .load(image_url) .transform(new GlideRoundTransform(mContext)) .crossFade() .into(ivCard); 当然圆角的radius可以自己定义，使用重载带radius的构造传入即可 好了，今天就到这里吧~ 夜深了，晚安咯(￣o￣) . z Z]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Glide</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 产生随机数]]></title>
    <url>%2F2017%2F09%2F24%2FAndroid%E4%BA%A7%E7%94%9F%E9%9A%8F%E6%9C%BA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[##1.产生指定位数的随机数 以产生6位数随机数为例 num 1234567产生其他位数随机数在最后面要乘的数即 *100000* 后加0即可##2.产生指定范围的随机数以产生[10,99]范围内的随机数为例 int min=10;int max=99;Random random = new Random();int num = random.nextInt(max)%(max-min+1) + min;` end ~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>随机数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 使用原生动画工具类实现平移动画]]></title>
    <url>%2F2017%2F09%2F24%2FAndroid%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%94%9F%E5%8A%A8%E7%94%BB%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%B9%B3%E7%A7%BB%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[1234567891011// 向右边移出llVideo.setAnimation(AnimationUtils.makeOutAnimation(this, true));// 向右边移入llVideo.setAnimation(AnimationUtils.makeInAnimation(this, true)); llVideo.setVisibility(View.VISIBLE);llVideo.setVisibility(View.GONE);// 向左边移入llVideo.setAnimation(AnimationUtils.makeInAnimation(this, false));// 向左边移出llVideo.setAnimation(AnimationUtils.makeOutAnimation(this, false));]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用 Git 命令手册]]></title>
    <url>%2F2017%2F09%2F24%2F%E5%B8%B8%E7%94%A8Git%E5%91%BD%E4%BB%A4%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[此文只是对Git有一定基础的人当记忆使用，比较简略，初级学员强烈推荐廖雪峰老师的Git系列教程，通俗易懂，戳此处即可开始学习 1.安装Git Linux 1sudo apt-get install git Window:到Git官网下载安装：https://git-scm.com/downloads 2.配置全局用户Name和E-mail12$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot; 3.初始化仓库1git init 4.添加文件到Git仓库1git add &lt;file&gt; 提示：可反复多次使用，添加多个文件； 5.提交添加的文件到Git仓库1git commit 然后会弹出一个Vim编辑器输入本次提交的内容； 或者 1git commit -m &quot;提交说明&quot; 6.查看仓库当前的状态1git status 7.比较当前文件的修改1$ git diff &lt;file&gt; 8.查看历史提交记录1git log 或者加上参数查看就比较清晰了 1$ git log --pretty=oneline 9.回退版本1$ git reset --hard HEAD^ 说明：在Git中，用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，以此类推，如果需要回退几十个版本，写几十个^容易数不过来，所以可以写，例如回退30个版本为：HEAD~30。 如果你回退完版本又后悔了，想回来，一般情况下是回不来的，但是如果你可以找到你之前的commit id的话，也是可以的，使用如下即可： 1$ git reset --hard + commit id 提示：commit id不需要写全，Git会自动查找； 补充说明：Git中，commit id是一个使用SHA1计算出来的一个非常大的数字，用十六进制表示，你提交时看到的一大串类似3628164…882e1e0的就是commit id（版本号）； 在Git中，版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向回退的版本，然后顺便刷新工作区文件； 10.查看操作的历史命令记录1$ git reflog 结果会将你之前的操作的commit id和具体的操作类型及相关的信息打印出来，这个命令还有一个作用就是，当你过了几天，你想回退之前的某次提交，但是你不知道commit id了，通过这个你可查找出commit id,就可以轻松回退了，用一句话总结：穿越未来，回到过去，so easy！ 11.diff文件1git diff HEAD -- &lt;file&gt; 说明：查看工作区和版本库里面最新版本文件的区别，也可以不加HEAD参数； ###12.丢弃工作区的修改 1$ git checkout -- &lt;file&gt; 说明：适用于工作区修改没有add的文件 13.丢弃暂存区的文件1$ git reset HEAD &lt;file&gt; 说明：适用于暂存区已经add的文件，注意执行完此命令，他会将暂存区的修改放回到工作区中，如果要想工作区的修改也丢弃，就执行第12条命令即可； 14.删除文件1$ rm &lt;file&gt; 然后提交即可； 如果不小心删错了，如果还没有提交的话使用下面命令即可恢复删除，注意的是它只能恢复最近版本提交的修改，你工作区的修改是不能被恢复的！ 1$ git checkout -- &lt;file&gt; 15.创建SSH key1$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 一般本地Git仓库和远程Git仓库之间的传输是通过SSH加密的，所以我们可以将其生成的公钥添加到Git服务端的设置中即可，这样Git就可以知道是你提交的了； 16.与远程仓库协作1$ git remote add origin git@github.com:xinpengfei520/IM.git 删除本地库与远程库的关联： 1$ git remote rm origin 作用：有时候我们需要关联其他远程库，需要先删除旧的关联，再添加新的关联，因为如果你已经关联过了就不能在关联了，不过想关联多个远程库也是可以的，前提是你的本地库没有关联任何远程库，操作如下： 先关联Github远程库： 1$ git remote add github git@github.com:xinpengfei520/IM.git 接着关联码云远程库： 1$ git remote add gitee git@gitee.com:xinpengfei521/IM.git 现在，我们用remote -v```查看远程库的关联信息，如果看到两组关联信息就说明关联成功了；1234ok,现在我们的本地库可以和多个远程库协作了如果要推送到GitHub，使用命令： $ git push github master12如果要推送到码云，使用命令： $ git push gitee master12### 17.推送到远程仓库 $ git push -u origin master1234注意：第一次提交需要加一个参数-u,以后不需要推送master到远程库 $ git push origin master12推送branch1到远程库 $ git push origin branch1123推送分支时需要注意，你在那个分支时就推那个分支！例如，不可以在master分支推到其他分支上去！！！### 18.克隆一个远程库 $ git clone git@github.com:xinpengfei520/IM.git1234### 19.Git分支管理创建一个分支branch1 $ git branch branch112切换到branch1分支： $ git checkout branch112创建并切换到branch1分支： $ git checkout -b branch112查看分支： $ git branch1234提示：显示的结果中，其中有一个分支前有个*号，表示的是当前所在的分支；合并branch1分支到master： $ git merge branch112删除分支： $ git branch -d branch112拉取一个远程的分支的同时并创建一个本地分支： $ git fetch origin branch:branch12### 20.查看提交的历史记录 $ git log12命令可以看到分支合并图 git log –graph1234### 21.合并分支禁用Fast forward模式合并分支 $ git merge –no-ff -m “merge” branch112345678910说明：默认Git合并分支时使用的是Fast forward模式，这种模式合并，删除分支后，会丢掉分支信息，所以我们需要强制禁用此模式来合并；补充内容：实际开发中分支管理的策略 - master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面提交； - 我们可以新开一个dev分支，也就是说dev分支是不稳定的，到版本发布时，再把dev分支合并到master上，在master分支发布新版本； - 你和你的协作者平时都在dev分支上提交，每个人都有自己的分支，时不时地往dev分支上合并就可以了；### 22.保存工作现场 $ git stash1234作用：当你需要去修改其他内容时，这时候你的工作还没有做完，先临时保存起来，等干完其他事之后，再回来回复现场，再继续干活；为什么？因为暂存区是公用的，如果不通过stash命令隐藏，会带到其它分支去；查看已经保存的工作现场列表： $ git stash list12恢复工作现场(恢复并从stash list删除)： $ git stash pop12或者： git stash apply1恢复工作现场，但stash内容并不删除，如果你需要删除执行如下命令： $ git stash drop12恢复指定的stash: $ git stash apply stash@{0}123456说明：其中stash@&#123;0&#125;为```git stash list```中的一种编号### 23.丢弃一个没有被合并过的分支强行删除即可： $ git branch -D 1234作用：实际开发中，添加一个新feature，最好新建一个分支，如果要丢弃这个没有被合并过的分支，可以通过上面的命令强行删除；### 24.查看远程库的信息 $ git remote12显示更详细的信息： $ git remote -v1234### 25.拉取分支拉取master到本地 $ git pull origin master12拉取 branch1 分支的内容到本地 $ git pull origin branch11234拉取时要注意本地已经有和远程分支对应了，如果没有的话，参考 19 中，拉取并创建本地分支，拉取时需要注意，你在那个分支时就拉取个分支！不可以在 master 分支拉取其他分支下来，这样会把远程的其他分支拉取下来和本地master分支合并！！！引起不必要的麻烦！如果不小心拉取下来了，就可以使用下面的命令，恢复到上一次提交： $ git reset HEAD^12### 26.创建本地分支 $ git checkout -b branch1 origin/branch11234说明：如果远程库中有分支，clone之后默认只有master分支的，所以需要执行如上命令来创建本地分支才能与远程的分支关联起来；### 27.指定本地branch1分支与远程origin/branch1分支的链接 $ git branch –set-upstream branch1 origin/branch11234作用：如果你本地新建的branch1分支，远程库中也有一个branch1分支(别人创建的)，而刚好你也没有提交过到这个分支，即没有关联过，会报一个```no tracking information```信息，通过上面命令关联即可；### 28.创建标签 $ git tag 12例如：```git tag v1.0 查看所有标签： 1$ git tag 对历史提交打tag 先使用git log --pretty12例如对commit id 为123456的提交打一个tag: $ git tag v0.9 12345612查看标签信息： $ git show 12eg:```git show v1.0 创建带有说明的标签，用-a指定标签名，-m指定说明文字，123456为commit id： 1$ git tag -a v1.0 -m &quot;V1.0 released&quot; 123456 用私钥签名一个标签： 1$ git tag -s v2.0 -m &quot;signed V2.0 released&quot; 345678 说明：签名采用PGP签名，因此，必须先要安装gpg（GnuPG），如果没有找到gpg，或者没有gpg密钥对，就会报错，具体请参考GnuPG帮助文档配置Key； 作用：用PGP签名的标签是不可伪造的，因为可以验证PGP签名； 删除标签： 1$ git tag -d &lt;tagname&gt; 删除远程库中的标签： 比如要删除远程库中的 V1.0 标签，分两步： [1] 先删除本地标签：git tag -d V1.0```12[2] 再推送删除即可：```$ git push origin :refs/tags/V1.0 推送标签到远程库： 1$ git push origin &lt;tagname&gt; 推送所有标签到远程库： 1$ git push origin --tags 29.自定义Git设置Git显示颜色，会让命令输出看起来更清晰、醒目： 1$ git config --global color.ui true 设置命令别名： 1$ git config --global alias.st status 说明：–global表示全局，即设置完之后全局生效，st表示别名，status表示原始名 好了，现在敲st```就相当于是```git status```命令了，是不是方便？12345当然还有其他命令可以简写，这里举几个：很多人都用co表示checkout，ci表示commit，br表示branch...根据自己的喜好可以设置即可，个人觉得不是很推荐使用别名的方式；推荐一个比较丧心病狂的别名设置： git config –global alias.lg “log –color –graph –pretty=format:’%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset’ –abbrev-commit”123456789101112131415161718效果自己去体会...其他说明：配置的时候加上--global是针对当前用户起作用的，如果不加只对当前的仓库起作用；每个仓库的Git配置文件都放在 **.git/config** 文件中，我们可以打开对其中的配置作修改，可以删除设置的别名；而当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中，我们也可以对其进行配置和修改。### 30.忽略文件规则原则： - 忽略系统自动生成的文件等； - 忽略编译生成的中间文件、可执行文件等，比如Java编译产生的.class文件，自动生成的文件就没必要提交； - 忽略你自己的带有敏感信息的配置文件，个人相关配置文件； - 忽略与自己相关开发环境相关的配置文件； - ...使用：在Git工作区的根目录下创建一个特殊的 **.gitignore** 文件，然后把要忽略的文件名或者相关规则填进去，Git就会自动忽略这些文件，不知道怎么写的可参考：[https://github.com/github/gitignore](https://github.com/github/gitignore),这里提供了一些忽略的规则，可供参考；如果你想添加一个被 **.gitignore** 忽略的文件到Git中，但发现是添加不了的，所以我们可以使用强制添加```$ git add -f &lt;file&gt; 或者我们可以检查及修改 .gitignore 文件的忽略规则： 1$ git check-ignore -v &lt;file&gt; Git会告诉我们具体的 .gitignore 文件中的第几行规则忽略了该文件，这样我们就知道应该修改哪个规则了； 如何忽略已经提交到远程库中的文件？如果你已经将一些文件提交到远程库中了，然后你想忽略掉此文件，然后在 .gitignore 文件中添加忽略，然而你会发现并没有生效，因为Git添加忽略时只有对没有跟踪的文件才生效，也就是说你没有add过和提交过的文件才生效，按如下命令： 比如说：我们要忽略.idea目录，先删除已经提交到本地库的文件目录 1git rm --cached .idea 格式：git rm –cached + 路径 如果提示：fatal: not removing ‘.idea’ recursively without -r 加个参数 -r 即可强制删除 1$ git rm -r --cached .idea 然后，执行git status会提示你已经删除.idea目录了，然后执行commit再push就可以了，此时的.idea目录是没有被跟踪的，将.idea目录添加到 .gitignore 文件中就可以忽略了。 附图： 好了，基本差不多了，其实常用的命令也就那么几个，如果使用多了，就熟练了，相信git给我们工作效率及工作上的提升… 声明：附图来自CSDN知识库，仅作为学习交流用；]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 实现 Bitmap 高斯模糊效果]]></title>
    <url>%2F2017%2F09%2F24%2FAndroid%E5%AE%9E%E7%8E%B0Bitmap%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[1.自定义高斯模糊工具类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import android.content.Context;import android.graphics.Bitmap;import android.renderscript.Allocation;import android.renderscript.Element;import android.renderscript.RenderScript;import android.renderscript.ScriptIntrinsicBlur;/** * Created by xpf on 2017/6/24 :) * Function:实现高斯模糊工具类 */public class BlurBitmapUtil &#123; // 图片缩放比例(即模糊度) private static final float BITMAP_SCALE = 0.4f; /** * @param context 上下文对象 * @param image 需要模糊的图片 * @return 模糊处理后的Bitmap */ public static Bitmap blurBitmap(Context context, Bitmap image, float blurRadius) &#123; // 计算图片缩小后的长宽 int width = Math.round(image.getWidth() * BITMAP_SCALE); int height = Math.round(image.getHeight() * BITMAP_SCALE); // 将缩小后的图片做为预渲染的图片 Bitmap inputBitmap = Bitmap.createScaledBitmap(image, width, height, false); // 创建一张渲染后的输出图片 Bitmap outputBitmap = Bitmap.createBitmap(inputBitmap); // 创建RenderScript内核对象 RenderScript rs = RenderScript.create(context); // 创建一个模糊效果的RenderScript的工具对象 ScriptIntrinsicBlur blurScript = ScriptIntrinsicBlur.create(rs, Element.U8_4(rs)); // 由于RenderScript并没有使用VM来分配内存,所以需要使用Allocation类来创建和分配内存空间 // 创建Allocation对象的时候其实内存是空的,需要使用copyTo()将数据填充进去 Allocation tmpIn = Allocation.createFromBitmap(rs, inputBitmap); Allocation tmpOut = Allocation.createFromBitmap(rs, outputBitmap); // 设置渲染的模糊程度, 25f是最大模糊度 blurScript.setRadius(blurRadius); // 设置blurScript对象的输入内存 blurScript.setInput(tmpIn); // 将输出数据保存到输出内存中 blurScript.forEach(tmpOut); // 将数据填充到Allocation中 tmpOut.copyTo(outputBitmap); return outputBitmap; &#125;&#125; 2.使用示例1234567if (image != null) &#123; Bitmap blurBitmap = BlurBitmapUtil.blurBitmap(mContext, image, 20); blurView.setImageBitmap(blurBitmap); &#125; else &#123; // 如果image为null就设置一张本地默认的模糊照片 blurView.setImageResource(R.drawable.img_mohu); &#125; Thanks all. Good night~]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Bitmap</tag>
        <tag>Android</tag>
        <tag>高斯模糊</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 最全 Intent 传递数据姿势]]></title>
    <url>%2F2017%2F09%2F24%2FAndroid%20%E6%9C%80%E5%85%A8%20Intent%20%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE%E5%A7%BF%E5%8A%BF%2F</url>
    <content type="text"><![CDATA[点击上面蓝色字体关注“IT大飞说”置顶公众号（ID：ITBigFly）第一时间收到推送 作为一个 Android 开发人员，我们都是用过 Intent，用它来在组件之间传递数据，所以说 Intent 是组件之间通信的使者，一般情况下，我们传递的都是一些比较简单的数据，并且都是基本的数据类型，写法也比较简单，今天我在这里说的是如何使用 Intent 传递对象及集合，我们知道Intent 是不能直接传递没有序列化的对象的，说到序列化，我们都知道，序列化有两种方式，即实现 Sereriable 或者 Paracelable 接口。默认情况下，像 List、Bitmap 等默认帮我们已经实现了序列化，我们就可以直接进行传递，还有一些像 Map 集合，自定义的 class，默认是没有实现序列化的接口的，我们必须要先实现序列化才可以进行传递。 1.传递序列化对象1.1 方式一这种方式比较简单，我们可以先将对象使用 Gson 先序列化成 Json 字符串，然后作为字符串来使用 Intent，这种方式的好处是不需要实现 Sereriable 或者 Paracelable，坏处就是需要额外的使用 Gson 来序列化和解析。 代码示例： ActivityA 中设置数据： 123456User user = new User();user.setName(&quot;Jack&quot;);user.setAge(18);Intent intent=new Intent(ActivityA.this,ActivityB.class);intent.putExtra(&quot;user&quot;,new Gson().toJson(user));startActivity(intent); ActivityB 中获取数据： 12String json = getIntent().getStringExtra(&quot;user&quot;);User user = new Gson().fromJson(json,User.class); 1.2 方式二这种方式就是将数据封装到 Bundle 中然后把 Bundle 对象调用 Intent 的 putExtra 方法然后传递过去，Bundle 类默认也是已经实现了 Parcelable 接口的，所以可以传递 Bundle 对象。 代码示例： ActivityA 中设置数据： 12345 // 创建一个Bundle对象封装数据 Bundle data = new Bundle(); data.putInt(&quot;age&quot;,18); data.putString(&quot;name&quot;,&quot;Jack&quot;);intent.putExtra(&quot;data&quot;,data); ActivityB 中获取数据： 123Bundle data = getIntent().getBundleExtra(&quot;data&quot;);int id = data.getInt(&quot;age&quot;);String name = data.getString(&quot;name&quot;); 1.3 方式三传递实现了 Serializable 接口的对象，这种方式也比较简单，传递之前先实现 Serializable 接口，也不需要重写方法。 代码示例： ActivityA 中设置数据： 12345678User user = new User();user.setName(&quot;Jack&quot;);user.setAge(18);Intent intent=new Intent(ActivityA.this,ActivityB.class);Bundle bundle = new Bundle();bundle.putSerializable(&quot;user&quot;, user);intent.putExtras(bundle);startActivity(intent); ActivityB 中获取数据： 12Intent intent = getIntent(); User user = (User)intent.getSerializableExtra(&quot;user&quot;); 1.4 方式四传递实现了 Parcelable 接口的对象，这种方式比实现 Serializable 接口的方式稍微麻烦一点，需要重写方法，不过我们程序员都是比较懒的，给大家推荐一个插件： android-parcelable-intellij-plugin ，安装完之后就可以使用快捷键自动生成实现了 Serializable 接口的对象了，是不是比较方便。 实现 Serializable 对象的 User 类示例代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class User implements Parcelable &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public int describeContents() &#123; return 0; &#125; @Override public void writeToParcel(Parcel dest, int flags) &#123; dest.writeString(this.name); dest.writeInt(this.age); &#125; public User() &#123; &#125; protected User(Parcel in) &#123; this.name = in.readString(); this.age = in.readInt(); &#125; public static final Parcelable.Creator&lt;User&gt; CREATOR = new Parcelable.Creator&lt;User&gt;() &#123; @Override public User createFromParcel(Parcel source) &#123; return new User(source); &#125; @Override public User[] newArray(int size) &#123; return new User[size]; &#125; &#125;;&#125; 传递数据的方法和 Serializable 类似，还是写一下把： 代码示例： ActivityA 中设置数据： 12345678User user = new User();user.setName(&quot;Jack&quot;);user.setAge(18);Intent intent=new Intent(ActivityA.this,ActivityB.class);Bundle bundle = new Bundle();bundle.putParcelable(&quot;user&quot;, user);intent.putExtras(bundle);startActivity(intent); ActivityB 中获取数据： 12Intent intent = getIntent(); User user = (User)intent.getParcelableExtra(&quot;user&quot;); 2.传递集合类2.1 传递 List 集合数据如果我们要传递的 List 集合，我们可以把 List 强转成 Serializable 类型，List 默认是实现了 Serializable 接口的，但是注意 List 的泛型类也必须要实现了 Serializable 接口，基本类型及包装类就不用了。 代码示例： ActivityA 中设置数据： 1234567891011121314User user1 = new User();user1.setName(&quot;Jack&quot;);user1.setAge(18);User user2 = new User();user2.setName(&quot;Marry&quot;);user2.setAge(20);List&lt;User&gt; list = new ArrayList&lt;&gt;(); list.add(user1); list.add(user2);Intent intent = new Intent(ActivityA.this,ActivityB.class);intent.putExtras(&quot;list&quot;,(Serializable)list);startActivity(intent); ActivityB 中获取数据： 12Intent intent = getIntent(); List&lt;User&gt; list = (List&lt;User&gt;) getIntent().getSerializableExtra(&quot;list&quot;); 2.2 传递 Map 集合数据Map接口及他的实现类默认是没有实现序列化的接口的，我们要想传递 Map 就要让 Map 实现序列化接口，我们可以自定义一个类，以HashMap为例吧，我们的类就叫 SerializableHashMap 吧，然后让定义一个 Map 变量作为成员属性并实现序列化接口，这样我们的类就可以进行传递了，SerializableHashMap 的实现如下： 1234567891011121314151617181920public class SerializableHashMap implements Serializable &#123; private HashMap&lt;String, String&gt; map; public SerializableHashMap() &#123; &#125; public SerializableHashMap(HashMap&lt;String, String&gt; map) &#123; this.map = map; &#125; public HashMap&lt;String, String&gt; getMap() &#123; return map; &#125; public void setMap(HashMap&lt;String, String&gt; map) &#123; this.map = map; &#125;&#125; 代码示例： ActivityA 中设置数据： 1234567891011HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;name&quot;, &quot;Jack&quot;); map.put(&quot;age&quot;, 18);SerializableHashMap sMap = new SerializableHashMap(); sMap.setMap(map); // 将map数据添加到封装的sMap中 Bundle bundle = new Bundle(); bundle.putSerializable(&quot;map&quot;, sMap); Intent intent = new Intent(ActivityA.this,ActivityB.class); intent.putExtras(bundle);startActivity(intent); ActivityB 中获取数据： 1234Intent intent = getIntent(); Bundle bundle = intent.getExtras(); SerializableHashMap sMap = (SerializableHashMap) bundle.get(&quot;map&quot;); HashMap&lt;String, Object&gt; map = sMap.getMap(); 2.3 如何选择？另外，默认 Intent 帮我们实现了，可以支持传递 String 数组等，也比较简单，这里就不赘述了，另外如果数据量比较大的情况下，建议使用第三方框架来进行传递数据，例如：EventBus 等来代替，这样的话可以避免造成 TransactionTooLargeException。 如何选择哪种序列化方式？弄清楚他们的区别，你也就知道使用哪个更合适了。 Serializable 和 Parcelable 接口的区别： 在使用内存的时候，Parcelable 比 Serializable 性能高，所以推荐使用 Parcelable； Serializable 在序列化的时候会产生大量的临时变量，从而引起频繁的 GC； Parcelable 不能使用在要将数据存储在磁盘上的情况，因为 Parcelable 不能很好的保证数据的 持续性，在外界有变化的情况下，尽管 Serializable 效率低点，但此时还是建议使用Serializable； 好了，今天的分享就到这里，我还是你们的大飞哥，喜欢我的文章的就点个赞，点赞的人最可爱！ 猜你喜欢：给大家推荐一个神器深入浅出Retrofit2.x(一)MySQL8.0设置远程访问权限不得不会的10点Java基础知识CentOS7 重置 MySQL 8.0 密码 扫一扫，开启我们的的缘分可能不是最好的公众号，但肯定是最良心的公众号!]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Intent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 冷启动白屏问题]]></title>
    <url>%2F2017%2F09%2F24%2FAndroid%E5%86%B7%E5%90%AF%E5%8A%A8%E7%99%BD%E5%B1%8F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[点击上面蓝色字体关注“IT大飞说”置顶公众号（ID：ITBigFly）第一时间收到推送 本篇文章来自「UartAnd7c」的投稿原文地址：https://www.jianshu.com/p/9495ba92c138 原作者简书主页：https://www.jianshu.com/u/621bfbc7c878UartAnd7c 是一个在简书坚持原创的 Android 开发者，欢迎大家关注！ 今天把玩公司App发现了一个有趣的现象。启动app白屏。之前没太留意过；在参照大厂App解决白屏的方案后。简单汇总一下。 ###前言冷启动：App第一次启动的时候会加载一个Application进程，首先会创建和初始化Appliation类，然后在加载Activity。热启动：利用后台已经拥有的进程，从而避免了Application的加载。直接去加载Activity。 解决白屏的方案大致有以下四种 加入动画 使用占位图 使用图片 使用windowDisablePreview属性 这里我就描述一下使用占位图和windowDisablePreview属性 ####windowDisablePreview属性 123&lt;style name=&quot;SplashTheme&quot; parent=&quot;AppTheme&quot;&gt; &lt;item name=&quot;android:windowDisablePreview&quot;&gt;true&lt;/item&gt; &lt;/style&gt; 在AndroidManifest中設置主Activity的theme值，在主Activity中还原。 123456@Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; setTheme(R.style.AppTheme); getWindow().setBackgroundDrawableResource(R.drawable.main_splash_bg); super.onCreate(savedInstanceState); &#125; 运行后发现启动App延迟几秒后跳转到主Activity（有点类似掌上英雄联盟，会让用户误以为是自己手机的问题）。 ####使用占位图 1234&lt;style name=&quot;SplashTheme&quot; parent=&quot;AppTheme&quot;&gt; &lt;item name=&quot;android:windowBackground&quot;&gt;@drawable/shape_launch&lt;/item&gt; &lt;item name=&quot;android:windowFullscreen&quot;&gt;true&lt;/item&gt; &lt;/style&gt; 1234567891011&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:opacity=&quot;opaque&quot;&gt; &lt;item android:drawable=&quot;@android:color/white&quot;/&gt; &lt;item&gt; &lt;bitmap android:src=&quot;@mipmap/main_splash_bg&quot; android:gravity=&quot;fill&quot; /&gt; &lt;/item&gt;&lt;/layer-list&gt; 使用windowBackground属性来完成其他操作同windowDisablePreview属性的设置。运行后发现明显白屏问题得到有效解决。 ###参考文献 gitHub地址:https://github.com/saulmm/onboarding-examples-android#onboarding-with-a-placeholdergoogle论坛:https://plus.google.com/+AndroidDevelopers/posts/Z1Wwainpjhd 温馨提示：点击「阅读原文」可查看原作者简书原文。 猜你喜欢：深入浅出Retrofit2.x(一)深入浅出Retrofit2.x(二)Android 最全 Intent 传递数据姿势 欢迎扫码关注我的公众号]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS7 安装 MySQL 8.0)]]></title>
    <url>%2F2017%2F09%2F24%2FCentOS7%E5%AE%89%E8%A3%85MySQL8.0%2F</url>
    <content type="text"><![CDATA[个人服务器搭建一个 MySQL 数据库，来读写一些简单的接口数据处理。 废话不多说，直接撸起。 1.切换到用户目录 1cd ~ 2.下载 rpm 包 在官网找到对应的 MySQL 的源，我们选择 mysql80-community-release-el7-1.noarch.rpm 社区免费正式发布版8.0 1wget https://repo.mysql.com//mysql80-community-release-el7-1.noarch.rpm 3.安装 rpm 包 1rpm -ivh mysql80-community-release-el7-1.noarch.rpm 4.修改 MySQL 的repo源，使MySQL8.0可用 使用 vim 编辑 1vi /etc/yum.repos.d/mysql-community.repo 找到 [mysql80-community] 确保 enabled=1 修改，保存并退出。 5.安装 mysql-server 1yum install mysql-server 开始下载并安装 MySQL，中间会有几次询问你，一路 yes 即可，等待直到完成。 6.修改 MySQL 的访问权限 1chown -R root:root /var/lib/mysql 7.重启 MySQL 服务 1service mysqld restart 至此 MySQL8.0 的安装就算完成了。 安装完成后，我们要登录使用 MySQL，但是我们需要访问的密码，安装的时候已经为我们生成了一个随机密码，我们必须重置密码才能使用，因为 MySQL8.0 的密码重还比较麻烦，下一篇我来讲解如何重置密码。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Window10磁盘分区]]></title>
    <url>%2F2017%2F09%2F24%2FWindow10%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[好多童鞋新买的电脑，系统默认的是C盘占了所有的空间，这样我们管理起来很不方便，好多东西全部都混在一个C盘中，对于一个追求条理的人来说，特别不爽！因此要自己对磁盘进行分区；我个人喜欢一般会将磁盘分为四个区，C盘装系统，D盘装软件，E盘装自己的一些文件和资料，F盘为娱乐，比如游戏和电影等。 下面我们就来进行分盘：前提是系统已经装好了，我们就不需要重装系统了，我们还有一些资料，分完区之后我们的资料也不会丢失，详细步骤如下： 1.快捷键win+X,打开磁盘分区，对要分区的磁盘进行压缩，输入分出的磁盘大小执行压缩，然后对分出来的分区右键执行新建分区，然后一路点击下一步即可，它的原理是压缩出磁盘分区中空白的区域，然后进行逻辑分区，因此不会覆盖和影响之前已经存储的区域。至于每个分区的大小就看个人的喜好了。 详细图文请看下面组图↓ 最后感谢下面的文章： 参考图文教程：http://jingyan.baidu.com/article/425e69e6bbd0c7be14fc164a.html]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>硬盘分区</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL8.0设置远程访问权限]]></title>
    <url>%2F2017%2F09%2F01%2FMySQL8.0%E8%AE%BE%E7%BD%AE%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%2F</url>
    <content type="text"><![CDATA[上一篇文章讲解了重置 MySQL 的密码，有同学反馈无法程连接到数据库，这是因为 MySQL 安装完成后只支持 localhost 访问，我们必须设置一下才可以远程访问，另外还有一些 MySQL 8.0 连接时的一些问题，本文也会一并进行讲解如何解决。 1.登录MySQL 1mysql -u root -p 输入您的密码 2.选择 mysql 数据库 1use mysql; 因为 mysql 数据库中存储了用户信息的 user 表。 3.在 mysql 数据库的 user 表中查看当前 root 用户的相关信息 1select host, user, authentication_string, plugin from user; 执行完上面的命令后会显示一个表格 查看表格中 root 用户的 host，默认应该显示的 localhost，只支持本地访问，不允许远程访问。 4.授权 root 用户的所有权限并设置远程访问 1GRANT ALL ON *.* TO &apos;root&apos;@&apos;%&apos;; GRANT ALL ON 表示所有权限，% 表示通配所有 host，可以访问远程。 5.刷新权限 所有操作后，应执行 1flush privileges; 6.查看 root 用户的 host 再次执行步骤 2，你会发现 root 用户的 host 已经变成 %，说明我们的修改已经成功，可以远程访问了。 7.访问数据库 远程访问数据库的可视化工具比较多如：Navicat、SQLyog、MySQL workbench 等，我这里使用 Navicat 输入访问的 host 和密码，报 2059 错误，这是因为 MySql8.0 版本 和 5.0 的加密规则不一样，而现在的可视化工具只支持旧的加密方式。 此问题有两种方法，一种是更新 Navicat 驱动来解决此问题，另一种是将 MySQL 用户登录的加密规则修改为 mysql_native_password，第一种方法我试过了没有起作用，我这里采用第二种方法。 8.修改加密规则 1ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;password&apos; PASSWORD EXPIRE NEVER; password 为你当前密码。 9.更新 root 用户密码 1ALTER USER &apos;root&apos;@&apos;%&apos; IDENTIFIED WITH mysql_native_password BY &apos;password&apos;; password 为你新设置的密码。 10.刷新权限 1FLUSH PRIVILEGES; OK，设置完成，再次使用 Navicat 连接数据库，oh yeah~ 完美解决！]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>CentOS</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC 访问 MySQL 数据库踩坑]]></title>
    <url>%2F2017%2F08%2F24%2FJDBC%E8%AE%BF%E9%97%AEMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B8%A9%E5%9D%91%2F</url>
    <content type="text"><![CDATA[作为一个 Android 开发者，闲来无事，想着使用 JSP + Servlet 写一些简单的接口，然后通过前端调用接口，后端的数据库使用的是 MySQL。 1.安装 MySQL 数据库安装比较简单，打开 MySQL 官网，我们是个人使用，所以下载最新的（8.0）社区免费版即可。 安装过程中可能需要您设置管理员密码，默认账号为 root,安装完成后就可以启动 MySQL 服务了，Windows下的启动命令如下： 使用管理员权限打开Windows PowerShell 开启MySQL服务： start mysql80```12关闭MySQL服务： ```net stop mysql80 2.连接 MySQL 服务我们要创建并操作数据库首先要连接到数据库，连接数据的可视化工具比较多，如 Navicat、 MySQL Workbench、 SQLyog 等，当然，如果你对 MySQL 的命令行比较熟练的话，也可以使用命令来进行相关操作，我个人比较喜欢使用 Navicat。 注意，如果在连接的时候出现连接错误，前提是密码正确，大概报的意思是不支持老的密码方式，也就是说你的可视化工具的版本太低了，使用最新的可视化工具，或者在安装的时候，有两个选项，一个是增强型密码一个是非增强型密码，我们选择非增强型密码即可。 连接上之后我们就可以建数据库建表了，因为我们都是写一些简单的接口，所以不是很复杂我们手动建表，一般实际开发都是使用模型可视化工具来建表，当然表之间的关系也就比较复杂了。 3.JDBC 访问数据库因为只是练习使用，所以没使用框架，代码中使用原始的 JDBC 来连接并访问数据库 主要代码如下： 加载驱动，获取连接 12345678910111213public DBHelper(String sql) &#123; try &#123; Class.forName(name); conn = DriverManager.getConnection(url, user, password); if (conn != null) &#123; pst = conn.prepareStatement(sql); &#125; else &#123; System.out.println(&quot;conn is null !&quot;); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 在测试的过程中报异常了： 1conn is null ! 拿不到数据库连接，我期初判断是不是防火墙问题，后来检查了一下，防火墙没问题，而且我访问的是我本地的数据库，继续检查是不是端口的问题，检查了一下 3306 端口就 mysql 占用了，也没有问题。 很是纳闷，因为使用 Navicat 是可以连接上数据库的，理论上代码应该也是没有问题的，JDBC 连接就几行代码，怎么会有问题？后来网上搜了一大堆，都没有解决问题；后来想了想可能是驱动包太旧了吧，我看了一下，现在使用的是 ，然后我到网上下载了一个 ```mysql-connector-java-5.1.30-bin.jar``` 驱动包，比之前的新一点，替换掉，运行了一下，还是一样的问题。卡了好几天，然后，我让公司的后台帮忙看看，他说代码也没有什么问题，他说很奇怪，然后他给我一个我们公司的数据库，然后我代码中去连接，是可以拿到数据库连接的，访问没有问题，说明代码也是没有问题的，只能怀疑是数据库的问题了，后来网上搜索了一下，可能是数据库权限的问题，我看了一下数据库用户的权限，都是全选的，也没有问题。1234后来还是在网上搜，无意中看到一篇文章 [https://blog.csdn.net/tuna_lxg/article/details/40188659](https://blog.csdn.net/tuna_lxg/article/details/40188659) 大概的意思还是说驱动包太旧了，然后最新的驱动包是可以通过 官网下载 MySQL Connector/J驱动包解压缩后，将 MySQL-connector-Java-x.x-bin.jar拷贝到项目中即可，然后我立即下载了一个安装包，解压后提取出其中的 jar 包，放在项目中，（注意新驱动包的name为“com.mysql.cj.jdbc.Driver” 旧包中没有cj）运行起来，访问接口，报如下异常：![这里写图片描述](https://img-blog.csdn.net/20180520001234929?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbnBlbmdmZWk1MjE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70) Caused by: com.mysql.cj.exceptions.InvalidConnectionAttributeException: The server time zone value ‘ÖÐ¹ú±ê×¼Ê±¼ä’ is unrecognized or represents more than one time zone. You must configure either the server or JDBC driver (via the serverTimezone configuration property) to use a more specifc time zone value if you want to utilize time zone support.12翻译过来就是： 引起的:com.mysql.cj.exceptions。InvalidConnectionAttributeException:服务器时区价值”OÐ¹u±e×¼e±¼的识别或代表多个时区。您必须配置服务器或JDBC驱动程序(通过serverTimezone配置属性)，如果您想要利用时区支持，则需要使用更特殊的时区值。1234567891011121314网上搜到一篇博客的解决办法：[https://www.cnblogs.com/shanelau/p/7041293.html](https://www.cnblogs.com/shanelau/p/7041293.html)我是按第一种方法，在数据库的URL中加入 ```?serverTimezone=UTC```即可。然后再次运行项目，访问接口...哇！泪崩~终于 OK 了！oh yeah~看了一下 logcat 中打出如下警告： Establishing SSL connection without server’s identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn’t set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to ‘false’. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification.12翻译过来就是： 不建议在没有服务器身份验证的情况下建立SSL连接。根据MySQL 5.5.45+、5.6.26+和5.7.6+的要求，如果不设置显式选项，则必须建立默认的SSL连接。您需要通过设置useSSL=false来显式禁用SSL，或者设置useSSL=true并为服务器证书验证提供信任存储。` 因为本人有轻微强迫症，所以解决办法也比较简单在访问数据库的 URL 中加入 &amp;useSSL=false,然后重新运行项目，OK 警告没了，太爽了！ 至此这个问题就算完美解决了，哈哈~ 2018-5-20 虐狗节 -。-]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>JSP</tag>
        <tag>Servlet</tag>
        <tag>Navicat</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 设置 Activity 全屏的两种方式]]></title>
    <url>%2F2017%2F07%2F30%2FAndroid%E8%AE%BE%E7%BD%AEActivity%E5%85%A8%E5%B1%8F%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1.代码中在 Activity 的 onCreate() 方法中设置两个Flag： 12345super.onCreate(savedInstanceState);this.requestWindowFeature(Window.FEATURE_NO_TITLE);this.getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);setContentView(R.layout.loading); 注意书写位置要放在setContentView之前!!! 2.AndroidMenifest.xml文件中找到要设置的Activity声明标签，设置它的theme即可，例如： 123456789&lt;activity android:name=&quot;.MainActivity&quot; android:theme=&quot; @android :style/Theme.NoTitleBar.Fullscreen&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 如果要设置所有页面都为全屏的话就直接将theme属性添加到application标签中即可，例如： 12345&lt;application android:icon=&quot;@drawable/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:theme=&quot; @android :style/Theme.NoTitleBar.Fullscreen&quot;&gt; ... Thanks all. 2017.7.30 Beijing 晴]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
        <tag>Activity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不得不珍藏的 Chrome 插件推荐]]></title>
    <url>%2F2017%2F01%2F25%2F%E4%B8%8D%E5%BE%97%E4%B8%8D%E7%8F%8D%E8%97%8F%E7%9A%84Chrome%E6%8F%92%E4%BB%B6%E6%8E%A8%E8%8D%90%2F</url>
    <content type="text"><![CDATA[自从第一次使用 Chrome 就喜欢上了它简洁、还有 icon 的独特风格，越用越发喜欢，越用越爽，深陷其中不能自拔，从此走上了一条不归路… 现在好多程序员都喜欢用它，它的优点有很多： ①页面简洁、阅读舒服；②支持各种强大的插件；③支持浏览器内部应用程序；当然也有一些劣势，但是这些劣势可以忽略，我觉得其优点完全大于其不足。 今天我就给大家推荐一些非常好用的 Chrome 插件，其中有些是我自己现在用的，还有一些是我在网上照的还有别的人推荐的一些，我觉得如果熟练使用这些插件可以极大地提高工作和学习的效率，还有你的逼格可以瞬间提升一个档次，就光这点可以秒杀千千万万的屌丝，哈哈~(自己以后慢慢体会) 1.Infinity-New-Tab老规矩，先验货 xx:哇哦，好漂亮哦~ 惊讶吧，喜欢吧，亮瞎眼了吧，欣喜吧，爱上了吧…没错！就是她，这是我见过的最漂亮的Chrome插件，漂亮的不像实力派。下面我就来说说它漂亮在哪？如果你是个标签控，不知道怎么整理这些杂乱的标签，那么我告诉你你狠幸运，因为你遇见她了，它强大的标签管理功能，可以自定义添加好多标签，每个标签对应一个圆形的ICON，相当漂亮，而且图标也很有标志性，你可以一眼就能看出它是哪个网站，平时常用的网站都可以添加进来，这样的话就不用自己整理和保存了，还有背景大图可以自己更换，让你在工作的同时也不缺乏你赏景，可以添加一些大自然的景色，开拓一下视野，有的童鞋问：如果我更换电脑了或者卸载了，我自己添加的这些标签岂不没有了，别担心，你可以注册一个账号将其同步到云端，下次用的时候同步下来就可以了，是不是很简单？还有它切换和滚动时的动画看着也特别舒服，另外还有一大堆很强的自定义设置功能，这里就不一一列举了，自己去发掘吧。 插件官网地址： http://www.infinitynewtab.com/ 进去就可以看到很详细的安装步骤了。 2.Evernote-Web-Clipper这是一个很强大的剪藏插件，我们在浏览网页或者是看博客的时候遇到很多不错的文章，我们之前的做法是将网页离线保存下来或者将内容复制保存下来，没错这也是一种保存的办法，但是这种方法不容易查找，容易丢失，阅读也不方便，自从有了这款插件，我就深深地喜欢上它了，安装完插件之后，会在浏览器上生成一个剪藏的按钮，在你遇到喜欢的文章时，只需点击剪藏按钮就可以将它保存在你的印象笔记里了，如果没有登录会提示你登录账户，保存的时候可以选择全网页保存和正文保存，区别就是保存正文时会取消文中的广告，然后选择你要保存的笔记本，这样你就以后可以方便查找和阅读了，另外印象笔记还可以添加一些标签，以后通过标签也可以查找文章，手机上可以下载一个app，这样手机和电脑都同步了，不管在哪里，随时随地都可以尽情地开撕了…印象笔记官网剪藏功能介绍：https://www.yinxiang.com/webclipper/安装教程推荐：https://www.douban.com/group/topic/96693172/文末我会将所有插件打包下载地址进行公布，别急，后面更带劲！！！ 3.PostmanPostman 是一款功能强大的 HTTP 调试与模拟插件。前端的妹子或者是开发后台调试接口的哥们估计很熟悉吧。用户在开发或者调试网络程序或者是网页 B/S 模式的程序的时候是需要一些方法来跟踪网页请求的，用户可以使用一些网络的监视工具比如著名的 Firebug 等网页调试工具。今天给大家介绍的这款网页调试工具不仅可以调试简单的 css、html、脚本等简单的网页基本信息，它还可以发送几乎所有类型的 HTTP请求！Postman 在发送网络 HTTP 请求方面可以说是 Chrome 插件类产品中的代表产品之一。更多它的介绍访问： http://chromecj.com/web-development/2014-09/60.html 4.JSONViewJsonView 是一款 web 开发格式化和高亮插件 Chrome 插件，我们在开发的时候经常会先使用浏览器先访问以下接口，然后将返回的 json 进行格式化，有了这款插件就可以很清晰地看到 json 数据的格式了，如果是 Android 开发者再配合Android studio 的 gsonformat 插件，百试不爽！你懂得。推荐安装教程： http://www.cnblogs.com/androidstudy/p/5846210.html 5.OctotreeOctotree 是一个用来显示 Github 项目的目录结构的Chrome 插件，主要针对于广大的程序猿童鞋们，Github 上面成千上万的开源项目给程序猿带来很多帮助，还可以学习大神们的思想，向大神看齐。不过，在 Github 上查看源代码的体验十分糟糕，尤其是从一个目录跳转到另一个目录的时候，非常麻烦。octotree 插件就能很好地解决了上述问题。 安装教程： http://blog.csdn.net/wang4664/article/details/50965351 官方站点： https://github.com/buunguyen/octotree/ 最后推荐几个插件的网站，你可以找到好多很好用能提高效率的插件，还不赶紧去发掘一下？ 插件网：http://www.cnplugins.com/ 谷歌浏览器插件：http://chromecj.com 打包下载地址：链接：http://pan.baidu.com/s/1i43BWP3 密码：a66v 以上就是我给大家推荐的几个好用的插件，码字不易，呕心沥血，良心推荐，不转发和点赞真心说不过去！自己看着办吧。请大家继续关注，我会一直坚持我的干货分享，点击底部‘阅读原文’跳转到我个人博客。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Chrome</tag>
        <tag>Plugin</tag>
      </tags>
  </entry>
</search>
